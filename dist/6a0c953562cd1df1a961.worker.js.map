{"version":3,"sources":["webpack:///6a0c953562cd1df1a961.worker.js","webpack:///webpack/bootstrap 6a0c953562cd1df1a961","webpack:///./lib/workers/cam-preflight.js","webpack:///../~/poly2tri/src/xy.js","webpack:///../~/poly2tri/src/advancingfront.js","webpack:///../~/poly2tri/src/pointerror.js","webpack:///../~/poly2tri/src/triangle.js","webpack:///./lib/mesh.js","webpack:///../~/clipper-lib/clipper.js","webpack:///../~/eve/eve.js","webpack:///../~/poly2tri/src/assert.js","webpack:///../~/poly2tri/src/point.js","webpack:///../~/poly2tri/src/sweep.js","webpack:///../~/poly2tri/src/sweepcontext.js","webpack:///../~/poly2tri/src/utils.js","webpack:///../~/snapsvg-cjs/dist/snap.svg-cjs.js"],"names":["modules","hotCreateRequire","moduleId","ensure","chunkId","callback","hotStatus","hotSetStatus","hotChunksLoading","__webpack_require__","e","finishChunkLoading","hotWaitingFilesMap","hotEnsureUpdateChunk","hotWaitingFiles","hotUpdateDownloaded","call","fn","me","installedModules","request","hot","active","parents","indexOf","push","children","hotCurrentParents","console","warn","name","Object","prototype","hasOwnProperty","canDefineProperty","defineProperty","configurable","enumerable","get","set","value","hotCreateModule","_acceptedDependencies","_declinedDependencies","_selfAccepted","_selfDeclined","_disposeHandlers","accept","dep","i","length","decline","dispose","addDisposeHandler","removeDisposeHandler","idx","splice","check","hotCheck","apply","hotApply","status","l","hotStatusHandlers","addStatusHandler","removeStatusHandler","data","hotCurrentModuleData","newStatus","toModuleId","id","isNumber","Error","hotApplyOnUpdate","err","hotDownloadManifest","update","hotRequestedFilesMap","hotAvailibleFilesMap","c","hotUpdateNewHash","h","hotCallback","hotUpdate","hotDownloadUpdateChunk","outdatedModules","options","getAffectedStuff","module","outdatedDependencies","queue","slice","pop","parentId","parent","addAllToSet","a","b","item","appliedUpdate","result","ignoreUnaccepted","outdatedSelfAcceptedModules","errorHandler","disposeHandlers","j","cb","child","moduleOutdatedDependencies","dependency","hotCurrentHash","error","callbacks","exports","loaded","x","m","p","_mesh","self","onmessage","event","matchColor","filterColor","color","examineDocTree","isTab","doc","documents","find","d","rawPaths","jobs","tabGeometry","union","rawPathsToClipperPaths","scale","translate","op","filterFillColor","fillColor","filterStrokeColor","strokeColor","isClosed","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","rawPath","return","clipperPaths","geometry","xor","openGeometry","concat","type","docsWithImages","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_event$data","settings","opIndex","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","tabDocuments","chunk","percent","job","shift","postMessage","parseInt","message","level","toString","close","toStringBase","y","s","compare","equals","Node","t","this","point","triangle","prev","AdvancingFront","head","tail","head_","tail_","search_node_","setHead","node","setTail","search","setSearch","findSearchNode","locateNode","locatePoint","px","nx","xy","PointError","points","constructor","Triangle","points_","neighbors_","interior_","constrained_edge","delaunay_edge","p2s","getPoint","index","GetPoint","getPoints","getNeighbor","containsPoint","containsEdge","edge","q","containsPoints","p1","p2","isInterior","setInterior","interior","markNeighborPointers","markNeighbor","clearNeighbors","clearDelaunayEdges","pointCW","pointCCW","neighborCW","neighborCCW","getConstrainedEdgeCW","getConstrainedEdgeCCW","getConstrainedEdgeAcross","setConstrainedEdgeCW","ce","setConstrainedEdgeCCW","getDelaunayEdgeCW","getDelaunayEdgeCCW","setDelaunayEdgeCW","setDelaunayEdgeCCW","neighborAcross","oppositePoint","cw","legalize","opoint","npoint","edgeIndex","markConstrainedEdgeByIndex","markConstrainedEdgeByEdge","markConstrainedEdgeByPoints","_interopRequireDefault","obj","__esModule","default","linearizeCubicBezier","p1x","p1y","c1x","c1y","c2x","c2y","p2x","p2y","minNumSegments","minSegmentLength","bez","p0","p3","numSegments","nextX","nextY","linearizeSnapPath","path","alertFn","subpath","elementToLinearSnapPaths","element","Snap","snapElement","attr","Number","w","map","transform","globalMatrix","parsePathString","snapPathToRawPaths","snapPath","pxPerInch","factor","currentPath","elementToRawPaths","flipY","allRawPaths","deltaY","hasClosedRawPaths","filterClosedRawPaths","scaleX","scaleY","translateX","translateY","X","mmToClipperScale","Y","_clipperLib2","Clipper","CleanPolygons","cleanPolyDist","SimplifyPolygons","PolyFillType","pftEvenOdd","clipperPathsToPolyTree","paths","AddPaths","PolyType","ptSubject","polyTree","PolyTree","Execute","ClipType","ctUnion","triangulatePolyTree","pointToVertex","contourToVertexes","nodesToVertexes","nodes","Contour","processNode","vertexes","holes","Childs","context","_sweepcontext2","addHoles","triangulate","triangles","getTriangles","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","hole","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","triangulateRawPaths","clipperPathsToCPaths","memoryBlocks","doubleSize","cPaths","Module","_malloc","cPathsBase","cPathSizes","cPathSizesBase","clipperPath","cPath","pathArray","Float64Array","HEAPU32","buffer","byteOffset","clipperToCppScale","cPathsToClipperPaths","cPathsRef","cNumPathsRef","cPathSizesRef","cNumPaths","pathSize","cPathsToCamPaths","convertedPaths","convertedPath","safeToClose","Z","clipperBounds","minX","MAX_VALUE","minY","maxX","maxY","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","pt","Math","min","max","clip","paths1","paths2","clipType","clipper","ptClip","diff","ctDifference","ctXor","offset","amount","joinType","endType","JoinType","jtRound","EndType","etClosedPolygon","jtSquare","jtMiter","co","ClipperOffset","arcTolerance","offsetted","inchToClipperScale","_clipperLib","_sweepcontext","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","n","v","floor","am2","xl","xh","am3","int2char","BI_RM","charAt","intAt","BI_RC","charCodeAt","bnpCopyTo","r","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toRadix","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","abs","am","bnpSquareTo","bnpDivRemTo","pm","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","pow","intValue","substr","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","navigator_appName","nav","navigator","userAgent","toLowerCase","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","and","or","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","parseFloat","Inherit","ce2","$baseCtor","props","getOwnPropertyNames","getOwnPropertyDescriptor","Path","Paths","DoublePoint","arguments","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","ChildCount","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Parent","IsHole","m_AllPolys","Clear","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","toInteger","PI","PI2","IntPoint","alen","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","pftNonZero","pftPositive","pftNegative","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","join","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","miterLimit","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","sin","cos","OffsetPoint","DoSquare","DoRound","X2","clpr","outer","outerNode","jointype","cosA","DoMiter","tan","atan2","alert","JS","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","PolyTreeToExPolygons","__WEBPACK_AMD_DEFINE_ARRAY__","glob","current_event","stop","version","has","separator","comaseparator","wildcard","numsort","events","firstDefined","ii","lastDefined","eve","scope","String","oldstop","args","listeners","indexed","out","zIndex","_events","items","jj","nes","names","split","es","on","exist","attrs","subname","RegExp","test","nts","off","unbind","key","cur","funcs","once","f2","assert","condition","Point","_p2t_edge_list","toJSON","set_zero","sub","mul","normalize","cross","cmp","dot","tcx","initTriangulation","createAdvancingFront","sweepPoints","finalizationPolygon","pointCount","pointEvent","edgeEventByEdge","front","meshClean","new_node","newFrontTriangle","fill","fillAdvancingFront","edge_event","isEdgeSideOfTriangle","fillEdgeEvent","edgeEventByPoints","eq","o1","orient2d","COLLINEAR","o2","CW","flipEdgeEvent","addToMap","mapTriangleToNodes","isAngleObtuse","isBasinAngleRight","fillBasin","ot","oi","inside","inCircle","rotateTrianglePair","not_legalized","pa","pb","pc","pd","adx","ady","bdx","bdy","adxbdy","bdxady","oabd","cdx","cdy","cdxady","adxcdy","ocad","bdxcdy","cdxbdy","alift","blift","clift","det","n2","n3","n4","ce1","ce3","ce4","de1","de2","de3","de4","CCW","basin","left_node","bottom_node","right_node","width","left_highest","fillBasinReq","isShallow","o","height","fillRightAboveEdgeEvent","fillLeftAboveEdgeEvent","fillRightBelowEdgeEvent","fillRightConcaveEdgeEvent","fillRightConvexEdgeEvent","fillLeftBelowEdgeEvent","fillLeftConcaveEdgeEvent","fillLeftConvexEdgeEvent","inScanArea","nextFlipTriangle","newP","nextFlipPoint","flipScanEdgeEvent","edge_index","o2d","flip_triangle","utils","EPSILON","sweep","kAlpha","Edge","Basin","clear","EdgeEvent","SweepContext","contour","triangles_","map_","cloneArrays","edge_list","pmin_","pmax_","front_","af_head_","af_middle_","af_tail_","initEdges","addHole","polyline","AddHole","addPoint","AddPoint","addPoints","getBoundingBox","GetTriangles","getMap","xmax","xmin","ymax","ymin","middle","removeNode","removeFromMap","detleft","detright","oadb","oadc","bx","by","mina","animations","requestAnimFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","isArray","idgen","idprefix","Date","ID","timer","now","sta","dur","speed","spd","duration","stopit","pause","pdif","resume","start","end","easing","frame","anim","linear","time","getById","easeout","easein","easeinout","Q","backin","backout","elastic","bounce","root","nodeType","wrap","is","Element","querySelector","Paper","$","el","createTextNode","text","createComment","substring","getAttributeNS","xlink","xmlns","getAttribute","nodeValue","Str","setAttributeNS","setAttribute","removeAttribute","createElementNS","isFinite","objectToString","repush","array","cacher","postprocessor","newf","arg","cache","count","angle","x1","y1","x2","y2","x3","y3","math","rad","deg","svgTransform2string","tstr","replace","all","params","transform2matrix","bbox","tdata","parseTransformString","Matrix","bb","tlen","command","absolute","inver","invert","rotate","getSomeDefs","ownerSVGElement","parentNode","select","pdefs","defs","make","getSomeSVG","unit2px","getW","mgr","getBBox","getH","nam","svg","class","appendChild","removeChild","add2group","list","forEach","childNodes","snap","hub","paper","tagName","nodeName","anims","_","mask","symbol","method","Fragment","frag","desc","proto","ownerDocument","getElementsByTagName","body","dom","contentDocument","jsonFiller","win","document","toFloat","toInt","mmax","mmin","colourRegExp","commaSpaces","hsrg","hs","rg","pathCommand","tCommand","pathValues","url","format","tokenRegex","objNotationRegex","replacer","quote","quotedName","isFunc","str","asin","num","atan","len2","closestPoint","distance2","best","bestLength","scan","scanDistance","pathNode","pathLength","getTotalLength","precision","pathSegList","numberOfItems","bestDistance","Infinity","scanLength","getPointAtLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","snapTo","values","getRGB","colour","hex","rgbtoString","toHex","red","green","blue","opacity","rgb","hsb2rgb","hsl2rgb","hsb","hsl","toFixed","style","defaultView","getComputedStyle","getPropertyValue","hsbtoString","hsltoString","prepareRGB","string","clr","packageRGB","rgb2hsl","rgb2hsb","R","G","H","S","V","L","M","pathString","pth","arr","paramCounts","TString","rgTransform","_unit2px","contains","compareDocumentPosition","adown","documentElement","bup","query","selectAll","nodelist","querySelectorAll","setInterval","attributes","json","att","parse","createDocumentFragment","full","div","createElement","innerHTML","firstChild","fragment","ch","lastIndexOf","css","letter","cssAttr","alignment-baseline","baseline-shift","clip-path","clip-rule","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cursor","direction","display","dominant-baseline","enable-background","fill-opacity","fill-rule","filter","flood-color","flood-opacity","font","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","glyph-orientation-horizontal","glyph-orientation-vertical","image-rendering","kerning","letter-spacing","lighting-color","marker","marker-end","marker-mid","marker-start","overflow","pointer-events","shape-rendering","stop-color","stop-opacity","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-decoration","text-rendering","unicode-bidi","visibility","word-spacing","writing-mode","toUpperCase","ajax","postData","req","XMLHttpRequest","encodeURIComponent","open","setRequestHeader","onreadystatechange","readyState","send","load","responseText","getOffset","elem","box","getBoundingClientRect","docElem","clientTop","clientLeft","pageYOffset","scrollTop","pageXOffset","scrollLeft","getElementByPoint","target","canvas","elementFromPoint","so","sr","createSVGRect","hits","getIntersectionList","plugin","extractTransform","doReturn","matrix","fixids","urltest","it","uses","URL","linktest","els","ids","oldid","old","fs","from","to","chld","elproto","isWithoutTransform","removed","localMatrix","original","href","getElementById","pathfinder","deflt","bboxwt","realPath","propString","papa","global","getCTM","local","localString","toTransformString","totalMatrix","diffMatrix","total","gradientTransform","patternTransform","append","appendTo","prepend","first","insertBefore","prependTo","nextSibling","insertAfter","remove","asPX","use","xlink:href","cloneNode","toDefs","toPattern","patternUnits","viewBox","refX","refY","cx","cy","markerWidth","markerHeight","orient","Animation","animation","inAnim","_attrs","_callback","curStatus","animate","setter","fkeys","tkeys","keys","equal","eldata","removeData","outerSVG","innerSVG","toDataURL","btoa","contents","unescape","matrixproto","norm","mag","fromCharCode","determinant","row","scalex","shear","scaley","isSimple","isSuperSimple","noRotation","shorter","fillStroke","grad","gradient","setFontSize","fontSize","textExtract","chi","getFontSize","reURLValue","clipIt","gradrg","tokens","stops","toAbsolute","txt","className","baseVal","vb","rx","ry","tp","textPath","tuner","tuned","getter","textContent","rgNotSpace","addClass","pos","clazz","finalValue","classes","curClasses","removeClass","hasClass","toggleClass","flag","getNumber","getUnit","unit","operators","+","-","/","*","reUnit","reAddon","plus","evnt","atr","aUnit","isNaN","bplus","rect","circle","preload","onerror","src","img","cssText","onload","image","preserveAspectRatio","offsetWidth","offsetHeight","ellipse","group","vbx","vby","vbw","vbh","ptrn","vx","vy","vw","vh","line","Gstops","GaddStop","GgetBBox","seed","step","unshift","gradientLinear","gradientRadial","gradientUnits","addStop","fx","fy","ps","sleep","r1","r0","rectPath","pathClone","getPointAtSegmentLength","bezlen","findDotsAtSegment","getTotLen","getLengthFactory","istotal","O","onlystart","path2curve","sp","subpaths","t1","t13","t12","t2","t3","mx","my","ny","alpha","bezierBBox","curveDim","isPointInsideBBox","isBBoxIntersect","bbox1","bbox2","base3","p4","x4","y4","z2","Tvalues","Cvalues","sum","ct","xbase","ybase","comb","ll","intersect","denominator","py","px2","py2","interHelper","bez1","bez2","justCount","l1","l2","dots1","dots2","di","di1","dj","dj1","ci","cj","pathIntersection","path1","path2","interPathHelper","pathIntersectionNumber","x1m","y1m","x2m","y2m","pi","pj","intr","kk","segment1","segment2","isPointInsidePath","pathBBox","dim","ellipsePath","pathToRelative","lowerCase","rel","pathToAbsolute","pa0","crz","dots","catmullRom2bezier","l2c","q2c","_13","_23","a2c","large_arc_flag","sweep_flag","recursive","_120","f1","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","x0","b2ac","sqrtb2ac","tvalues","mt","curve","qx","qy","attrs2","processPath","pcom","T","fixArc","pcoms1","pcoms2","fixM","pfirst","seg","seg2","seglen","seg2len","mapPath","pathi","crp","iLen","getSubpathsAtLength","getPath","getSubpath","closest","found","intersection","intersectionNumber","isPointInside","toRelative","toCubic","Set","bindings","setproto","thisArg","each","begin","handler","callbacker","bind","aname","unbound","insertion","todel","arglen","exclude","getEmpty","equaliseTransform","tt1","tt2","maxlength","path2array","getViewBox","getColour","Function","isNumeric","arrayEqual","arr1","arr2","bUnit","supportsTouch","touchMap","mousedown","mousemove","mouseup","getScroll","preventTouch","originalEvent","preventDefault","stopTouch","stopPropagation","addEvent","realName","scrollY","scrollX","targetTouches","olde","clientX","clientY","addEventListener","removeEventListener","drag","dragMove","dragi","touch","touches","identifier","_drag","move_scope","dragUp","unmousemove","unmouseup","end_scope","start_scope","eventName","hover","f_in","f_out","scope_in","scope_out","mouseover","mouseout","unhover","unmouseover","unmouseout","draggable","onmove","onstart","onend","init","origTransform","undrag","unmousedown","pproto","rgurl","filstr","filterUnits","blur","def","shadow","grayscale","sepia","saturate","hueRotate","amount2","brightness","contrast","firstLetter","getAlign","way","align"],"mappings":"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","file":"6a0c953562cd1df1a961.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n/******/ \tvar canDefineProperty = false;\r\n/******/ \ttry {\r\n/******/ \t\tObject.defineProperty({}, \"x\", {\r\n/******/ \t\t\tget: function() {}\r\n/******/ \t\t});\r\n/******/ \t\tcanDefineProperty = true;\r\n/******/ \t} catch(x) {\r\n/******/ \t\t// IE will fail on defineProperty\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotApplyOnUpdate = true;\r\n/******/ \tvar hotCurrentHash = \"6a0c953562cd1df1a961\"; // eslint-disable-line no-unused-vars\r\n/******/ \tvar hotCurrentModuleData = {};\r\n/******/ \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n/******/ \t\r\n/******/ \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar me = installedModules[moduleId];\r\n/******/ \t\tif(!me) return __webpack_require__;\r\n/******/ \t\tvar fn = function(request) {\r\n/******/ \t\t\tif(me.hot.active) {\r\n/******/ \t\t\t\tif(installedModules[request]) {\r\n/******/ \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n/******/ \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n/******/ \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n/******/ \t\t\t\t\t\tme.children.push(request);\r\n/******/ \t\t\t\t} else hotCurrentParents = [moduleId];\r\n/******/ \t\t\t} else {\r\n/******/ \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n/******/ \t\t\t\thotCurrentParents = [];\r\n/******/ \t\t\t}\r\n/******/ \t\t\treturn __webpack_require__(request);\r\n/******/ \t\t};\r\n/******/ \t\tfor(var name in __webpack_require__) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n/******/ \t\t\t\tif(canDefineProperty) {\r\n/******/ \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n/******/ \t\t\t\t\t\treturn {\r\n/******/ \t\t\t\t\t\t\tconfigurable: true,\r\n/******/ \t\t\t\t\t\t\tenumerable: true,\r\n/******/ \t\t\t\t\t\t\tget: function() {\r\n/******/ \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n/******/ \t\t\t\t\t\t\t},\r\n/******/ \t\t\t\t\t\t\tset: function(value) {\r\n/******/ \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n/******/ \t\t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\t};\r\n/******/ \t\t\t\t\t}(name)));\r\n/******/ \t\t\t\t} else {\r\n/******/ \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction ensure(chunkId, callback) {\r\n/******/ \t\t\tif(hotStatus === \"ready\")\r\n/******/ \t\t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotChunksLoading++;\r\n/******/ \t\t\t__webpack_require__.e(chunkId, function() {\r\n/******/ \t\t\t\ttry {\r\n/******/ \t\t\t\t\tcallback.call(null, fn);\r\n/******/ \t\t\t\t} finally {\r\n/******/ \t\t\t\t\tfinishChunkLoading();\r\n/******/ \t\t\t\t}\r\n/******/ \t\r\n/******/ \t\t\t\tfunction finishChunkLoading() {\r\n/******/ \t\t\t\t\thotChunksLoading--;\r\n/******/ \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n/******/ \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n/******/ \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\tif(canDefineProperty) {\r\n/******/ \t\t\tObject.defineProperty(fn, \"e\", {\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tvalue: ensure\r\n/******/ \t\t\t});\r\n/******/ \t\t} else {\r\n/******/ \t\t\tfn.e = ensure;\r\n/******/ \t\t}\r\n/******/ \t\treturn fn;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar hot = {\r\n/******/ \t\t\t// private stuff\r\n/******/ \t\t\t_acceptedDependencies: {},\r\n/******/ \t\t\t_declinedDependencies: {},\r\n/******/ \t\t\t_selfAccepted: false,\r\n/******/ \t\t\t_selfDeclined: false,\r\n/******/ \t\t\t_disposeHandlers: [],\r\n/******/ \t\r\n/******/ \t\t\t// Module API\r\n/******/ \t\t\tactive: true,\r\n/******/ \t\t\taccept: function(dep, callback) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfAccepted = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"function\")\r\n/******/ \t\t\t\t\thot._selfAccepted = dep;\r\n/******/ \t\t\t\telse if(typeof dep === \"object\")\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdecline: function(dep) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfDeclined = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"number\")\r\n/******/ \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdispose: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddDisposeHandler: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveDisposeHandler: function(callback) {\r\n/******/ \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n/******/ \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t// Management API\r\n/******/ \t\t\tcheck: hotCheck,\r\n/******/ \t\t\tapply: hotApply,\r\n/******/ \t\t\tstatus: function(l) {\r\n/******/ \t\t\t\tif(!l) return hotStatus;\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddStatusHandler: function(l) {\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveStatusHandler: function(l) {\r\n/******/ \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n/******/ \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t//inherit from previous dispose call\r\n/******/ \t\t\tdata: hotCurrentModuleData[moduleId]\r\n/******/ \t\t};\r\n/******/ \t\treturn hot;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotStatusHandlers = [];\r\n/******/ \tvar hotStatus = \"idle\";\r\n/******/ \t\r\n/******/ \tfunction hotSetStatus(newStatus) {\r\n/******/ \t\thotStatus = newStatus;\r\n/******/ \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n/******/ \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \t// while downloading\r\n/******/ \tvar hotWaitingFiles = 0;\r\n/******/ \tvar hotChunksLoading = 0;\r\n/******/ \tvar hotWaitingFilesMap = {};\r\n/******/ \tvar hotRequestedFilesMap = {};\r\n/******/ \tvar hotAvailibleFilesMap = {};\r\n/******/ \tvar hotCallback;\r\n/******/ \t\r\n/******/ \t// The update info\r\n/******/ \tvar hotUpdate, hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \tfunction toModuleId(id) {\r\n/******/ \t\tvar isNumber = (+id) + \"\" === id;\r\n/******/ \t\treturn isNumber ? +id : id;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCheck(apply, callback) {\r\n/******/ \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n/******/ \t\tif(typeof apply === \"function\") {\r\n/******/ \t\t\thotApplyOnUpdate = false;\r\n/******/ \t\t\tcallback = apply;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotApplyOnUpdate = apply;\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\thotSetStatus(\"check\");\r\n/******/ \t\thotDownloadManifest(function(err, update) {\r\n/******/ \t\t\tif(err) return callback(err);\r\n/******/ \t\t\tif(!update) {\r\n/******/ \t\t\t\thotSetStatus(\"idle\");\r\n/******/ \t\t\t\tcallback(null, null);\r\n/******/ \t\t\t\treturn;\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\thotRequestedFilesMap = {};\r\n/******/ \t\t\thotAvailibleFilesMap = {};\r\n/******/ \t\t\thotWaitingFilesMap = {};\r\n/******/ \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n/******/ \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n/******/ \t\t\thotUpdateNewHash = update.h;\r\n/******/ \t\r\n/******/ \t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotCallback = callback;\r\n/******/ \t\t\thotUpdate = {};\r\n/******/ \t\t\tvar chunkId = 0;\r\n/******/ \t\t\t{ // eslint-disable-line no-lone-blocks\r\n/******/ \t\t\t\t/*globals chunkId */\r\n/******/ \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t}\r\n/******/ \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t}\r\n/******/ \t\t});\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n/******/ \t\t\treturn;\r\n/******/ \t\thotRequestedFilesMap[chunkId] = false;\r\n/******/ \t\tfor(var moduleId in moreModules) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n/******/ \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n/******/ \t\t\thotUpdateDownloaded();\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotEnsureUpdateChunk(chunkId) {\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n/******/ \t\t\thotWaitingFilesMap[chunkId] = true;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotRequestedFilesMap[chunkId] = true;\r\n/******/ \t\t\thotWaitingFiles++;\r\n/******/ \t\t\thotDownloadUpdateChunk(chunkId);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotUpdateDownloaded() {\r\n/******/ \t\thotSetStatus(\"ready\");\r\n/******/ \t\tvar callback = hotCallback;\r\n/******/ \t\thotCallback = null;\r\n/******/ \t\tif(!callback) return;\r\n/******/ \t\tif(hotApplyOnUpdate) {\r\n/******/ \t\t\thotApply(hotApplyOnUpdate, callback);\r\n/******/ \t\t} else {\r\n/******/ \t\t\tvar outdatedModules = [];\r\n/******/ \t\t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t\tcallback(null, outdatedModules);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotApply(options, callback) {\r\n/******/ \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n/******/ \t\tif(typeof options === \"function\") {\r\n/******/ \t\t\tcallback = options;\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t} else if(options && typeof options === \"object\") {\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t} else {\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction getAffectedStuff(module) {\r\n/******/ \t\t\tvar outdatedModules = [module];\r\n/******/ \t\t\tvar outdatedDependencies = {};\r\n/******/ \t\r\n/******/ \t\t\tvar queue = outdatedModules.slice();\r\n/******/ \t\t\twhile(queue.length > 0) {\r\n/******/ \t\t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tif(!module || module.hot._selfAccepted)\r\n/******/ \t\t\t\t\tcontinue;\r\n/******/ \t\t\t\tif(module.hot._selfDeclined) {\r\n/******/ \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(moduleId === 0) {\r\n/******/ \t\t\t\t\treturn;\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n/******/ \t\t\t\t\tvar parentId = module.parents[i];\r\n/******/ \t\t\t\t\tvar parent = installedModules[parentId];\r\n/******/ \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n/******/ \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n/******/ \t\t\t\t\toutdatedModules.push(parentId);\r\n/******/ \t\t\t\t\tqueue.push(parentId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\treturn [outdatedModules, outdatedDependencies];\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction addAllToSet(a, b) {\r\n/******/ \t\t\tfor(var i = 0; i < b.length; i++) {\r\n/******/ \t\t\t\tvar item = b[i];\r\n/******/ \t\t\t\tif(a.indexOf(item) < 0)\r\n/******/ \t\t\t\t\ta.push(item);\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// at begin all updates modules are outdated\r\n/******/ \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n/******/ \t\tvar outdatedDependencies = {};\r\n/******/ \t\tvar outdatedModules = [];\r\n/******/ \t\tvar appliedUpdate = {};\r\n/******/ \t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\tvar moduleId = toModuleId(id);\r\n/******/ \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n/******/ \t\t\t\tif(!result) {\r\n/******/ \t\t\t\t\tif(options.ignoreUnaccepted)\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(result instanceof Error) {\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(result);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n/******/ \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n/******/ \t\t\t\tfor(var moduleId in result[1]) {\r\n/******/ \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Store self accepted outdated modules to require them later by the module system\r\n/******/ \t\tvar outdatedSelfAcceptedModules = [];\r\n/******/ \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n/******/ \t\t\tvar moduleId = outdatedModules[i];\r\n/******/ \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n/******/ \t\t\t\toutdatedSelfAcceptedModules.push({\r\n/******/ \t\t\t\t\tmodule: moduleId,\r\n/******/ \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n/******/ \t\t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Now in \"dispose\" phase\r\n/******/ \t\thotSetStatus(\"dispose\");\r\n/******/ \t\tvar queue = outdatedModules.slice();\r\n/******/ \t\twhile(queue.length > 0) {\r\n/******/ \t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\tif(!module) continue;\r\n/******/ \t\r\n/******/ \t\t\tvar data = {};\r\n/******/ \t\r\n/******/ \t\t\t// Call dispose handlers\r\n/******/ \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n/******/ \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n/******/ \t\t\t\tvar cb = disposeHandlers[j];\r\n/******/ \t\t\t\tcb(data);\r\n/******/ \t\t\t}\r\n/******/ \t\t\thotCurrentModuleData[moduleId] = data;\r\n/******/ \t\r\n/******/ \t\t\t// disable module (this disables requires from this module)\r\n/******/ \t\t\tmodule.hot.active = false;\r\n/******/ \t\r\n/******/ \t\t\t// remove module from cache\r\n/******/ \t\t\tdelete installedModules[moduleId];\r\n/******/ \t\r\n/******/ \t\t\t// remove \"parents\" references from all children\r\n/******/ \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n/******/ \t\t\t\tvar child = installedModules[module.children[j]];\r\n/******/ \t\t\t\tif(!child) continue;\r\n/******/ \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n/******/ \t\t\t\tif(idx >= 0) {\r\n/******/ \t\t\t\t\tchild.parents.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// remove outdated dependency from module children\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n/******/ \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n/******/ \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Not in \"apply\" phase\r\n/******/ \t\thotSetStatus(\"apply\");\r\n/******/ \t\r\n/******/ \t\thotCurrentHash = hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \t\t// insert new code\r\n/******/ \t\tfor(var moduleId in appliedUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n/******/ \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// call accept handlers\r\n/******/ \t\tvar error = null;\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tvar callbacks = [];\r\n/******/ \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n/******/ \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n/******/ \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n/******/ \t\t\t\t\tcallbacks.push(cb);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n/******/ \t\t\t\t\tvar cb = callbacks[i];\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\tcb(outdatedDependencies);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Load self accepted modules\r\n/******/ \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n/******/ \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n/******/ \t\t\tvar moduleId = item.module;\r\n/******/ \t\t\thotCurrentParents = [moduleId];\r\n/******/ \t\t\ttry {\r\n/******/ \t\t\t\t__webpack_require__(moduleId);\r\n/******/ \t\t\t} catch(err) {\r\n/******/ \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\titem.errorHandler(err);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t} else if(!error)\r\n/******/ \t\t\t\t\terror = err;\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// handle errors in accept handlers and self accepted module load\r\n/******/ \t\tif(error) {\r\n/******/ \t\t\thotSetStatus(\"fail\");\r\n/******/ \t\t\treturn callback(error);\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\thotSetStatus(\"idle\");\r\n/******/ \t\tcallback(null, outdatedModules);\r\n/******/ \t}\r\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\thot: hotCreateModule(moduleId),\n/******/ \t\t\tparents: hotCurrentParents,\n/******/ \t\t\tchildren: []\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// __webpack_hash__\n/******/ \t__webpack_require__.h = function() { return hotCurrentHash; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn hotCreateRequire(0)(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _mesh = __webpack_require__(5);\n\t\n\tself.onmessage = function (event) {\n\t\n\t    var jobs = [];\n\t\n\t    var _event$data = event.data,\n\t        settings = _event$data.settings,\n\t        opIndex = _event$data.opIndex,\n\t        op = _event$data.op,\n\t        geometry = _event$data.geometry,\n\t        openGeometry = _event$data.openGeometry,\n\t        tabGeometry = _event$data.tabGeometry,\n\t        documents = _event$data.documents;\n\t\n\t\n\t    var docsWithImages = [];\n\t\n\t    function matchColor(filterColor, color) {\n\t        if (!filterColor) return true;\n\t        if (!color) return false;\n\t        return filterColor[0] == color[0] && filterColor[1] == color[1] && filterColor[2] == color[2] && filterColor[3] == color[3];\n\t    }\n\t\n\t    function examineDocTree(isTab, id) {\n\t        var doc = documents.find(function (d) {\n\t            return d.id === id;\n\t        });\n\t        if (doc.rawPaths) {\n\t            jobs.push(function (cb) {\n\t                if (isTab) {\n\t                    tabGeometry = (0, _mesh.union)(tabGeometry, (0, _mesh.rawPathsToClipperPaths)(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]));\n\t                } else if (matchColor(op.filterFillColor, doc.fillColor) && matchColor(op.filterStrokeColor, doc.strokeColor)) {\n\t                    var isClosed = false;\n\t                    var _iteratorNormalCompletion = true;\n\t                    var _didIteratorError = false;\n\t                    var _iteratorError = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator = doc.rawPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                            var rawPath = _step.value;\n\t\n\t                            if (rawPath.length >= 4 && rawPath[0] == rawPath[rawPath.length - 2] && rawPath[1] == rawPath[rawPath.length - 1]) isClosed = true;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError = true;\n\t                        _iteratorError = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion && _iterator.return) {\n\t                                _iterator.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError) {\n\t                                throw _iteratorError;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    var clipperPaths = (0, _mesh.rawPathsToClipperPaths)(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]);\n\t                    if (isClosed) geometry = (0, _mesh.xor)(geometry, clipperPaths);else if (!op.filterFillColor) openGeometry = openGeometry.concat(clipperPaths);\n\t                }\n\t                cb();\n\t            });\n\t        }\n\t        if (doc.type === 'image' && !isTab) {\n\t            docsWithImages.push(doc);\n\t        }\n\t        var _iteratorNormalCompletion2 = true;\n\t        var _didIteratorError2 = false;\n\t        var _iteratorError2 = undefined;\n\t\n\t        try {\n\t            for (var _iterator2 = doc.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                var child = _step2.value;\n\t\n\t                examineDocTree(isTab, child);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError2 = true;\n\t            _iteratorError2 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                    _iterator2.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError2) {\n\t                    throw _iteratorError2;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    var _iteratorNormalCompletion3 = true;\n\t    var _didIteratorError3 = false;\n\t    var _iteratorError3 = undefined;\n\t\n\t    try {\n\t        for (var _iterator3 = op.documents[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t            var id = _step3.value;\n\t\n\t            examineDocTree(false, id);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t            }\n\t        }\n\t    }\n\t\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = op.tabDocuments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var _id = _step4.value;\n\t\n\t            examineDocTree(true, _id);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t\n\t    var chunk = 100 / jobs.length;\n\t    var percent = 0;\n\t\n\t    while (jobs.length) {\n\t        try {\n\t            var job = jobs.shift();\n\t            if (job) job(function () {\n\t                percent = percent + chunk;\n\t                postMessage({ event: \"onProgress\", percent: parseInt(percent) });\n\t            });\n\t        } catch (error) {\n\t            console.error(error);\n\t            postMessage({ event: \"onError\", message: \"Something wrong has happened, sorry.\", level: \"error\", error: error.toString() });\n\t        }\n\t    }\n\t\n\t    postMessage({ event: \"onDone\", settings: settings, opIndex: opIndex, op: op, geometry: geometry, openGeometry: openGeometry, tabGeometry: tabGeometry, docsWithImages: docsWithImages });\n\t    self.close();\n\t};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * The following functions operate on \"Point\" or any \"Point like\" object with {x,y},\n\t * as defined by the {@link XY} type\n\t * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n\t * @module\n\t * @private\n\t */\n\t\n\t/**\n\t * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n\t * Any \"Point like\" object with <code>{x, y}</code> attributes is supported\n\t * to initialize the SweepContext polylines and points\n\t * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n\t *\n\t * poly2tri.js might add extra fields to the point objects when computing the\n\t * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions\n\t * with fields in the custom class.\n\t *\n\t * @example\n\t *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *\n\t * @typedef {Object} XY\n\t * @property {number} x - x coordinate\n\t * @property {number} y - y coordinate\n\t */\n\t\n\t\n\t/**\n\t * Point pretty printing : prints x and y coordinates.\n\t * @example\n\t *      xy.toStringBase({x:5, y:42})\n\t *      // → \"(5;42)\"\n\t * @protected\n\t * @param {!XY} p - point object with {x,y}\n\t * @returns {string} <code>\"(x;y)\"</code>\n\t */\n\tfunction toStringBase(p) {\n\t    return (\"(\" + p.x + \";\" + p.y + \")\");\n\t}\n\t\n\t/**\n\t * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n\t * else simply prints x and y coordinates.\n\t * @example\n\t *      xy.toString({x:5, y:42})\n\t *      // → \"(5;42)\"\n\t * @example\n\t *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n\t *      // → \"5:42\"\n\t * @param {!XY} p - point object with {x,y}\n\t * @returns {string} <code>\"(x;y)\"</code>\n\t */\n\tfunction toString(p) {\n\t    // Try a custom toString first, and fallback to own implementation if none\n\t    var s = p.toString();\n\t    return (s === '[object Object]' ? toStringBase(p) : s);\n\t}\n\t\n\t\n\t/**\n\t * Compare two points component-wise. Ordered by y axis first, then x axis.\n\t * @param {!XY} a - point object with {x,y}\n\t * @param {!XY} b - point object with {x,y}\n\t * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,\n\t *         <code>&gt; 0</code> if <code>a &gt; b</code>, \n\t *         <code>0</code> otherwise.\n\t */\n\tfunction compare(a, b) {\n\t    if (a.y === b.y) {\n\t        return a.x - b.x;\n\t    } else {\n\t        return a.y - b.y;\n\t    }\n\t}\n\t\n\t/**\n\t * Test two Point objects for equality.\n\t * @param {!XY} a - point object with {x,y}\n\t * @param {!XY} b - point object with {x,y}\n\t * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.\n\t */\n\tfunction equals(a, b) {\n\t    return a.x === b.x && a.y === b.y;\n\t}\n\t\n\t\n\tmodule.exports = {\n\t    toString: toString,\n\t    toStringBase: toStringBase,\n\t    compare: compare,\n\t    equals: equals\n\t};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint maxcomplexity:11 */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\t\n\t// -------------------------------------------------------------------------Node\n\t\n\t/**\n\t * Advancing front node\n\t * @constructor\n\t * @private\n\t * @struct\n\t * @param {!XY} p - Point\n\t * @param {Triangle=} t triangle (optional)\n\t */\n\tvar Node = function(p, t) {\n\t    /** @type {XY} */\n\t    this.point = p;\n\t\n\t    /** @type {Triangle|null} */\n\t    this.triangle = t || null;\n\t\n\t    /** @type {Node|null} */\n\t    this.next = null;\n\t    /** @type {Node|null} */\n\t    this.prev = null;\n\t\n\t    /** @type {number} */\n\t    this.value = p.x;\n\t};\n\t\n\t// ---------------------------------------------------------------AdvancingFront\n\t/**\n\t * @constructor\n\t * @private\n\t * @struct\n\t * @param {Node} head\n\t * @param {Node} tail\n\t */\n\tvar AdvancingFront = function(head, tail) {\n\t    /** @type {Node} */\n\t    this.head_ = head;\n\t    /** @type {Node} */\n\t    this.tail_ = tail;\n\t    /** @type {Node} */\n\t    this.search_node_ = head;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.head = function() {\n\t    return this.head_;\n\t};\n\t\n\t/** @param {Node} node */\n\tAdvancingFront.prototype.setHead = function(node) {\n\t    this.head_ = node;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.tail = function() {\n\t    return this.tail_;\n\t};\n\t\n\t/** @param {Node} node */\n\tAdvancingFront.prototype.setTail = function(node) {\n\t    this.tail_ = node;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.search = function() {\n\t    return this.search_node_;\n\t};\n\t\n\t/** @param {Node} node */\n\tAdvancingFront.prototype.setSearch = function(node) {\n\t    this.search_node_ = node;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.findSearchNode = function(/*x*/) {\n\t    // TODO: implement BST index\n\t    return this.search_node_;\n\t};\n\t\n\t/**\n\t * @param {number} x value\n\t * @return {Node}\n\t */\n\tAdvancingFront.prototype.locateNode = function(x) {\n\t    var node = this.search_node_;\n\t\n\t    /* jshint boss:true */\n\t    if (x < node.value) {\n\t        while (node = node.prev) {\n\t            if (x >= node.value) {\n\t                this.search_node_ = node;\n\t                return node;\n\t            }\n\t        }\n\t    } else {\n\t        while (node = node.next) {\n\t            if (x < node.value) {\n\t                this.search_node_ = node.prev;\n\t                return node.prev;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t};\n\t\n\t/**\n\t * @param {!XY} point - Point\n\t * @return {Node}\n\t */\n\tAdvancingFront.prototype.locatePoint = function(point) {\n\t    var px = point.x;\n\t    var node = this.findSearchNode(px);\n\t    var nx = node.point.x;\n\t\n\t    if (px === nx) {\n\t        // Here we are comparing point references, not values\n\t        if (point !== node.point) {\n\t            // We might have two nodes with same x value for a short time\n\t            if (point === node.prev.point) {\n\t                node = node.prev;\n\t            } else if (point === node.next.point) {\n\t                node = node.next;\n\t            } else {\n\t                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');\n\t            }\n\t        }\n\t    } else if (px < nx) {\n\t        /* jshint boss:true */\n\t        while (node = node.prev) {\n\t            if (point === node.point) {\n\t                break;\n\t            }\n\t        }\n\t    } else {\n\t        while (node = node.next) {\n\t            if (point === node.point) {\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (node) {\n\t        this.search_node_ = node;\n\t    }\n\t    return node;\n\t};\n\t\n\t\n\t// ----------------------------------------------------------------------Exports\n\t\n\tmodule.exports = AdvancingFront;\n\tmodule.exports.Node = Node;\n\t\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/*\n\t * Class added in the JavaScript version (was not present in the c++ version)\n\t */\n\t\n\tvar xy = __webpack_require__(1);\n\t\n\t/**\n\t * Custom exception class to indicate invalid Point values\n\t * @constructor\n\t * @public\n\t * @extends Error\n\t * @struct\n\t * @param {string=} message - error message\n\t * @param {Array.<XY>=} points - invalid points\n\t */\n\tvar PointError = function(message, points) {\n\t    this.name = \"PointError\";\n\t    /**\n\t     * Invalid points\n\t     * @public\n\t     * @type {Array.<XY>}\n\t     */\n\t    this.points = points = points || [];\n\t    /**\n\t     * Error message\n\t     * @public\n\t     * @type {string}\n\t     */\n\t    this.message = message || \"Invalid Points!\";\n\t    for (var i = 0; i < points.length; i++) {\n\t        this.message += \" \" + xy.toString(points[i]);\n\t    }\n\t};\n\tPointError.prototype = new Error();\n\tPointError.prototype.constructor = PointError;\n\t\n\t\n\tmodule.exports = PointError;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t *\n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint maxcomplexity:10 */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar xy = __webpack_require__(1);\n\t\n\t\n\t// ---------------------------------------------------------------------Triangle\n\t/**\n\t * Triangle class.<br>\n\t * Triangle-based data structures are known to have better performance than\n\t * quad-edge structures.\n\t * See: J. Shewchuk, \"Triangle: Engineering a 2D Quality Mesh Generator and\n\t * Delaunay Triangulator\", \"Triangulations in CGAL\"\n\t *\n\t * @constructor\n\t * @struct\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t */\n\tvar Triangle = function(a, b, c) {\n\t    /**\n\t     * Triangle points\n\t     * @private\n\t     * @type {Array.<XY>}\n\t     */\n\t    this.points_ = [a, b, c];\n\t\n\t    /**\n\t     * Neighbor list\n\t     * @private\n\t     * @type {Array.<Triangle>}\n\t     */\n\t    this.neighbors_ = [null, null, null];\n\t\n\t    /**\n\t     * Has this triangle been marked as an interior triangle?\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    this.interior_ = false;\n\t\n\t    /**\n\t     * Flags to determine if an edge is a Constrained edge\n\t     * @private\n\t     * @type {Array.<boolean>}\n\t     */\n\t    this.constrained_edge = [false, false, false];\n\t\n\t    /**\n\t     * Flags to determine if an edge is a Delauney edge\n\t     * @private\n\t     * @type {Array.<boolean>}\n\t     */\n\t    this.delaunay_edge = [false, false, false];\n\t};\n\t\n\tvar p2s = xy.toString;\n\t/**\n\t * For pretty printing ex. <code>\"[(5;42)(10;20)(21;30)]\"</code>.\n\t * @public\n\t * @return {string}\n\t */\n\tTriangle.prototype.toString = function() {\n\t    return (\"[\" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + \"]\");\n\t};\n\t\n\t/**\n\t * Get one vertice of the triangle.\n\t * The output triangles of a triangulation have vertices which are references\n\t * to the initial input points (not copies): any custom fields in the\n\t * initial points can be retrieved in the output triangles.\n\t * @example\n\t *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t *      typeof triangles[0].getPoint(0).id\n\t *      // → \"number\"\n\t * @param {number} index - vertice index: 0, 1 or 2\n\t * @public\n\t * @returns {XY}\n\t */\n\tTriangle.prototype.getPoint = function(index) {\n\t    return this.points_[index];\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode Triangle#getPoint} instead\n\t */\n\tTriangle.prototype.GetPoint = Triangle.prototype.getPoint;\n\t\n\t/**\n\t * Get all 3 vertices of the triangle as an array\n\t * @public\n\t * @return {Array.<XY>}\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tTriangle.prototype.getPoints = function() {\n\t    return this.points_;\n\t};\n\t\n\t/**\n\t * @private\n\t * @param {number} index\n\t * @returns {?Triangle}\n\t */\n\tTriangle.prototype.getNeighbor = function(index) {\n\t    return this.neighbors_[index];\n\t};\n\t\n\t/**\n\t * Test if this Triangle contains the Point object given as parameter as one of its vertices.\n\t * Only point references are compared, not values.\n\t * @public\n\t * @param {XY} point - point object with {x,y}\n\t * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,\n\t *         <code>false</code> otherwise.\n\t */\n\tTriangle.prototype.containsPoint = function(point) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    return (point === points[0] || point === points[1] || point === points[2]);\n\t};\n\t\n\t/**\n\t * Test if this Triangle contains the Edge object given as parameter as its\n\t * bounding edges. Only point references are compared, not values.\n\t * @private\n\t * @param {Edge} edge\n\t * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding\n\t *         edges, <code>false</code> otherwise.\n\t */\n\tTriangle.prototype.containsEdge = function(edge) {\n\t    return this.containsPoint(edge.p) && this.containsPoint(edge.q);\n\t};\n\t\n\t/**\n\t * Test if this Triangle contains the two Point objects given as parameters among its vertices.\n\t * Only point references are compared, not values.\n\t * @param {XY} p1 - point object with {x,y}\n\t * @param {XY} p2 - point object with {x,y}\n\t * @return {boolean}\n\t */\n\tTriangle.prototype.containsPoints = function(p1, p2) {\n\t    return this.containsPoint(p1) && this.containsPoint(p2);\n\t};\n\t\n\t/**\n\t * Has this triangle been marked as an interior triangle?\n\t * @returns {boolean}\n\t */\n\tTriangle.prototype.isInterior = function() {\n\t    return this.interior_;\n\t};\n\t\n\t/**\n\t * Mark this triangle as an interior triangle\n\t * @private\n\t * @param {boolean} interior\n\t * @returns {Triangle} this\n\t */\n\tTriangle.prototype.setInterior = function(interior) {\n\t    this.interior_ = interior;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Update neighbor pointers.\n\t * @private\n\t * @param {XY} p1 - point object with {x,y}\n\t * @param {XY} p2 - point object with {x,y}\n\t * @param {Triangle} t Triangle object.\n\t * @throws {Error} if can't find objects\n\t */\n\tTriangle.prototype.markNeighborPointers = function(p1, p2, t) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {\n\t        this.neighbors_[0] = t;\n\t    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {\n\t        this.neighbors_[1] = t;\n\t    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {\n\t        this.neighbors_[2] = t;\n\t    } else {\n\t        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');\n\t    }\n\t};\n\t\n\t/**\n\t * Exhaustive search to update neighbor pointers\n\t * @private\n\t * @param {!Triangle} t\n\t */\n\tTriangle.prototype.markNeighbor = function(t) {\n\t    var points = this.points_;\n\t    if (t.containsPoints(points[1], points[2])) {\n\t        this.neighbors_[0] = t;\n\t        t.markNeighborPointers(points[1], points[2], this);\n\t    } else if (t.containsPoints(points[0], points[2])) {\n\t        this.neighbors_[1] = t;\n\t        t.markNeighborPointers(points[0], points[2], this);\n\t    } else if (t.containsPoints(points[0], points[1])) {\n\t        this.neighbors_[2] = t;\n\t        t.markNeighborPointers(points[0], points[1], this);\n\t    }\n\t};\n\t\n\t\n\tTriangle.prototype.clearNeighbors = function() {\n\t    this.neighbors_[0] = null;\n\t    this.neighbors_[1] = null;\n\t    this.neighbors_[2] = null;\n\t};\n\t\n\tTriangle.prototype.clearDelaunayEdges = function() {\n\t    this.delaunay_edge[0] = false;\n\t    this.delaunay_edge[1] = false;\n\t    this.delaunay_edge[2] = false;\n\t};\n\t\n\t/**\n\t * Returns the point clockwise to the given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.pointCW = function(p) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p === points[0]) {\n\t        return points[2];\n\t    } else if (p === points[1]) {\n\t        return points[0];\n\t    } else if (p === points[2]) {\n\t        return points[1];\n\t    } else {\n\t        return null;\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the point counter-clockwise to the given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.pointCCW = function(p) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p === points[0]) {\n\t        return points[1];\n\t    } else if (p === points[1]) {\n\t        return points[2];\n\t    } else if (p === points[2]) {\n\t        return points[0];\n\t    } else {\n\t        return null;\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the neighbor clockwise to given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.neighborCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.neighbors_[1];\n\t    } else if (p === this.points_[1]) {\n\t        return this.neighbors_[2];\n\t    } else {\n\t        return this.neighbors_[0];\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the neighbor counter-clockwise to given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.neighborCCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.neighbors_[2];\n\t    } else if (p === this.points_[1]) {\n\t        return this.neighbors_[0];\n\t    } else {\n\t        return this.neighbors_[1];\n\t    }\n\t};\n\t\n\tTriangle.prototype.getConstrainedEdgeCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.constrained_edge[1];\n\t    } else if (p === this.points_[1]) {\n\t        return this.constrained_edge[2];\n\t    } else {\n\t        return this.constrained_edge[0];\n\t    }\n\t};\n\t\n\tTriangle.prototype.getConstrainedEdgeCCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.constrained_edge[2];\n\t    } else if (p === this.points_[1]) {\n\t        return this.constrained_edge[0];\n\t    } else {\n\t        return this.constrained_edge[1];\n\t    }\n\t};\n\t\n\t// Additional check from Java version (see issue #88)\n\tTriangle.prototype.getConstrainedEdgeAcross = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.constrained_edge[0];\n\t    } else if (p === this.points_[1]) {\n\t        return this.constrained_edge[1];\n\t    } else {\n\t        return this.constrained_edge[2];\n\t    }\n\t};\n\t\n\tTriangle.prototype.setConstrainedEdgeCW = function(p, ce) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.constrained_edge[1] = ce;\n\t    } else if (p === this.points_[1]) {\n\t        this.constrained_edge[2] = ce;\n\t    } else {\n\t        this.constrained_edge[0] = ce;\n\t    }\n\t};\n\t\n\tTriangle.prototype.setConstrainedEdgeCCW = function(p, ce) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.constrained_edge[2] = ce;\n\t    } else if (p === this.points_[1]) {\n\t        this.constrained_edge[0] = ce;\n\t    } else {\n\t        this.constrained_edge[1] = ce;\n\t    }\n\t};\n\t\n\tTriangle.prototype.getDelaunayEdgeCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.delaunay_edge[1];\n\t    } else if (p === this.points_[1]) {\n\t        return this.delaunay_edge[2];\n\t    } else {\n\t        return this.delaunay_edge[0];\n\t    }\n\t};\n\t\n\tTriangle.prototype.getDelaunayEdgeCCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.delaunay_edge[2];\n\t    } else if (p === this.points_[1]) {\n\t        return this.delaunay_edge[0];\n\t    } else {\n\t        return this.delaunay_edge[1];\n\t    }\n\t};\n\t\n\tTriangle.prototype.setDelaunayEdgeCW = function(p, e) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.delaunay_edge[1] = e;\n\t    } else if (p === this.points_[1]) {\n\t        this.delaunay_edge[2] = e;\n\t    } else {\n\t        this.delaunay_edge[0] = e;\n\t    }\n\t};\n\t\n\tTriangle.prototype.setDelaunayEdgeCCW = function(p, e) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.delaunay_edge[2] = e;\n\t    } else if (p === this.points_[1]) {\n\t        this.delaunay_edge[0] = e;\n\t    } else {\n\t        this.delaunay_edge[1] = e;\n\t    }\n\t};\n\t\n\t/**\n\t * The neighbor across to given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t * @returns {Triangle}\n\t */\n\tTriangle.prototype.neighborAcross = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.neighbors_[0];\n\t    } else if (p === this.points_[1]) {\n\t        return this.neighbors_[1];\n\t    } else {\n\t        return this.neighbors_[2];\n\t    }\n\t};\n\t\n\t/**\n\t * @private\n\t * @param {!Triangle} t Triangle object.\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.oppositePoint = function(t, p) {\n\t    var cw = t.pointCW(p);\n\t    return this.pointCW(cw);\n\t};\n\t\n\t/**\n\t * Legalize triangle by rotating clockwise around oPoint\n\t * @private\n\t * @param {XY} opoint - point object with {x,y}\n\t * @param {XY} npoint - point object with {x,y}\n\t * @throws {Error} if oPoint can not be found\n\t */\n\tTriangle.prototype.legalize = function(opoint, npoint) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (opoint === points[0]) {\n\t        points[1] = points[0];\n\t        points[0] = points[2];\n\t        points[2] = npoint;\n\t    } else if (opoint === points[1]) {\n\t        points[2] = points[1];\n\t        points[1] = points[0];\n\t        points[0] = npoint;\n\t    } else if (opoint === points[2]) {\n\t        points[0] = points[2];\n\t        points[2] = points[1];\n\t        points[1] = npoint;\n\t    } else {\n\t        throw new Error('poly2tri Invalid Triangle.legalize() call');\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the index of a point in the triangle. \n\t * The point *must* be a reference to one of the triangle's vertices.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t * @returns {number} index 0, 1 or 2\n\t * @throws {Error} if p can not be found\n\t */\n\tTriangle.prototype.index = function(p) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p === points[0]) {\n\t        return 0;\n\t    } else if (p === points[1]) {\n\t        return 1;\n\t    } else if (p === points[2]) {\n\t        return 2;\n\t    } else {\n\t        throw new Error('poly2tri Invalid Triangle.index() call');\n\t    }\n\t};\n\t\n\t/**\n\t * @private\n\t * @param {XY} p1 - point object with {x,y}\n\t * @param {XY} p2 - point object with {x,y}\n\t * @return {number} index 0, 1 or 2, or -1 if errror\n\t */\n\tTriangle.prototype.edgeIndex = function(p1, p2) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p1 === points[0]) {\n\t        if (p2 === points[1]) {\n\t            return 2;\n\t        } else if (p2 === points[2]) {\n\t            return 1;\n\t        }\n\t    } else if (p1 === points[1]) {\n\t        if (p2 === points[2]) {\n\t            return 0;\n\t        } else if (p2 === points[0]) {\n\t            return 2;\n\t        }\n\t    } else if (p1 === points[2]) {\n\t        if (p2 === points[0]) {\n\t            return 1;\n\t        } else if (p2 === points[1]) {\n\t            return 0;\n\t        }\n\t    }\n\t    return -1;\n\t};\n\t\n\t/**\n\t * Mark an edge of this triangle as constrained.\n\t * @private\n\t * @param {number} index - edge index\n\t */\n\tTriangle.prototype.markConstrainedEdgeByIndex = function(index) {\n\t    this.constrained_edge[index] = true;\n\t};\n\t/**\n\t * Mark an edge of this triangle as constrained.\n\t * @private\n\t * @param {Edge} edge instance\n\t */\n\tTriangle.prototype.markConstrainedEdgeByEdge = function(edge) {\n\t    this.markConstrainedEdgeByPoints(edge.p, edge.q);\n\t};\n\t/**\n\t * Mark an edge of this triangle as constrained.\n\t * This method takes two Point instances defining the edge of the triangle.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t * @param {XY} q - point object with {x,y}\n\t */\n\tTriangle.prototype.markConstrainedEdgeByPoints = function(p, q) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values        \n\t    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {\n\t        this.constrained_edge[2] = true;\n\t    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {\n\t        this.constrained_edge[1] = true;\n\t    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {\n\t        this.constrained_edge[0] = true;\n\t    }\n\t};\n\t\n\t\n\t// ---------------------------------------------------------Exports (public API)\n\t\n\tmodule.exports = Triangle;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Copyright 2014-2016 Todd Fleming\n\t//\n\t// This program is free software: you can redistribute it and/or modify\n\t// it under the terms of the GNU Affero General Public License as published by\n\t// the Free Software Foundation, either version 3 of the License, or\n\t// (at your option) any later version.\n\t// \n\t// This program is distributed in the hope that it will be useful,\n\t// but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t// GNU Affero General Public License for more details.\n\t// \n\t// You should have received a copy of the GNU Affero General Public License\n\t// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t\n\t// TODO: pass React elements to alertFn\n\t\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.arcTolerance = exports.cleanPolyDist = exports.clipperToCppScale = exports.mmToClipperScale = exports.inchToClipperScale = undefined;\n\texports.elementToRawPaths = elementToRawPaths;\n\texports.flipY = flipY;\n\texports.hasClosedRawPaths = hasClosedRawPaths;\n\texports.filterClosedRawPaths = filterClosedRawPaths;\n\texports.rawPathsToClipperPaths = rawPathsToClipperPaths;\n\texports.triangulateRawPaths = triangulateRawPaths;\n\texports.clipperPathsToCPaths = clipperPathsToCPaths;\n\texports.cPathsToClipperPaths = cPathsToClipperPaths;\n\texports.cPathsToCamPaths = cPathsToCamPaths;\n\texports.clipperBounds = clipperBounds;\n\texports.clip = clip;\n\texports.union = union;\n\texports.diff = diff;\n\texports.xor = xor;\n\texports.offset = offset;\n\t\n\tvar _clipperLib = __webpack_require__(6);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tvar _sweepcontext = __webpack_require__(11);\n\t\n\tvar _sweepcontext2 = _interopRequireDefault(_sweepcontext);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar inchToClipperScale = exports.inchToClipperScale = 1270000000;\n\tvar mmToClipperScale = exports.mmToClipperScale = inchToClipperScale / 25.4; // 50000000;\n\tvar clipperToCppScale = exports.clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm\n\tvar cleanPolyDist = exports.cleanPolyDist = 100;\n\tvar arcTolerance = exports.arcTolerance = 10000;\n\t\n\t// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't\n\t// include (p1x, p1y); it's part of the previous segment.\n\tfunction linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {\n\t    function bez(p0, p1, p2, p3, t) {\n\t        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\n\t    }\n\t\n\t    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y) return ['L', p2x, p2y];\n\t\n\t    var numSegments = minNumSegments;\n\t    while (true) {\n\t        var x = p1x;\n\t        var y = p1y;\n\t        var result = ['L'];\n\t        for (var i = 1; i <= numSegments; ++i) {\n\t            var t = 1.0 * i / numSegments;\n\t            var nextX = bez(p1x, c1x, c2x, p2x, t);\n\t            var nextY = bez(p1y, c1y, c2y, p2y, t);\n\t            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {\n\t                numSegments *= 2;\n\t                result = null;\n\t                break;\n\t            }\n\t            result.push(nextX, nextY);\n\t            x = nextX;\n\t            y = nextY;\n\t        }\n\t        if (result) return result;\n\t    }\n\t}\n\t\n\t// Linearize a path. Both the input path and the returned path are in snap.svg's format.\n\t// Calls alertFn with an error message and returns null if there's a problem.\n\tfunction linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {\n\t    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {\n\t        alertFn('Path does not begin with M');\n\t        return null;\n\t    }\n\t    var x = path[0][1];\n\t    var y = path[0][2];\n\t    var result = [path[0]];\n\t    for (var i = 1; i < path.length; ++i) {\n\t        var subpath = path[i];\n\t        if (subpath[0] == 'C' && subpath.length == 7) {\n\t            result.push(linearizeCubicBezier(x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));\n\t            x = subpath[5];\n\t            y = subpath[6];\n\t        } else if (subpath[0] == 'M' && subpath.length == 3) {\n\t            result.push(subpath);\n\t            x = subpath[1];\n\t            y = subpath[2];\n\t        } else {\n\t            alertFn('Subpath has an unknown prefix: ' + subpath[0]);\n\t            return null;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t// Get linear paths (snap format) from an SVG element. Calls alertFn with an \n\t// error message and returns null if there's a problem.\n\tfunction elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {\n\t    var path = null;\n\t    var Snap = __webpack_require__(13);\n\t    var snapElement = Snap(element);\n\t\n\t    if (snapElement.type == 'path') path = snapElement.attr('d');else if (snapElement.type == 'rect') {\n\t        var x = Number(snapElement.attr('x'));\n\t        var y = Number(snapElement.attr('y'));\n\t        var w = Number(snapElement.attr('width'));\n\t        var h = Number(snapElement.attr('height'));\n\t        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + -w + ',' + 0 + ' ' + 0 + ',' + -h + ' ';\n\t    } else {\n\t        alertFn('<b>' + snapElement.type + \"</b> is not supported; try Inkscape's <strong>Object to Path</strong> command\");\n\t        return null;\n\t    }\n\t\n\t    if (snapElement.attr('clip-path') != '') {\n\t        alertFn('clip-path is not supported');\n\t        return null;\n\t    }\n\t\n\t    if (snapElement.attr('mask') != '') {\n\t        alertFn('mask is not supported');\n\t        return null;\n\t    }\n\t\n\t    if (path == null) {\n\t        alertFn('path is missing');\n\t        return;\n\t    }\n\t\n\t    path = Snap.path.map(path, snapElement.transform().globalMatrix);\n\t    path = Snap.parsePathString(path);\n\t    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);\n\t    return path;\n\t};\n\t\n\t// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].\n\t// Result is in mm. Returns multiple paths. Only supports linear paths.\n\t// Calls alertFn with an error message and returns null if there's a problem.\n\tfunction snapPathToRawPaths(snapPath, pxPerInch, alertFn) {\n\t    var factor = 25.4 / pxPerInch;\n\t    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {\n\t        alertFn('Path does not begin with M');\n\t        return null;\n\t    }\n\t    var currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];\n\t    var result = [currentPath];\n\t    for (var i = 1; i < snapPath.length; ++i) {\n\t        var subpath = snapPath[i];\n\t        if (subpath[0] == 'M' && subpath.length == 3) {\n\t            currentPath = [subpath[1] * factor, subpath[2] * factor];\n\t            result.push(currentPath);\n\t        } else if (subpath[0] == 'L') {\n\t            for (var j = 0; j < (subpath.length - 1) / 2; ++j) {\n\t                currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);\n\t            }\n\t        } else {\n\t            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);\n\t            return null;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].\n\t// Result is in mm. Returns multiple paths. Converts curves.\n\t// Calls alertFn with an error message and returns null if there's a problem.\n\tfunction elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {\n\t    var path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);\n\t    if (path !== null) return snapPathToRawPaths(path, pxPerInch, alertFn);\n\t    return null;\n\t}\n\t\n\t// [[[x0, y0, x1, y1, ...], ...], ...]\n\tfunction flipY(allRawPaths, deltaY) {\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t        for (var _iterator = allRawPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var rawPaths = _step.value;\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = rawPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var rawPath = _step2.value;\n\t\n\t                    for (var i = 0; i < rawPath.length; i += 2) {\n\t                        rawPath[i + 1] = deltaY - rawPath[i + 1];\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError) {\n\t                throw _iteratorError;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hasClosedRawPaths(rawPaths) {\n\t    var _iteratorNormalCompletion3 = true;\n\t    var _didIteratorError3 = false;\n\t    var _iteratorError3 = undefined;\n\t\n\t    try {\n\t        for (var _iterator3 = rawPaths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t            var path = _step3.value;\n\t\n\t            if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) return true;\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t            }\n\t        }\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\tfunction filterClosedRawPaths(rawPaths) {\n\t    var result = [];\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = rawPaths[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var path = _step4.value;\n\t\n\t            if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) result.push(path);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction rawPathsToClipperPaths(rawPaths, scaleX, scaleY, translateX, translateY) {\n\t    var result = rawPaths.map(function (p) {\n\t        var result = [];\n\t        for (var i = 0; i < p.length; i += 2) {\n\t            result.push({ X: (p[i] * scaleX + translateX) * mmToClipperScale, Y: (p[i + 1] * scaleY + translateY) * mmToClipperScale });\n\t        }return result;\n\t    });\n\t    if (hasClosedRawPaths(rawPaths)) {\n\t        result = _clipperLib2.default.Clipper.CleanPolygons(result, cleanPolyDist);\n\t        result = _clipperLib2.default.Clipper.SimplifyPolygons(result, _clipperLib2.default.PolyFillType.pftEvenOdd);\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction clipperPathsToPolyTree(paths) {\n\t    var c = new _clipperLib2.default.Clipper();\n\t    c.AddPaths(paths, _clipperLib2.default.PolyType.ptSubject, true);\n\t    var polyTree = new _clipperLib2.default.PolyTree();\n\t    c.Execute(_clipperLib2.default.ClipType.ctUnion, polyTree, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);\n\t    return polyTree;\n\t}\n\t\n\tfunction triangulatePolyTree(polyTree) {\n\t    var result = [];\n\t    var pointToVertex = function pointToVertex(point) {\n\t        return { x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale };\n\t    };\n\t    var contourToVertexes = function contourToVertexes(path) {\n\t        return path.map(pointToVertex);\n\t    };\n\t    var nodesToVertexes = function nodesToVertexes(nodes) {\n\t        return nodes.map(function (node) {\n\t            return contourToVertexes(node.Contour());\n\t        });\n\t    };\n\t    var processNode = function processNode(node) {\n\t        var vertexes = contourToVertexes(node.Contour());\n\t        var holes = nodesToVertexes(node.Childs());\n\t        var context = new _sweepcontext2.default(vertexes);\n\t        context.addHoles(holes);\n\t        context.triangulate();\n\t        var triangles = context.getTriangles();\n\t        var _iteratorNormalCompletion5 = true;\n\t        var _didIteratorError5 = false;\n\t        var _iteratorError5 = undefined;\n\t\n\t        try {\n\t            for (var _iterator5 = triangles[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t                var t = _step5.value;\n\t\n\t                var p = t.getPoints();\n\t                result.push(p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError5 = true;\n\t            _iteratorError5 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t                    _iterator5.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError5) {\n\t                    throw _iteratorError5;\n\t                }\n\t            }\n\t        }\n\t\n\t        var _iteratorNormalCompletion6 = true;\n\t        var _didIteratorError6 = false;\n\t        var _iteratorError6 = undefined;\n\t\n\t        try {\n\t            for (var _iterator6 = node.Childs()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t                var hole = _step6.value;\n\t                var _iteratorNormalCompletion7 = true;\n\t                var _didIteratorError7 = false;\n\t                var _iteratorError7 = undefined;\n\t\n\t                try {\n\t                    for (var _iterator7 = hole.Childs()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t                        var next = _step7.value;\n\t\n\t                        processNode(next);\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError7 = true;\n\t                    _iteratorError7 = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t                            _iterator7.return();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError7) {\n\t                            throw _iteratorError7;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError6 = true;\n\t            _iteratorError6 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t                    _iterator6.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError6) {\n\t                    throw _iteratorError6;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var _iteratorNormalCompletion8 = true;\n\t    var _didIteratorError8 = false;\n\t    var _iteratorError8 = undefined;\n\t\n\t    try {\n\t        for (var _iterator8 = polyTree.Childs()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t            var node = _step8.value;\n\t\n\t            processNode(node);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError8 = true;\n\t        _iteratorError8 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t                _iterator8.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError8) {\n\t                throw _iteratorError8;\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction triangulateRawPaths(rawPaths) {\n\t    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, 1, 1, 0, 0)));\n\t}\n\t\n\t// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].\n\tfunction clipperPathsToCPaths(memoryBlocks, clipperPaths) {\n\t    var doubleSize = 8;\n\t\n\t    var cPaths = Module._malloc(clipperPaths.length * 4);\n\t    memoryBlocks.push(cPaths);\n\t    var cPathsBase = cPaths >> 2;\n\t\n\t    var cPathSizes = Module._malloc(clipperPaths.length * 4);\n\t    memoryBlocks.push(cPathSizes);\n\t    var cPathSizesBase = cPathSizes >> 2;\n\t\n\t    for (var i = 0; i < clipperPaths.length; ++i) {\n\t        var clipperPath = clipperPaths[i];\n\t\n\t        var cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);\n\t        memoryBlocks.push(cPath);\n\t        if (cPath & 4) cPath += 4;\n\t        //console.log(\"-> \" + cPath.toString(16));\n\t        var pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\t\n\t        for (var j = 0; j < clipperPath.length; ++j) {\n\t            var point = clipperPath[j];\n\t            pathArray[j * 2] = point.X * clipperToCppScale;\n\t            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;\n\t        }\n\t\n\t        Module.HEAPU32[cPathsBase + i] = cPath;\n\t        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;\n\t    }\n\t\n\t    return [cPaths, clipperPaths.length, cPathSizes];\n\t}\n\t\n\t// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n\t// Each point has X, Y (stride = 2).\n\tfunction cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n\t    var cPaths = Module.HEAPU32[cPathsRef >> 2];\n\t    memoryBlocks.push(cPaths);\n\t    var cPathsBase = cPaths >> 2;\n\t\n\t    var cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\t\n\t    var cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n\t    memoryBlocks.push(cPathSizes);\n\t    var cPathSizesBase = cPathSizes >> 2;\n\t\n\t    var clipperPaths = [];\n\t    for (var i = 0; i < cNumPaths; ++i) {\n\t        var pathSize = Module.HEAPU32[cPathSizesBase + i];\n\t        var cPath = Module.HEAPU32[cPathsBase + i];\n\t        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n\t        memoryBlocks.push(cPath);\n\t        if (cPath & 4) cPath += 4;\n\t        var pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\t\n\t        var clipperPath = [];\n\t        clipperPaths.push(clipperPath);\n\t        for (var j = 0; j < pathSize; ++j) {\n\t            clipperPath.push({\n\t                X: pathArray[j * 2] / clipperToCppScale,\n\t                Y: pathArray[j * 2 + 1] / clipperToCppScale\n\t            });\n\t        }\n\t    }\n\t\n\t    return clipperPaths;\n\t}\n\t\n\t// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n\t// Each point has X, Y, Z (stride = 3).\n\tfunction cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n\t    var cPaths = Module.HEAPU32[cPathsRef >> 2];\n\t    memoryBlocks.push(cPaths);\n\t    var cPathsBase = cPaths >> 2;\n\t\n\t    var cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\t\n\t    var cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n\t    memoryBlocks.push(cPathSizes);\n\t    var cPathSizesBase = cPathSizes >> 2;\n\t\n\t    var convertedPaths = [];\n\t    for (var i = 0; i < cNumPaths; ++i) {\n\t        var pathSize = Module.HEAPU32[cPathSizesBase + i];\n\t        var cPath = Module.HEAPU32[cPathsBase + i];\n\t        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n\t        memoryBlocks.push(cPath);\n\t        if (cPath & 4) cPath += 4;\n\t        var pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\t\n\t        var convertedPath = [];\n\t        convertedPaths.push({ path: convertedPath, safeToClose: false });\n\t        for (var j = 0; j < pathSize; ++j) {\n\t            convertedPath.push({\n\t                X: pathArray[j * 3] / clipperToCppScale,\n\t                Y: pathArray[j * 3 + 1] / clipperToCppScale,\n\t                Z: pathArray[j * 3 + 2] / clipperToCppScale\n\t            });\n\t        } //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);\n\t    }\n\t\n\t    return convertedPaths;\n\t}\n\t\n\tfunction clipperBounds(paths) {\n\t    var minX = Number.MAX_VALUE;\n\t    var minY = Number.MAX_VALUE;\n\t    var maxX = -Number.MAX_VALUE;\n\t    var maxY = -Number.MAX_VALUE;\n\t    var _iteratorNormalCompletion9 = true;\n\t    var _didIteratorError9 = false;\n\t    var _iteratorError9 = undefined;\n\t\n\t    try {\n\t        for (var _iterator9 = paths[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t            var path = _step9.value;\n\t            var _iteratorNormalCompletion10 = true;\n\t            var _didIteratorError10 = false;\n\t            var _iteratorError10 = undefined;\n\t\n\t            try {\n\t                for (var _iterator10 = path[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t                    var pt = _step10.value;\n\t\n\t                    minX = Math.min(minX, pt.X);\n\t                    maxX = Math.max(maxX, pt.X);\n\t                    minY = Math.min(minY, pt.Y);\n\t                    maxY = Math.max(maxY, pt.Y);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError10 = true;\n\t                _iteratorError10 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t                        _iterator10.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError10) {\n\t                        throw _iteratorError10;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError9 = true;\n\t        _iteratorError9 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t                _iterator9.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError9) {\n\t                throw _iteratorError9;\n\t            }\n\t        }\n\t    }\n\t\n\t    return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };\n\t}\n\t\n\t// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.\n\tfunction clip(paths1, paths2, clipType) {\n\t    var clipper = new _clipperLib2.default.Clipper();\n\t    clipper.AddPaths(paths1, _clipperLib2.default.PolyType.ptSubject, true);\n\t    clipper.AddPaths(paths2, _clipperLib2.default.PolyType.ptClip, true);\n\t    var result = [];\n\t    clipper.Execute(clipType, result, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);\n\t    return result;\n\t}\n\t\n\t// Return union of two Clipper geometries. Returns new geometry.\n\tfunction union(paths1, paths2) {\n\t    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctUnion);\n\t}\n\t\n\t// Return difference between two Clipper geometries. Returns new geometry.\n\tfunction diff(paths1, paths2) {\n\t    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctDifference);\n\t}\n\t\n\t// Return xor of two Clipper geometries. Returns new geometry.\n\tfunction xor(paths1, paths2) {\n\t    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctXor);\n\t}\n\t\n\t// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.\n\tfunction offset(paths, amount, joinType, endType) {\n\t    if (joinType === undefined) joinType = _clipperLib2.default.JoinType.jtRound;\n\t    if (endType === undefined) endType = _clipperLib2.default.EndType.etClosedPolygon;\n\t\n\t    // bug workaround: join types are swapped in ClipperLib 6.1.3.2\n\t    if (joinType === _clipperLib2.default.JoinType.jtSquare) joinType = _clipperLib2.default.JoinType.jtMiter;else if (joinType === _clipperLib2.default.JoinType.jtMiter) joinType = _clipperLib2.default.JoinType.jtSquare;\n\t\n\t    var co = new _clipperLib2.default.ClipperOffset(2, arcTolerance);\n\t    co.AddPaths(paths, joinType, endType);\n\t    var offsetted = [];\n\t    co.Execute(offsetted, amount);\n\t    return offsetted;\n\t}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x¹,y¹) & (x²,y²) is ...\n\t    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n\t    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n\t    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t// ┌────────────────────────────────────────────────────────────┐ \\\\\n\t// │ Eve 0.4.2 - JavaScript Events Library                      │ \\\\\n\t// ├────────────────────────────────────────────────────────────┤ \\\\\n\t// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n\t// └────────────────────────────────────────────────────────────┘ \\\\\n\t\n\t(function (glob) {\n\t    var version = \"0.4.2\",\n\t        has = \"hasOwnProperty\",\n\t        separator = /[\\.\\/]/,\n\t        comaseparator = /\\s*,\\s*/,\n\t        wildcard = \"*\",\n\t        fun = function () {},\n\t        numsort = function (a, b) {\n\t            return a - b;\n\t        },\n\t        current_event,\n\t        stop,\n\t        events = {n: {}},\n\t        firstDefined = function () {\n\t            for (var i = 0, ii = this.length; i < ii; i++) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        lastDefined = function () {\n\t            var i = this.length;\n\t            while (--i) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t    /*\\\n\t     * eve\n\t     [ method ]\n\t\n\t     * Fires event with given `name`, given scope and other parameters.\n\t\n\t     > Arguments\n\t\n\t     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n\t     - scope (object) context for the event handlers\n\t     - varargs (...) the rest of arguments will be sent to event handlers\n\t\n\t     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n\t    \\*/\n\t        eve = function (name, scope) {\n\t            name = String(name);\n\t            var e = events,\n\t                oldstop = stop,\n\t                args = Array.prototype.slice.call(arguments, 2),\n\t                listeners = eve.listeners(name),\n\t                z = 0,\n\t                f = false,\n\t                l,\n\t                indexed = [],\n\t                queue = {},\n\t                out = [],\n\t                ce = current_event,\n\t                errors = [];\n\t            out.firstDefined = firstDefined;\n\t            out.lastDefined = lastDefined;\n\t            current_event = name;\n\t            stop = 0;\n\t            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n\t                indexed.push(listeners[i].zIndex);\n\t                if (listeners[i].zIndex < 0) {\n\t                    queue[listeners[i].zIndex] = listeners[i];\n\t                }\n\t            }\n\t            indexed.sort(numsort);\n\t            while (indexed[z] < 0) {\n\t                l = queue[indexed[z++]];\n\t                out.push(l.apply(scope, args));\n\t                if (stop) {\n\t                    stop = oldstop;\n\t                    return out;\n\t                }\n\t            }\n\t            for (i = 0; i < ii; i++) {\n\t                l = listeners[i];\n\t                if (\"zIndex\" in l) {\n\t                    if (l.zIndex == indexed[z]) {\n\t                        out.push(l.apply(scope, args));\n\t                        if (stop) {\n\t                            break;\n\t                        }\n\t                        do {\n\t                            z++;\n\t                            l = queue[indexed[z]];\n\t                            l && out.push(l.apply(scope, args));\n\t                            if (stop) {\n\t                                break;\n\t                            }\n\t                        } while (l)\n\t                    } else {\n\t                        queue[l.zIndex] = l;\n\t                    }\n\t                } else {\n\t                    out.push(l.apply(scope, args));\n\t                    if (stop) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            stop = oldstop;\n\t            current_event = ce;\n\t            return out;\n\t        };\n\t        // Undocumented. Debug only.\n\t        eve._events = events;\n\t    /*\\\n\t     * eve.listeners\n\t     [ method ]\n\t\n\t     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\t\n\t     > Arguments\n\t\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\t\n\t     = (array) array of event handlers\n\t    \\*/\n\t    eve.listeners = function (name) {\n\t        var names = name.split(separator),\n\t            e = events,\n\t            item,\n\t            items,\n\t            k,\n\t            i,\n\t            ii,\n\t            j,\n\t            jj,\n\t            nes,\n\t            es = [e],\n\t            out = [];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            nes = [];\n\t            for (j = 0, jj = es.length; j < jj; j++) {\n\t                e = es[j].n;\n\t                items = [e[names[i]], e[wildcard]];\n\t                k = 2;\n\t                while (k--) {\n\t                    item = items[k];\n\t                    if (item) {\n\t                        nes.push(item);\n\t                        out = out.concat(item.f || []);\n\t                    }\n\t                }\n\t            }\n\t            es = nes;\n\t        }\n\t        return out;\n\t    };\n\t    \n\t    /*\\\n\t     * eve.on\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n\t     | eve.on(\"*.under.*\", f);\n\t     | eve(\"mouse.under.floor\"); // triggers f\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n\t     > Example:\n\t     | eve.on(\"mouse\", eatIt)(2);\n\t     | eve.on(\"mouse\", scream);\n\t     | eve.on(\"mouse\", catchIt)(1);\n\t     * This will ensure that `catchIt` function will be called before `eatIt`.\n\t     *\n\t     * If you want to put your handler before non-indexed handlers, specify a negative value.\n\t     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n\t    \\*/\n\t    eve.on = function (name, f) {\n\t        name = String(name);\n\t        if (typeof f != \"function\") {\n\t            return function () {};\n\t        }\n\t        var names = name.split(comaseparator);\n\t        for (var i = 0, ii = names.length; i < ii; i++) {\n\t            (function (name) {\n\t                var names = name.split(separator),\n\t                    e = events,\n\t                    exist;\n\t                for (var i = 0, ii = names.length; i < ii; i++) {\n\t                    e = e.n;\n\t                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n\t                }\n\t                e.f = e.f || [];\n\t                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n\t                    exist = true;\n\t                    break;\n\t                }\n\t                !exist && e.f.push(f);\n\t            }(names[i]));\n\t        }\n\t        return function (zIndex) {\n\t            if (+zIndex == +zIndex) {\n\t                f.zIndex = +zIndex;\n\t            }\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.f\n\t     [ method ]\n\t     **\n\t     * Returns function that will fire given event with optional arguments.\n\t     * Arguments that will be passed to the result function will be also\n\t     * concated to the list of final arguments.\n\t     | el.onclick = eve.f(\"click\", 1, 2);\n\t     | eve.on(\"click\", function (a, b, c) {\n\t     |     console.log(a, b, c); // 1, 2, [event object]\n\t     | });\n\t     > Arguments\n\t     - event (string) event name\n\t     - varargs (…) and any other arguments\n\t     = (function) possible event handler function\n\t    \\*/\n\t    eve.f = function (event) {\n\t        var attrs = [].slice.call(arguments, 1);\n\t        return function () {\n\t            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.stop\n\t     [ method ]\n\t     **\n\t     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n\t    \\*/\n\t    eve.stop = function () {\n\t        stop = 1;\n\t    };\n\t    /*\\\n\t     * eve.nt\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     > Arguments\n\t     **\n\t     - subname (string) #optional subname of the event\n\t     **\n\t     = (string) name of the event, if `subname` is not specified\n\t     * or\n\t     = (boolean) `true`, if current event’s name contains `subname`\n\t    \\*/\n\t    eve.nt = function (subname) {\n\t        if (subname) {\n\t            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n\t        }\n\t        return current_event;\n\t    };\n\t    /*\\\n\t     * eve.nts\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     **\n\t     = (array) names of the event\n\t    \\*/\n\t    eve.nts = function () {\n\t        return current_event.split(separator);\n\t    };\n\t    /*\\\n\t     * eve.off\n\t     [ method ]\n\t     **\n\t     * Removes given function from the list of event listeners assigned to given name.\n\t     * If no arguments specified all the events will be cleared.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t    \\*/\n\t    /*\\\n\t     * eve.unbind\n\t     [ method ]\n\t     **\n\t     * See @eve.off\n\t    \\*/\n\t    eve.off = eve.unbind = function (name, f) {\n\t        if (!name) {\n\t            eve._events = events = {n: {}};\n\t            return;\n\t        }\n\t        var names = name.split(comaseparator);\n\t        if (names.length > 1) {\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                eve.off(names[i], f);\n\t            }\n\t            return;\n\t        }\n\t        names = name.split(separator);\n\t        var e,\n\t            key,\n\t            splice,\n\t            i, ii, j, jj,\n\t            cur = [events];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            for (j = 0; j < cur.length; j += splice.length - 2) {\n\t                splice = [j, 1];\n\t                e = cur[j].n;\n\t                if (names[i] != wildcard) {\n\t                    if (e[names[i]]) {\n\t                        splice.push(e[names[i]]);\n\t                    }\n\t                } else {\n\t                    for (key in e) if (e[has](key)) {\n\t                        splice.push(e[key]);\n\t                    }\n\t                }\n\t                cur.splice.apply(cur, splice);\n\t            }\n\t        }\n\t        for (i = 0, ii = cur.length; i < ii; i++) {\n\t            e = cur[i];\n\t            while (e.n) {\n\t                if (f) {\n\t                    if (e.f) {\n\t                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n\t                            e.f.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !e.f.length && delete e.f;\n\t                    }\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        var funcs = e.n[key].f;\n\t                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n\t                            funcs.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !funcs.length && delete e.n[key].f;\n\t                    }\n\t                } else {\n\t                    delete e.f;\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        delete e.n[key].f;\n\t                    }\n\t                }\n\t                e = e.n;\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.once\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name to only run once then unbind itself.\n\t     | eve.once(\"login\", f);\n\t     | eve(\"login\"); // triggers f\n\t     | eve(\"login\"); // no listeners\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) same return function as @eve.on\n\t    \\*/\n\t    eve.once = function (name, f) {\n\t        var f2 = function () {\n\t            eve.unbind(name, f2);\n\t            return f.apply(this, arguments);\n\t        };\n\t        return eve.on(name, f2);\n\t    };\n\t    /*\\\n\t     * eve.version\n\t     [ property (string) ]\n\t     **\n\t     * Current version of the library.\n\t    \\*/\n\t    eve.version = version;\n\t    eve.toString = function () {\n\t        return \"You are running Eve \" + version;\n\t    };\n\t    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));\n\t})(this);\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t *\n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t *\n\t * All rights reserved.\n\t *\n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/*\n\t * Function added in the JavaScript version (was not present in the c++ version)\n\t */\n\t\n\t/**\n\t * assert and throw an exception.\n\t *\n\t * @private\n\t * @param {boolean} condition   the condition which is asserted\n\t * @param {string} message      the message which is display is condition is falsy\n\t */\n\tfunction assert(condition, message) {\n\t    if (!condition) {\n\t        throw new Error(message || \"Assert Failed\");\n\t    }\n\t}\n\tmodule.exports = assert;\n\t\n\t\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar xy = __webpack_require__(1);\n\t\n\t// ------------------------------------------------------------------------Point\n\t/**\n\t * Construct a point\n\t * @example\n\t *      var point = new poly2tri.Point(150, 150);\n\t * @public\n\t * @constructor\n\t * @struct\n\t * @param {number=} x    coordinate (0 if undefined)\n\t * @param {number=} y    coordinate (0 if undefined)\n\t */\n\tvar Point = function(x, y) {\n\t    /**\n\t     * @type {number}\n\t     * @expose\n\t     */\n\t    this.x = +x || 0;\n\t    /**\n\t     * @type {number}\n\t     * @expose\n\t     */\n\t    this.y = +y || 0;\n\t\n\t    // All extra fields added to Point are prefixed with _p2t_\n\t    // to avoid collisions if custom Point class is used.\n\t\n\t    /**\n\t     * The edges this point constitutes an upper ending point\n\t     * @private\n\t     * @type {Array.<Edge>}\n\t     */\n\t    this._p2t_edge_list = null;\n\t};\n\t\n\t/**\n\t * For pretty printing\n\t * @example\n\t *      \"p=\" + new poly2tri.Point(5,42)\n\t *      // → \"p=(5;42)\"\n\t * @returns {string} <code>\"(x;y)\"</code>\n\t */\n\tPoint.prototype.toString = function() {\n\t    return xy.toStringBase(this);\n\t};\n\t\n\t/**\n\t * JSON output, only coordinates\n\t * @example\n\t *      JSON.stringify(new poly2tri.Point(1,2))\n\t *      // → '{\"x\":1,\"y\":2}'\n\t */\n\tPoint.prototype.toJSON = function() {\n\t    return { x: this.x, y: this.y };\n\t};\n\t\n\t/**\n\t * Creates a copy of this Point object.\n\t * @return {Point} new cloned point\n\t */\n\tPoint.prototype.clone = function() {\n\t    return new Point(this.x, this.y);\n\t};\n\t\n\t/**\n\t * Set this Point instance to the origo. <code>(0; 0)</code>\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.set_zero = function() {\n\t    this.x = 0.0;\n\t    this.y = 0.0;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Set the coordinates of this instance.\n\t * @param {number} x   coordinate\n\t * @param {number} y   coordinate\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.set = function(x, y) {\n\t    this.x = +x || 0;\n\t    this.y = +y || 0;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Negate this Point instance. (component-wise)\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.negate = function() {\n\t    this.x = -this.x;\n\t    this.y = -this.y;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Add another Point object to this instance. (component-wise)\n\t * @param {!Point} n - Point object.\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.add = function(n) {\n\t    this.x += n.x;\n\t    this.y += n.y;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Subtract this Point instance with another point given. (component-wise)\n\t * @param {!Point} n - Point object.\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.sub = function(n) {\n\t    this.x -= n.x;\n\t    this.y -= n.y;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Multiply this Point instance by a scalar. (component-wise)\n\t * @param {number} s   scalar.\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.mul = function(s) {\n\t    this.x *= s;\n\t    this.y *= s;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Return the distance of this Point instance from the origo.\n\t * @return {number} distance\n\t */\n\tPoint.prototype.length = function() {\n\t    return Math.sqrt(this.x * this.x + this.y * this.y);\n\t};\n\t\n\t/**\n\t * Normalize this Point instance (as a vector).\n\t * @return {number} The original distance of this instance from the origo.\n\t */\n\tPoint.prototype.normalize = function() {\n\t    var len = this.length();\n\t    this.x /= len;\n\t    this.y /= len;\n\t    return len;\n\t};\n\t\n\t/**\n\t * Test this Point object with another for equality.\n\t * @param {!XY} p - any \"Point like\" object with {x,y}\n\t * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.\n\t */\n\tPoint.prototype.equals = function(p) {\n\t    return this.x === p.x && this.y === p.y;\n\t};\n\t\n\t\n\t// -----------------------------------------------------Point (\"static\" methods)\n\t\n\t/**\n\t * Negate a point component-wise and return the result as a new Point object.\n\t * @param {!XY} p - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.negate = function(p) {\n\t    return new Point(-p.x, -p.y);\n\t};\n\t\n\t/**\n\t * Add two points component-wise and return the result as a new Point object.\n\t * @param {!XY} a - any \"Point like\" object with {x,y}\n\t * @param {!XY} b - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.add = function(a, b) {\n\t    return new Point(a.x + b.x, a.y + b.y);\n\t};\n\t\n\t/**\n\t * Subtract two points component-wise and return the result as a new Point object.\n\t * @param {!XY} a - any \"Point like\" object with {x,y}\n\t * @param {!XY} b - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.sub = function(a, b) {\n\t    return new Point(a.x - b.x, a.y - b.y);\n\t};\n\t\n\t/**\n\t * Multiply a point by a scalar and return the result as a new Point object.\n\t * @param {number} s - the scalar\n\t * @param {!XY} p - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.mul = function(s, p) {\n\t    return new Point(s * p.x, s * p.y);\n\t};\n\t\n\t/**\n\t * Perform the cross product on either two points (this produces a scalar)\n\t * or a point and a scalar (this produces a point).\n\t * This function requires two parameters, either may be a Point object or a\n\t * number.\n\t * @param  {XY|number} a - Point object or scalar.\n\t * @param  {XY|number} b - Point object or scalar.\n\t * @return {Point|number} a Point object or a number, depending on the parameters.\n\t */\n\tPoint.cross = function(a, b) {\n\t    if (typeof(a) === 'number') {\n\t        if (typeof(b) === 'number') {\n\t            return a * b;\n\t        } else {\n\t            return new Point(-a * b.y, a * b.x);\n\t        }\n\t    } else {\n\t        if (typeof(b) === 'number') {\n\t            return new Point(b * a.y, -b * a.x);\n\t        } else {\n\t            return a.x * b.y - a.y * b.x;\n\t        }\n\t    }\n\t};\n\t\n\t\n\t// -----------------------------------------------------------------\"Point-Like\"\n\t/*\n\t * The following functions operate on \"Point\" or any \"Point like\" object \n\t * with {x,y} (duck typing).\n\t */\n\t\n\tPoint.toString = xy.toString;\n\tPoint.compare = xy.compare;\n\tPoint.cmp = xy.compare; // backward compatibility\n\tPoint.equals = xy.equals;\n\t\n\t/**\n\t * Peform the dot product on two vectors.\n\t * @public\n\t * @param {!XY} a - any \"Point like\" object with {x,y}\n\t * @param {!XY} b - any \"Point like\" object with {x,y}\n\t * @return {number} The dot product\n\t */\n\tPoint.dot = function(a, b) {\n\t    return a.x * b.x + a.y * b.y;\n\t};\n\t\n\t\n\t// ---------------------------------------------------------Exports (public API)\n\t\n\tmodule.exports = Point;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint latedef:nofunc, maxcomplexity:9 */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * This 'Sweep' module is present in order to keep this JavaScript version\n\t * as close as possible to the reference C++ version, even though almost all\n\t * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.\n\t * @module\n\t * @private\n\t */\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar assert = __webpack_require__(8);\n\tvar PointError = __webpack_require__(3);\n\tvar Triangle = __webpack_require__(4);\n\tvar Node = __webpack_require__(2).Node;\n\t\n\t\n\t// ------------------------------------------------------------------------utils\n\t\n\tvar utils = __webpack_require__(12);\n\t\n\t/** @const */\n\tvar EPSILON = utils.EPSILON;\n\t\n\t/** @const */\n\tvar Orientation = utils.Orientation;\n\t/** @const */\n\tvar orient2d = utils.orient2d;\n\t/** @const */\n\tvar inScanArea = utils.inScanArea;\n\t/** @const */\n\tvar isAngleObtuse = utils.isAngleObtuse;\n\t\n\t\n\t// ------------------------------------------------------------------------Sweep\n\t\n\t/**\n\t * Triangulate the polygon with holes and Steiner points.\n\t * Do this AFTER you've added the polyline, holes, and Steiner points\n\t * @private\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction triangulate(tcx) {\n\t    tcx.initTriangulation();\n\t    tcx.createAdvancingFront();\n\t    // Sweep points; build mesh\n\t    sweepPoints(tcx);\n\t    // Clean up\n\t    finalizationPolygon(tcx);\n\t}\n\t\n\t/**\n\t * Start sweeping the Y-sorted point set from bottom to top\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction sweepPoints(tcx) {\n\t    var i, len = tcx.pointCount();\n\t    for (i = 1; i < len; ++i) {\n\t        var point = tcx.getPoint(i);\n\t        var node = pointEvent(tcx, point);\n\t        var edges = point._p2t_edge_list;\n\t        for (var j = 0; edges && j < edges.length; ++j) {\n\t            edgeEventByEdge(tcx, edges[j], node);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction finalizationPolygon(tcx) {\n\t    // Get an Internal triangle to start with\n\t    var t = tcx.front().head().next.triangle;\n\t    var p = tcx.front().head().next.point;\n\t    while (!t.getConstrainedEdgeCW(p)) {\n\t        t = t.neighborCCW(p);\n\t    }\n\t\n\t    // Collect interior triangles constrained by edges\n\t    tcx.meshClean(t);\n\t}\n\t\n\t/**\n\t * Find closes node to the left of the new point and\n\t * create a new triangle. If needed new holes and basins\n\t * will be filled to.\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param {!XY} point   Point\n\t */\n\tfunction pointEvent(tcx, point) {\n\t    var node = tcx.locateNode(point);\n\t    var new_node = newFrontTriangle(tcx, point, node);\n\t\n\t    // Only need to check +epsilon since point never have smaller\n\t    // x value than node due to how we fetch nodes from the front\n\t    if (point.x <= node.point.x + (EPSILON)) {\n\t        fill(tcx, node);\n\t    }\n\t\n\t    //tcx.AddNode(new_node);\n\t\n\t    fillAdvancingFront(tcx, new_node);\n\t    return new_node;\n\t}\n\t\n\tfunction edgeEventByEdge(tcx, edge, node) {\n\t    tcx.edge_event.constrained_edge = edge;\n\t    tcx.edge_event.right = (edge.p.x > edge.q.x);\n\t\n\t    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {\n\t        return;\n\t    }\n\t\n\t    // For now we will do all needed filling\n\t    // TODO: integrate with flip process might give some better performance\n\t    //       but for now this avoid the issue with cases that needs both flips and fills\n\t    fillEdgeEvent(tcx, edge, node);\n\t    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);\n\t}\n\t\n\tfunction edgeEventByPoints(tcx, ep, eq, triangle, point) {\n\t    if (isEdgeSideOfTriangle(triangle, ep, eq)) {\n\t        return;\n\t    }\n\t\n\t    var p1 = triangle.pointCCW(point);\n\t    var o1 = orient2d(eq, p1, ep);\n\t    if (o1 === Orientation.COLLINEAR) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision 09880a869095 dated March 8, 2011)\n\t        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);\n\t    }\n\t\n\t    var p2 = triangle.pointCW(point);\n\t    var o2 = orient2d(eq, p2, ep);\n\t    if (o2 === Orientation.COLLINEAR) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision 09880a869095 dated March 8, 2011)\n\t        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);\n\t    }\n\t\n\t    if (o1 === o2) {\n\t        // Need to decide if we are rotating CW or CCW to get to a triangle\n\t        // that will cross edge\n\t        if (o1 === Orientation.CW) {\n\t            triangle = triangle.neighborCCW(point);\n\t        } else {\n\t            triangle = triangle.neighborCW(point);\n\t        }\n\t        edgeEventByPoints(tcx, ep, eq, triangle, point);\n\t    } else {\n\t        // This triangle crosses constraint so lets flippin start!\n\t        flipEdgeEvent(tcx, ep, eq, triangle, point);\n\t    }\n\t}\n\t\n\tfunction isEdgeSideOfTriangle(triangle, ep, eq) {\n\t    var index = triangle.edgeIndex(ep, eq);\n\t    if (index !== -1) {\n\t        triangle.markConstrainedEdgeByIndex(index);\n\t        var t = triangle.getNeighbor(index);\n\t        if (t) {\n\t            t.markConstrainedEdgeByPoints(ep, eq);\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * Creates a new front triangle and legalize it\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction newFrontTriangle(tcx, point, node) {\n\t    var triangle = new Triangle(point, node.point, node.next.point);\n\t\n\t    triangle.markNeighbor(node.triangle);\n\t    tcx.addToMap(triangle);\n\t\n\t    var new_node = new Node(point);\n\t    new_node.next = node.next;\n\t    new_node.prev = node;\n\t    node.next.prev = new_node;\n\t    node.next = new_node;\n\t\n\t    if (!legalize(tcx, triangle)) {\n\t        tcx.mapTriangleToNodes(triangle);\n\t    }\n\t\n\t    return new_node;\n\t}\n\t\n\t/**\n\t * Adds a triangle to the advancing front to fill a hole.\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param node - middle node, that is the bottom of the hole\n\t */\n\tfunction fill(tcx, node) {\n\t    var triangle = new Triangle(node.prev.point, node.point, node.next.point);\n\t\n\t    // TODO: should copy the constrained_edge value from neighbor triangles\n\t    //       for now constrained_edge values are copied during the legalize\n\t    triangle.markNeighbor(node.prev.triangle);\n\t    triangle.markNeighbor(node.triangle);\n\t\n\t    tcx.addToMap(triangle);\n\t\n\t    // Update the advancing front\n\t    node.prev.next = node.next;\n\t    node.next.prev = node.prev;\n\t\n\t\n\t    // If it was legalized the triangle has already been mapped\n\t    if (!legalize(tcx, triangle)) {\n\t        tcx.mapTriangleToNodes(triangle);\n\t    }\n\t\n\t    //tcx.removeNode(node);\n\t}\n\t\n\t/**\n\t * Fills holes in the Advancing Front\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction fillAdvancingFront(tcx, n) {\n\t    // Fill right holes\n\t    var node = n.next;\n\t    while (node.next) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n\t        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n\t            break;\n\t        }\n\t        fill(tcx, node);\n\t        node = node.next;\n\t    }\n\t\n\t    // Fill left holes\n\t    node = n.prev;\n\t    while (node.prev) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n\t        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n\t            break;\n\t        }\n\t        fill(tcx, node);\n\t        node = node.prev;\n\t    }\n\t\n\t    // Fill right basins\n\t    if (n.next && n.next.next) {\n\t        if (isBasinAngleRight(n)) {\n\t            fillBasin(tcx, n);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * The basin angle is decided against the horizontal line [1,0].\n\t * @param {Node} node\n\t * @return {boolean} true if angle < 3*π/4\n\t */\n\tfunction isBasinAngleRight(node) {\n\t    var ax = node.point.x - node.next.next.point.x;\n\t    var ay = node.point.y - node.next.next.point.y;\n\t    assert(ay >= 0, \"unordered y\");\n\t    return (ax >= 0 || Math.abs(ax) < ay);\n\t}\n\t\n\t/**\n\t * Returns true if triangle was legalized\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @return {boolean}\n\t */\n\tfunction legalize(tcx, t) {\n\t    // To legalize a triangle we start by finding if any of the three edges\n\t    // violate the Delaunay condition\n\t    for (var i = 0; i < 3; ++i) {\n\t        if (t.delaunay_edge[i]) {\n\t            continue;\n\t        }\n\t        var ot = t.getNeighbor(i);\n\t        if (ot) {\n\t            var p = t.getPoint(i);\n\t            var op = ot.oppositePoint(t, p);\n\t            var oi = ot.index(op);\n\t\n\t            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)\n\t            // then we should not try to legalize\n\t            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {\n\t                t.constrained_edge[i] = ot.constrained_edge[oi];\n\t                continue;\n\t            }\n\t\n\t            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);\n\t            if (inside) {\n\t                // Lets mark this shared edge as Delaunay\n\t                t.delaunay_edge[i] = true;\n\t                ot.delaunay_edge[oi] = true;\n\t\n\t                // Lets rotate shared edge one vertex CW to legalize it\n\t                rotateTrianglePair(t, p, ot, op);\n\t\n\t                // We now got one valid Delaunay Edge shared by two triangles\n\t                // This gives us 4 new edges to check for Delaunay\n\t\n\t                // Make sure that triangle to node mapping is done only one time for a specific triangle\n\t                var not_legalized = !legalize(tcx, t);\n\t                if (not_legalized) {\n\t                    tcx.mapTriangleToNodes(t);\n\t                }\n\t\n\t                not_legalized = !legalize(tcx, ot);\n\t                if (not_legalized) {\n\t                    tcx.mapTriangleToNodes(ot);\n\t                }\n\t                // Reset the Delaunay edges, since they only are valid Delaunay edges\n\t                // until we add a new triangle or point.\n\t                // XXX: need to think about this. Can these edges be tried after we\n\t                //      return to previous recursive level?\n\t                t.delaunay_edge[i] = false;\n\t                ot.delaunay_edge[oi] = false;\n\t\n\t                // If triangle have been legalized no need to check the other edges since\n\t                // the recursive legalization will handles those so we can end here.\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * <b>Requirement</b>:<br>\n\t * 1. a,b and c form a triangle.<br>\n\t * 2. a and d is know to be on opposite side of bc<br>\n\t * <pre>\n\t *                a\n\t *                +\n\t *               / \\\n\t *              /   \\\n\t *            b/     \\c\n\t *            +-------+\n\t *           /    d    \\\n\t *          /           \\\n\t * </pre>\n\t * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by\n\t *  a,b and c<br>\n\t *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>\n\t *  This preknowledge gives us a way to optimize the incircle test\n\t * @param pa - triangle point, opposite d\n\t * @param pb - triangle point\n\t * @param pc - triangle point\n\t * @param pd - point opposite a\n\t * @return {boolean} true if d is inside circle, false if on circle edge\n\t */\n\tfunction inCircle(pa, pb, pc, pd) {\n\t    var adx = pa.x - pd.x;\n\t    var ady = pa.y - pd.y;\n\t    var bdx = pb.x - pd.x;\n\t    var bdy = pb.y - pd.y;\n\t\n\t    var adxbdy = adx * bdy;\n\t    var bdxady = bdx * ady;\n\t    var oabd = adxbdy - bdxady;\n\t    if (oabd <= 0) {\n\t        return false;\n\t    }\n\t\n\t    var cdx = pc.x - pd.x;\n\t    var cdy = pc.y - pd.y;\n\t\n\t    var cdxady = cdx * ady;\n\t    var adxcdy = adx * cdy;\n\t    var ocad = cdxady - adxcdy;\n\t    if (ocad <= 0) {\n\t        return false;\n\t    }\n\t\n\t    var bdxcdy = bdx * cdy;\n\t    var cdxbdy = cdx * bdy;\n\t\n\t    var alift = adx * adx + ady * ady;\n\t    var blift = bdx * bdx + bdy * bdy;\n\t    var clift = cdx * cdx + cdy * cdy;\n\t\n\t    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;\n\t    return det > 0;\n\t}\n\t\n\t/**\n\t * Rotates a triangle pair one vertex CW\n\t *<pre>\n\t *       n2                    n2\n\t *  P +-----+             P +-----+\n\t *    | t  /|               |\\  t |\n\t *    |   / |               | \\   |\n\t *  n1|  /  |n3           n1|  \\  |n3\n\t *    | /   |    after CW   |   \\ |\n\t *    |/ oT |               | oT \\|\n\t *    +-----+ oP            +-----+\n\t *       n4                    n4\n\t * </pre>\n\t */\n\tfunction rotateTrianglePair(t, p, ot, op) {\n\t    var n1, n2, n3, n4;\n\t    n1 = t.neighborCCW(p);\n\t    n2 = t.neighborCW(p);\n\t    n3 = ot.neighborCCW(op);\n\t    n4 = ot.neighborCW(op);\n\t\n\t    var ce1, ce2, ce3, ce4;\n\t    ce1 = t.getConstrainedEdgeCCW(p);\n\t    ce2 = t.getConstrainedEdgeCW(p);\n\t    ce3 = ot.getConstrainedEdgeCCW(op);\n\t    ce4 = ot.getConstrainedEdgeCW(op);\n\t\n\t    var de1, de2, de3, de4;\n\t    de1 = t.getDelaunayEdgeCCW(p);\n\t    de2 = t.getDelaunayEdgeCW(p);\n\t    de3 = ot.getDelaunayEdgeCCW(op);\n\t    de4 = ot.getDelaunayEdgeCW(op);\n\t\n\t    t.legalize(p, op);\n\t    ot.legalize(op, p);\n\t\n\t    // Remap delaunay_edge\n\t    ot.setDelaunayEdgeCCW(p, de1);\n\t    t.setDelaunayEdgeCW(p, de2);\n\t    t.setDelaunayEdgeCCW(op, de3);\n\t    ot.setDelaunayEdgeCW(op, de4);\n\t\n\t    // Remap constrained_edge\n\t    ot.setConstrainedEdgeCCW(p, ce1);\n\t    t.setConstrainedEdgeCW(p, ce2);\n\t    t.setConstrainedEdgeCCW(op, ce3);\n\t    ot.setConstrainedEdgeCW(op, ce4);\n\t\n\t    // Remap neighbors\n\t    // XXX: might optimize the markNeighbor by keeping track of\n\t    //      what side should be assigned to what neighbor after the\n\t    //      rotation. Now mark neighbor does lots of testing to find\n\t    //      the right side.\n\t    t.clearNeighbors();\n\t    ot.clearNeighbors();\n\t    if (n1) {\n\t        ot.markNeighbor(n1);\n\t    }\n\t    if (n2) {\n\t        t.markNeighbor(n2);\n\t    }\n\t    if (n3) {\n\t        t.markNeighbor(n3);\n\t    }\n\t    if (n4) {\n\t        ot.markNeighbor(n4);\n\t    }\n\t    t.markNeighbor(ot);\n\t}\n\t\n\t/**\n\t * Fills a basin that has formed on the Advancing Front to the right\n\t * of given node.<br>\n\t * First we decide a left,bottom and right node that forms the\n\t * boundaries of the basin. Then we do a reqursive fill.\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param node - starting node, this or next node will be left node\n\t */\n\tfunction fillBasin(tcx, node) {\n\t    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n\t        tcx.basin.left_node = node.next.next;\n\t    } else {\n\t        tcx.basin.left_node = node.next;\n\t    }\n\t\n\t    // Find the bottom and right node\n\t    tcx.basin.bottom_node = tcx.basin.left_node;\n\t    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {\n\t        tcx.basin.bottom_node = tcx.basin.bottom_node.next;\n\t    }\n\t    if (tcx.basin.bottom_node === tcx.basin.left_node) {\n\t        // No valid basin\n\t        return;\n\t    }\n\t\n\t    tcx.basin.right_node = tcx.basin.bottom_node;\n\t    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {\n\t        tcx.basin.right_node = tcx.basin.right_node.next;\n\t    }\n\t    if (tcx.basin.right_node === tcx.basin.bottom_node) {\n\t        // No valid basins\n\t        return;\n\t    }\n\t\n\t    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;\n\t    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;\n\t\n\t    fillBasinReq(tcx, tcx.basin.bottom_node);\n\t}\n\t\n\t/**\n\t * Recursive algorithm to fill a Basin with triangles\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param node - bottom_node\n\t */\n\tfunction fillBasinReq(tcx, node) {\n\t    // if shallow stop filling\n\t    if (isShallow(tcx, node)) {\n\t        return;\n\t    }\n\t\n\t    fill(tcx, node);\n\t\n\t    var o;\n\t    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {\n\t        return;\n\t    } else if (node.prev === tcx.basin.left_node) {\n\t        o = orient2d(node.point, node.next.point, node.next.next.point);\n\t        if (o === Orientation.CW) {\n\t            return;\n\t        }\n\t        node = node.next;\n\t    } else if (node.next === tcx.basin.right_node) {\n\t        o = orient2d(node.point, node.prev.point, node.prev.prev.point);\n\t        if (o === Orientation.CCW) {\n\t            return;\n\t        }\n\t        node = node.prev;\n\t    } else {\n\t        // Continue with the neighbor node with lowest Y value\n\t        if (node.prev.point.y < node.next.point.y) {\n\t            node = node.prev;\n\t        } else {\n\t            node = node.next;\n\t        }\n\t    }\n\t\n\t    fillBasinReq(tcx, node);\n\t}\n\t\n\tfunction isShallow(tcx, node) {\n\t    var height;\n\t    if (tcx.basin.left_highest) {\n\t        height = tcx.basin.left_node.point.y - node.point.y;\n\t    } else {\n\t        height = tcx.basin.right_node.point.y - node.point.y;\n\t    }\n\t\n\t    // if shallow stop filling\n\t    if (tcx.basin.width > height) {\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\tfunction fillEdgeEvent(tcx, edge, node) {\n\t    if (tcx.edge_event.right) {\n\t        fillRightAboveEdgeEvent(tcx, edge, node);\n\t    } else {\n\t        fillLeftAboveEdgeEvent(tcx, edge, node);\n\t    }\n\t}\n\t\n\tfunction fillRightAboveEdgeEvent(tcx, edge, node) {\n\t    while (node.next.point.x < edge.p.x) {\n\t        // Check if next node is below the edge\n\t        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n\t            fillRightBelowEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            node = node.next;\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillRightBelowEdgeEvent(tcx, edge, node) {\n\t    if (node.point.x < edge.p.x) {\n\t        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n\t            // Concave\n\t            fillRightConcaveEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            // Convex\n\t            fillRightConvexEdgeEvent(tcx, edge, node);\n\t            // Retry this one\n\t            fillRightBelowEdgeEvent(tcx, edge, node);\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillRightConcaveEdgeEvent(tcx, edge, node) {\n\t    fill(tcx, node.next);\n\t    if (node.next.point !== edge.p) {\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n\t            // Below\n\t            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n\t                // Next is concave\n\t                fillRightConcaveEdgeEvent(tcx, edge, node);\n\t            } else {\n\t                // Next is convex\n\t                /* jshint noempty:false */\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillRightConvexEdgeEvent(tcx, edge, node) {\n\t    // Next concave or convex?\n\t    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {\n\t        // Concave\n\t        fillRightConcaveEdgeEvent(tcx, edge, node.next);\n\t    } else {\n\t        // Convex\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {\n\t            // Below\n\t            fillRightConvexEdgeEvent(tcx, edge, node.next);\n\t        } else {\n\t            // Above\n\t            /* jshint noempty:false */\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftAboveEdgeEvent(tcx, edge, node) {\n\t    while (node.prev.point.x > edge.p.x) {\n\t        // Check if next node is below the edge\n\t        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n\t            fillLeftBelowEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            node = node.prev;\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftBelowEdgeEvent(tcx, edge, node) {\n\t    if (node.point.x > edge.p.x) {\n\t        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n\t            // Concave\n\t            fillLeftConcaveEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            // Convex\n\t            fillLeftConvexEdgeEvent(tcx, edge, node);\n\t            // Retry this one\n\t            fillLeftBelowEdgeEvent(tcx, edge, node);\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftConvexEdgeEvent(tcx, edge, node) {\n\t    // Next concave or convex?\n\t    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {\n\t        // Concave\n\t        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);\n\t    } else {\n\t        // Convex\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {\n\t            // Below\n\t            fillLeftConvexEdgeEvent(tcx, edge, node.prev);\n\t        } else {\n\t            // Above\n\t            /* jshint noempty:false */\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftConcaveEdgeEvent(tcx, edge, node) {\n\t    fill(tcx, node.prev);\n\t    if (node.prev.point !== edge.p) {\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n\t            // Below\n\t            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n\t                // Next is concave\n\t                fillLeftConcaveEdgeEvent(tcx, edge, node);\n\t            } else {\n\t                // Next is convex\n\t                /* jshint noempty:false */\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction flipEdgeEvent(tcx, ep, eq, t, p) {\n\t    var ot = t.neighborAcross(p);\n\t    assert(ot, \"FLIP failed due to missing triangle!\");\n\t\n\t    var op = ot.oppositePoint(t, p);\n\t\n\t    // Additional check from Java version (see issue #88)\n\t    if (t.getConstrainedEdgeAcross(p)) {\n\t        var index = t.index(p);\n\t        throw new PointError(\"poly2tri Intersecting Constraints\",\n\t                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);\n\t    }\n\t\n\t    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {\n\t        // Lets rotate shared edge one vertex CW\n\t        rotateTrianglePair(t, p, ot, op);\n\t        tcx.mapTriangleToNodes(t);\n\t        tcx.mapTriangleToNodes(ot);\n\t\n\t        // XXX: in the original C++ code for the next 2 lines, we are\n\t        // comparing point values (and not pointers). In this JavaScript\n\t        // code, we are comparing point references (pointers). This works\n\t        // because we can't have 2 different points with the same values.\n\t        // But to be really equivalent, we should use \"Point.equals\" here.\n\t        if (p === eq && op === ep) {\n\t            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {\n\t                t.markConstrainedEdgeByPoints(ep, eq);\n\t                ot.markConstrainedEdgeByPoints(ep, eq);\n\t                legalize(tcx, t);\n\t                legalize(tcx, ot);\n\t            } else {\n\t                // XXX: I think one of the triangles should be legalized here?\n\t                /* jshint noempty:false */\n\t            }\n\t        } else {\n\t            var o = orient2d(eq, op, ep);\n\t            t = nextFlipTriangle(tcx, o, t, ot, p, op);\n\t            flipEdgeEvent(tcx, ep, eq, t, p);\n\t        }\n\t    } else {\n\t        var newP = nextFlipPoint(ep, eq, ot, op);\n\t        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);\n\t        edgeEventByPoints(tcx, ep, eq, t, p);\n\t    }\n\t}\n\t\n\t/**\n\t * After a flip we have two triangles and know that only one will still be\n\t * intersecting the edge. So decide which to contiune with and legalize the other\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param o - should be the result of an orient2d( eq, op, ep )\n\t * @param t - triangle 1\n\t * @param ot - triangle 2\n\t * @param p - a point shared by both triangles\n\t * @param op - another point shared by both triangles\n\t * @return returns the triangle still intersecting the edge\n\t */\n\tfunction nextFlipTriangle(tcx, o, t, ot, p, op) {\n\t    var edge_index;\n\t    if (o === Orientation.CCW) {\n\t        // ot is not crossing edge after flip\n\t        edge_index = ot.edgeIndex(p, op);\n\t        ot.delaunay_edge[edge_index] = true;\n\t        legalize(tcx, ot);\n\t        ot.clearDelaunayEdges();\n\t        return t;\n\t    }\n\t\n\t    // t is not crossing edge after flip\n\t    edge_index = t.edgeIndex(p, op);\n\t\n\t    t.delaunay_edge[edge_index] = true;\n\t    legalize(tcx, t);\n\t    t.clearDelaunayEdges();\n\t    return ot;\n\t}\n\t\n\t/**\n\t * When we need to traverse from one triangle to the next we need\n\t * the point in current triangle that is the opposite point to the next\n\t * triangle.\n\t */\n\tfunction nextFlipPoint(ep, eq, ot, op) {\n\t    var o2d = orient2d(eq, op, ep);\n\t    if (o2d === Orientation.CW) {\n\t        // Right\n\t        return ot.pointCCW(op);\n\t    } else if (o2d === Orientation.CCW) {\n\t        // Left\n\t        return ot.pointCW(op);\n\t    } else {\n\t        throw new PointError(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [eq, op, ep]);\n\t    }\n\t}\n\t\n\t/**\n\t * Scan part of the FlipScan algorithm<br>\n\t * When a triangle pair isn't flippable we will scan for the next\n\t * point that is inside the flip triangle scan area. When found\n\t * we generate a new flipEdgeEvent\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param ep - last point on the edge we are traversing\n\t * @param eq - first point on the edge we are traversing\n\t * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge\n\t * @param t\n\t * @param p\n\t */\n\tfunction flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {\n\t    var ot = t.neighborAcross(p);\n\t    assert(ot, \"FLIP failed due to missing triangle\");\n\t\n\t    var op = ot.oppositePoint(t, p);\n\t\n\t    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {\n\t        // flip with new edge op.eq\n\t        flipEdgeEvent(tcx, eq, op, ot, op);\n\t    } else {\n\t        var newP = nextFlipPoint(ep, eq, ot, op);\n\t        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);\n\t    }\n\t}\n\t\n\t\n\t// ----------------------------------------------------------------------Exports\n\t\n\texports.triangulate = triangulate;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint maxcomplexity:6 */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar PointError = __webpack_require__(3);\n\tvar Point = __webpack_require__(9);\n\tvar Triangle = __webpack_require__(4);\n\tvar sweep = __webpack_require__(10);\n\tvar AdvancingFront = __webpack_require__(2);\n\tvar Node = AdvancingFront.Node;\n\t\n\t\n\t// ------------------------------------------------------------------------utils\n\t\n\t/**\n\t * Initial triangle factor, seed triangle will extend 30% of\n\t * PointSet width to both left and right.\n\t * @private\n\t * @const\n\t */\n\tvar kAlpha = 0.3;\n\t\n\t\n\t// -------------------------------------------------------------------------Edge\n\t/**\n\t * Represents a simple polygon's edge\n\t * @constructor\n\t * @struct\n\t * @private\n\t * @param {Point} p1\n\t * @param {Point} p2\n\t * @throw {PointError} if p1 is same as p2\n\t */\n\tvar Edge = function(p1, p2) {\n\t    this.p = p1;\n\t    this.q = p2;\n\t\n\t    if (p1.y > p2.y) {\n\t        this.q = p1;\n\t        this.p = p2;\n\t    } else if (p1.y === p2.y) {\n\t        if (p1.x > p2.x) {\n\t            this.q = p1;\n\t            this.p = p2;\n\t        } else if (p1.x === p2.x) {\n\t            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n\t        }\n\t    }\n\t\n\t    if (!this.q._p2t_edge_list) {\n\t        this.q._p2t_edge_list = [];\n\t    }\n\t    this.q._p2t_edge_list.push(this);\n\t};\n\t\n\t\n\t// ------------------------------------------------------------------------Basin\n\t/**\n\t * @constructor\n\t * @struct\n\t * @private\n\t */\n\tvar Basin = function() {\n\t    /** @type {Node} */\n\t    this.left_node = null;\n\t    /** @type {Node} */\n\t    this.bottom_node = null;\n\t    /** @type {Node} */\n\t    this.right_node = null;\n\t    /** @type {number} */\n\t    this.width = 0.0;\n\t    /** @type {boolean} */\n\t    this.left_highest = false;\n\t};\n\t\n\tBasin.prototype.clear = function() {\n\t    this.left_node = null;\n\t    this.bottom_node = null;\n\t    this.right_node = null;\n\t    this.width = 0.0;\n\t    this.left_highest = false;\n\t};\n\t\n\t// --------------------------------------------------------------------EdgeEvent\n\t/**\n\t * @constructor\n\t * @struct\n\t * @private\n\t */\n\tvar EdgeEvent = function() {\n\t    /** @type {Edge} */\n\t    this.constrained_edge = null;\n\t    /** @type {boolean} */\n\t    this.right = false;\n\t};\n\t\n\t// ----------------------------------------------------SweepContext (public API)\n\t/**\n\t * SweepContext constructor option\n\t * @typedef {Object} SweepContextOptions\n\t * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters\n\t *                  (contour, holes). Points inside arrays are never copied.\n\t *                  Default is <code>false</code> : keep a reference to the array arguments,\n\t *                  who will be modified in place.\n\t */\n\t/**\n\t * Constructor for the triangulation context.\n\t * It accepts a simple polyline (with non repeating points), \n\t * which defines the constrained edges.\n\t *\n\t * @example\n\t *          var contour = [\n\t *              new poly2tri.Point(100, 100),\n\t *              new poly2tri.Point(100, 300),\n\t *              new poly2tri.Point(300, 300),\n\t *              new poly2tri.Point(300, 100)\n\t *          ];\n\t *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n\t * @example\n\t *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n\t *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n\t * @constructor\n\t * @public\n\t * @struct\n\t * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,\n\t *          or any \"Point like\" custom class with <code>{x, y}</code> attributes.\n\t * @param {SweepContextOptions=} options - constructor options\n\t */\n\tvar SweepContext = function(contour, options) {\n\t    options = options || {};\n\t    this.triangles_ = [];\n\t    this.map_ = [];\n\t    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);\n\t    this.edge_list = [];\n\t\n\t    // Bounding box of all points. Computed at the start of the triangulation, \n\t    // it is stored in case it is needed by the caller.\n\t    this.pmin_ = this.pmax_ = null;\n\t\n\t    /**\n\t     * Advancing front\n\t     * @private\n\t     * @type {AdvancingFront}\n\t     */\n\t    this.front_ = null;\n\t\n\t    /**\n\t     * head point used with advancing front\n\t     * @private\n\t     * @type {Point}\n\t     */\n\t    this.head_ = null;\n\t\n\t    /**\n\t     * tail point used with advancing front\n\t     * @private\n\t     * @type {Point}\n\t     */\n\t    this.tail_ = null;\n\t\n\t    /**\n\t     * @private\n\t     * @type {Node}\n\t     */\n\t    this.af_head_ = null;\n\t    /**\n\t     * @private\n\t     * @type {Node}\n\t     */\n\t    this.af_middle_ = null;\n\t    /**\n\t     * @private\n\t     * @type {Node}\n\t     */\n\t    this.af_tail_ = null;\n\t\n\t    this.basin = new Basin();\n\t    this.edge_event = new EdgeEvent();\n\t\n\t    this.initEdges(this.points_);\n\t};\n\t\n\t\n\t/**\n\t * Add a hole to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var hole = [\n\t *          new poly2tri.Point(200, 200),\n\t *          new poly2tri.Point(200, 250),\n\t *          new poly2tri.Point(250, 250)\n\t *      ];\n\t *      swctx.addHole(hole);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n\t * @public\n\t * @param {Array.<XY>} polyline - array of \"Point like\" objects with {x,y}\n\t */\n\tSweepContext.prototype.addHole = function(polyline) {\n\t    this.initEdges(polyline);\n\t    var i, len = polyline.length;\n\t    for (i = 0; i < len; i++) {\n\t        this.points_.push(polyline[i]);\n\t    }\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode SweepContext#addHole} instead\n\t */\n\tSweepContext.prototype.AddHole = SweepContext.prototype.addHole;\n\t\n\t\n\t/**\n\t * Add several holes to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var holes = [\n\t *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n\t *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n\t *      ];\n\t *      swctx.addHoles(holes);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var holes = [\n\t *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n\t *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n\t *      ];\n\t *      swctx.addHoles(holes);\n\t * @public\n\t * @param {Array.<Array.<XY>>} holes - array of array of \"Point like\" objects with {x,y}\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.addHoles = function(holes) {\n\t    var i, len = holes.length;\n\t    for (i = 0; i < len; i++) {\n\t        this.initEdges(holes[i]);\n\t    }\n\t    this.points_ = this.points_.concat.apply(this.points_, holes);\n\t    return this; // for chaining\n\t};\n\t\n\t\n\t/**\n\t * Add a Steiner point to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var point = new poly2tri.Point(150, 150);\n\t *      swctx.addPoint(point);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.addPoint({x:150, y:150});\n\t * @public\n\t * @param {XY} point - any \"Point like\" object with {x,y}\n\t */\n\tSweepContext.prototype.addPoint = function(point) {\n\t    this.points_.push(point);\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode SweepContext#addPoint} instead\n\t */\n\tSweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;\n\t\n\t\n\t/**\n\t * Add several Steiner points to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var points = [\n\t *          new poly2tri.Point(150, 150),\n\t *          new poly2tri.Point(200, 250),\n\t *          new poly2tri.Point(250, 250)\n\t *      ];\n\t *      swctx.addPoints(points);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n\t * @public\n\t * @param {Array.<XY>} points - array of \"Point like\" object with {x,y}\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.addPoints = function(points) {\n\t    this.points_ = this.points_.concat(points);\n\t    return this; // for chaining\n\t};\n\t\n\t\n\t/**\n\t * Triangulate the polygon with holes and Steiner points.\n\t * Do this AFTER you've added the polyline, holes, and Steiner points\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t * @public\n\t */\n\t// Shortcut method for sweep.triangulate(SweepContext).\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.triangulate = function() {\n\t    sweep.triangulate(this);\n\t    return this; // for chaining\n\t};\n\t\n\t\n\t/**\n\t * Get the bounding box of the provided constraints (contour, holes and \n\t * Steinter points). Warning : these values are not available if the triangulation \n\t * has not been done yet.\n\t * @public\n\t * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.getBoundingBox = function() {\n\t    return {min: this.pmin_, max: this.pmax_};\n\t};\n\t\n\t/**\n\t * Get result of triangulation.\n\t * The output triangles have vertices which are references\n\t * to the initial input points (not copies): any custom fields in the\n\t * initial points can be retrieved in the output triangles.\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t * @example\n\t *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t *      typeof triangles[0].getPoint(0).id\n\t *      // → \"number\"\n\t * @public\n\t * @returns {array<Triangle>}   array of triangles\n\t */\n\tSweepContext.prototype.getTriangles = function() {\n\t    return this.triangles_;\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode SweepContext#getTriangles} instead\n\t */\n\tSweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;\n\t\n\t\n\t// ---------------------------------------------------SweepContext (private API)\n\t\n\t/** @private */\n\tSweepContext.prototype.front = function() {\n\t    return this.front_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.pointCount = function() {\n\t    return this.points_.length;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.head = function() {\n\t    return this.head_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.setHead = function(p1) {\n\t    this.head_ = p1;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.tail = function() {\n\t    return this.tail_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.setTail = function(p1) {\n\t    this.tail_ = p1;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.getMap = function() {\n\t    return this.map_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.initTriangulation = function() {\n\t    var xmax = this.points_[0].x;\n\t    var xmin = this.points_[0].x;\n\t    var ymax = this.points_[0].y;\n\t    var ymin = this.points_[0].y;\n\t\n\t    // Calculate bounds\n\t    var i, len = this.points_.length;\n\t    for (i = 1; i < len; i++) {\n\t        var p = this.points_[i];\n\t        /* jshint expr:true */\n\t        (p.x > xmax) && (xmax = p.x);\n\t        (p.x < xmin) && (xmin = p.x);\n\t        (p.y > ymax) && (ymax = p.y);\n\t        (p.y < ymin) && (ymin = p.y);\n\t    }\n\t    this.pmin_ = new Point(xmin, ymin);\n\t    this.pmax_ = new Point(xmax, ymax);\n\t\n\t    var dx = kAlpha * (xmax - xmin);\n\t    var dy = kAlpha * (ymax - ymin);\n\t    this.head_ = new Point(xmax + dx, ymin - dy);\n\t    this.tail_ = new Point(xmin - dx, ymin - dy);\n\t\n\t    // Sort points along y-axis\n\t    this.points_.sort(Point.compare);\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.initEdges = function(polyline) {\n\t    var i, len = polyline.length;\n\t    for (i = 0; i < len; ++i) {\n\t        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n\t    }\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.getPoint = function(index) {\n\t    return this.points_[index];\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.addToMap = function(triangle) {\n\t    this.map_.push(triangle);\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.locateNode = function(point) {\n\t    return this.front_.locateNode(point.x);\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.createAdvancingFront = function() {\n\t    var head;\n\t    var middle;\n\t    var tail;\n\t    // Initial triangle\n\t    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);\n\t\n\t    this.map_.push(triangle);\n\t\n\t    head = new Node(triangle.getPoint(1), triangle);\n\t    middle = new Node(triangle.getPoint(0), triangle);\n\t    tail = new Node(triangle.getPoint(2));\n\t\n\t    this.front_ = new AdvancingFront(head, tail);\n\t\n\t    head.next = middle;\n\t    middle.next = tail;\n\t    middle.prev = head;\n\t    tail.prev = middle;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.removeNode = function(node) {\n\t    // do nothing\n\t    /* jshint unused:false */\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.mapTriangleToNodes = function(t) {\n\t    for (var i = 0; i < 3; ++i) {\n\t        if (!t.getNeighbor(i)) {\n\t            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));\n\t            if (n) {\n\t                n.triangle = t;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.removeFromMap = function(triangle) {\n\t    var i, map = this.map_, len = map.length;\n\t    for (i = 0; i < len; i++) {\n\t        if (map[i] === triangle) {\n\t            map.splice(i, 1);\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Do a depth first traversal to collect triangles\n\t * @private\n\t * @param {Triangle} triangle start\n\t */\n\tSweepContext.prototype.meshClean = function(triangle) {\n\t    // New implementation avoids recursive calls and use a loop instead.\n\t    // Cf. issues # 57, 65 and 69.\n\t    var triangles = [triangle], t, i;\n\t    /* jshint boss:true */\n\t    while (t = triangles.pop()) {\n\t        if (!t.isInterior()) {\n\t            t.setInterior(true);\n\t            this.triangles_.push(t);\n\t            for (i = 0; i < 3; i++) {\n\t                if (!t.constrained_edge[i]) {\n\t                    triangles.push(t.getNeighbor(i));\n\t                }\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t// ----------------------------------------------------------------------Exports\n\t\n\tmodule.exports = SweepContext;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * Precision to detect repeated or collinear points\n\t * @private\n\t * @const {number}\n\t * @default\n\t */\n\tvar EPSILON = 1e-12;\n\texports.EPSILON = EPSILON;\n\t\n\t/**\n\t * @private\n\t * @enum {number}\n\t * @readonly\n\t */\n\tvar Orientation = {\n\t    \"CW\": 1,\n\t    \"CCW\": -1,\n\t    \"COLLINEAR\": 0\n\t};\n\texports.Orientation = Orientation;\n\t\n\t\n\t/**\n\t * Formula to calculate signed area<br>\n\t * Positive if CCW<br>\n\t * Negative if CW<br>\n\t * 0 if collinear<br>\n\t * <pre>\n\t * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)\n\t *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)\n\t * </pre>\n\t *\n\t * @private\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t * @return {Orientation}\n\t */\n\tfunction orient2d(pa, pb, pc) {\n\t    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\t    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n\t    var val = detleft - detright;\n\t    if (val > -(EPSILON) && val < (EPSILON)) {\n\t        return Orientation.COLLINEAR;\n\t    } else if (val > 0) {\n\t        return Orientation.CCW;\n\t    } else {\n\t        return Orientation.CW;\n\t    }\n\t}\n\texports.orient2d = orient2d;\n\t\n\t\n\t/**\n\t *\n\t * @private\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t * @param {!XY} pd  point object with {x,y}\n\t * @return {boolean}\n\t */\n\tfunction inScanArea(pa, pb, pc, pd) {\n\t    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);\n\t    if (oadb >= -EPSILON) {\n\t        return false;\n\t    }\n\t\n\t    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);\n\t    if (oadc <= EPSILON) {\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\texports.inScanArea = inScanArea;\n\t\n\t\n\t/**\n\t * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)\n\t *\n\t * @private\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t * @return {boolean} true if angle is obtuse\n\t */\n\tfunction isAngleObtuse(pa, pb, pc) {\n\t    var ax = pb.x - pa.x;\n\t    var ay = pb.y - pa.y;\n\t    var bx = pc.x - pa.x;\n\t    var by = pc.y - pa.y;\n\t    return (ax * bx + ay * by) < 0;\n\t}\n\texports.isAngleObtuse = isAngleObtuse;\n\t\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\twindow.eve = __webpack_require__(7)\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tvar mina = (function (eve) {\n\t    var animations = {},\n\t    requestAnimFrame = window.requestAnimationFrame       ||\n\t                       window.webkitRequestAnimationFrame ||\n\t                       window.mozRequestAnimationFrame    ||\n\t                       window.oRequestAnimationFrame      ||\n\t                       window.msRequestAnimationFrame     ||\n\t                       function (callback) {\n\t                           setTimeout(callback, 16);\n\t                       },\n\t    isArray = Array.isArray || function (a) {\n\t        return a instanceof Array ||\n\t            Object.prototype.toString.call(a) == \"[object Array]\";\n\t    },\n\t    idgen = 0,\n\t    idprefix = \"M\" + (+new Date).toString(36),\n\t    ID = function () {\n\t        return idprefix + (idgen++).toString(36);\n\t    },\n\t    diff = function (a, b, A, B) {\n\t        if (isArray(a)) {\n\t            res = [];\n\t            for (var i = 0, ii = a.length; i < ii; i++) {\n\t                res[i] = diff(a[i], b, A[i], B);\n\t            }\n\t            return res;\n\t        }\n\t        var dif = (A - a) / (B - b);\n\t        return function (bb) {\n\t            return a + dif * (bb - b);\n\t        };\n\t    },\n\t    timer = Date.now || function () {\n\t        return +new Date;\n\t    },\n\t    sta = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.s;\n\t        }\n\t        var ds = a.s - val;\n\t        a.b += a.dur * ds;\n\t        a.B += a.dur * ds;\n\t        a.s = val;\n\t    },\n\t    speed = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.spd;\n\t        }\n\t        a.spd = val;\n\t    },\n\t    duration = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.dur;\n\t        }\n\t        a.s = a.s * val / a.dur;\n\t        a.dur = val;\n\t    },\n\t    stopit = function () {\n\t        var a = this;\n\t        delete animations[a.id];\n\t        a.update();\n\t        eve(\"mina.stop.\" + a.id, a);\n\t    },\n\t    pause = function () {\n\t        var a = this;\n\t        if (a.pdif) {\n\t            return;\n\t        }\n\t        delete animations[a.id];\n\t        a.update();\n\t        a.pdif = a.get() - a.b;\n\t    },\n\t    resume = function () {\n\t        var a = this;\n\t        if (!a.pdif) {\n\t            return;\n\t        }\n\t        a.b = a.get() - a.pdif;\n\t        delete a.pdif;\n\t        animations[a.id] = a;\n\t    },\n\t    update = function () {\n\t        var a = this,\n\t            res;\n\t        if (isArray(a.start)) {\n\t            res = [];\n\t            for (var j = 0, jj = a.start.length; j < jj; j++) {\n\t                res[j] = +a.start[j] +\n\t                    (a.end[j] - a.start[j]) * a.easing(a.s);\n\t            }\n\t        } else {\n\t            res = +a.start + (a.end - a.start) * a.easing(a.s);\n\t        }\n\t        a.set(res);\n\t    },\n\t    frame = function () {\n\t        var len = 0;\n\t        for (var i in animations) if (animations.hasOwnProperty(i)) {\n\t            var a = animations[i],\n\t                b = a.get(),\n\t                res;\n\t            len++;\n\t            a.s = (b - a.b) / (a.dur / a.spd);\n\t            if (a.s >= 1) {\n\t                delete animations[i];\n\t                a.s = 1;\n\t                len--;\n\t                (function (a) {\n\t                    setTimeout(function () {\n\t                        eve(\"mina.finish.\" + a.id, a);\n\t                    });\n\t                }(a));\n\t            }\n\t            a.update();\n\t        }\n\t        len && requestAnimFrame(frame);\n\t    },\n\t    /*\\\n\t     * mina\n\t     [ method ]\n\t     **\n\t     * Generic animation of numbers\n\t     **\n\t     - a (number) start _slave_ number\n\t     - A (number) end _slave_ number\n\t     - b (number) start _master_ number (start time in general case)\n\t     - B (number) end _master_ number (end time in gereal case)\n\t     - get (function) getter of _master_ number (see @mina.time)\n\t     - set (function) setter of _slave_ number\n\t     - easing (function) #optional easing function, default is @mina.linear\n\t     = (object) animation descriptor\n\t     o {\n\t     o         id (string) animation id,\n\t     o         start (number) start _slave_ number,\n\t     o         end (number) end _slave_ number,\n\t     o         b (number) start _master_ number,\n\t     o         s (number) animation status (0..1),\n\t     o         dur (number) animation duration,\n\t     o         spd (number) animation speed,\n\t     o         get (function) getter of _master_ number (see @mina.time),\n\t     o         set (function) setter of _slave_ number,\n\t     o         easing (function) easing function, default is @mina.linear,\n\t     o         status (function) status getter/setter,\n\t     o         speed (function) speed getter/setter,\n\t     o         duration (function) duration getter/setter,\n\t     o         stop (function) animation stopper\n\t     o         pause (function) pauses the animation\n\t     o         resume (function) resumes the animation\n\t     o         update (function) calles setter with the right value of the animation\n\t     o }\n\t    \\*/\n\t    mina = function (a, A, b, B, get, set, easing) {\n\t        var anim = {\n\t            id: ID(),\n\t            start: a,\n\t            end: A,\n\t            b: b,\n\t            s: 0,\n\t            dur: B - b,\n\t            spd: 1,\n\t            get: get,\n\t            set: set,\n\t            easing: easing || mina.linear,\n\t            status: sta,\n\t            speed: speed,\n\t            duration: duration,\n\t            stop: stopit,\n\t            pause: pause,\n\t            resume: resume,\n\t            update: update\n\t        };\n\t        animations[anim.id] = anim;\n\t        var len = 0, i;\n\t        for (i in animations) if (animations.hasOwnProperty(i)) {\n\t            len++;\n\t            if (len == 2) {\n\t                break;\n\t            }\n\t        }\n\t        len == 1 && requestAnimFrame(frame);\n\t        return anim;\n\t    };\n\t    /*\\\n\t     * mina.time\n\t     [ method ]\n\t     **\n\t     * Returns the current time. Equivalent to:\n\t     | function () {\n\t     |     return (new Date).getTime();\n\t     | }\n\t    \\*/\n\t    mina.time = timer;\n\t    /*\\\n\t     * mina.getById\n\t     [ method ]\n\t     **\n\t     * Returns an animation by its id\n\t     - id (string) animation's id\n\t     = (object) See @mina\n\t    \\*/\n\t    mina.getById = function (id) {\n\t        return animations[id] || null;\n\t    };\n\t\n\t    /*\\\n\t     * mina.linear\n\t     [ method ]\n\t     **\n\t     * Default linear easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.linear = function (n) {\n\t        return n;\n\t    };\n\t    /*\\\n\t     * mina.easeout\n\t     [ method ]\n\t     **\n\t     * Easeout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easeout = function (n) {\n\t        return Math.pow(n, 1.7);\n\t    };\n\t    /*\\\n\t     * mina.easein\n\t     [ method ]\n\t     **\n\t     * Easein easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easein = function (n) {\n\t        return Math.pow(n, .48);\n\t    };\n\t    /*\\\n\t     * mina.easeinout\n\t     [ method ]\n\t     **\n\t     * Easeinout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easeinout = function (n) {\n\t        if (n == 1) {\n\t            return 1;\n\t        }\n\t        if (n == 0) {\n\t            return 0;\n\t        }\n\t        var q = .48 - n / 1.04,\n\t            Q = Math.sqrt(.1734 + q * q),\n\t            x = Q - q,\n\t            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n\t            y = -Q - q,\n\t            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n\t            t = X + Y + .5;\n\t        return (1 - t) * 3 * t * t + t * t * t;\n\t    };\n\t    /*\\\n\t     * mina.backin\n\t     [ method ]\n\t     **\n\t     * Backin easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.backin = function (n) {\n\t        if (n == 1) {\n\t            return 1;\n\t        }\n\t        var s = 1.70158;\n\t        return n * n * ((s + 1) * n - s);\n\t    };\n\t    /*\\\n\t     * mina.backout\n\t     [ method ]\n\t     **\n\t     * Backout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.backout = function (n) {\n\t        if (n == 0) {\n\t            return 0;\n\t        }\n\t        n = n - 1;\n\t        var s = 1.70158;\n\t        return n * n * ((s + 1) * n + s) + 1;\n\t    };\n\t    /*\\\n\t     * mina.elastic\n\t     [ method ]\n\t     **\n\t     * Elastic easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.elastic = function (n) {\n\t        if (n == !!n) {\n\t            return n;\n\t        }\n\t        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n\t            (2 * Math.PI) / .3) + 1;\n\t    };\n\t    /*\\\n\t     * mina.bounce\n\t     [ method ]\n\t     **\n\t     * Bounce easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.bounce = function (n) {\n\t        var s = 7.5625,\n\t            p = 2.75,\n\t            l;\n\t        if (n < (1 / p)) {\n\t            l = s * n * n;\n\t        } else {\n\t            if (n < (2 / p)) {\n\t                n -= (1.5 / p);\n\t                l = s * n * n + .75;\n\t            } else {\n\t                if (n < (2.5 / p)) {\n\t                    n -= (2.25 / p);\n\t                    l = s * n * n + .9375;\n\t                } else {\n\t                    n -= (2.625 / p);\n\t                    l = s * n * n + .984375;\n\t                }\n\t            }\n\t        }\n\t        return l;\n\t    };\n\t    window.mina = mina;\n\t    return mina;\n\t})(typeof eve == \"undefined\" ? function () {} : eve);\n\t// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t\n\tvar Snap = (function(root) {\n\tSnap.version = \"0.4.0\";\n\t/*\\\n\t * Snap\n\t [ method ]\n\t **\n\t * Creates a drawing surface or wraps existing SVG element.\n\t **\n\t - width (number|string) width of surface\n\t - height (number|string) height of surface\n\t * or\n\t - DOM (SVGElement) element to be wrapped into Snap structure\n\t * or\n\t - array (array) array of elements (will return set of elements)\n\t * or\n\t - query (string) CSS query selector\n\t = (object) @Element\n\t\\*/\n\tfunction Snap(w, h) {\n\t    if (w) {\n\t        if (w.nodeType) {\n\t            return wrap(w);\n\t        }\n\t        if (is(w, \"array\") && Snap.set) {\n\t            return Snap.set.apply(Snap, w);\n\t        }\n\t        if (w instanceof Element) {\n\t            return w;\n\t        }\n\t        if (h == null) {\n\t            w = glob.doc.querySelector(String(w));\n\t            return wrap(w);\n\t        }\n\t    }\n\t    w = w == null ? \"100%\" : w;\n\t    h = h == null ? \"100%\" : h;\n\t    return new Paper(w, h);\n\t}\n\tSnap.toString = function () {\n\t    return \"Snap v\" + this.version;\n\t};\n\tSnap._ = {};\n\tvar glob = {\n\t    win: root.window,\n\t    doc: root.window.document\n\t};\n\tSnap._.glob = glob;\n\tvar has = \"hasOwnProperty\",\n\t    Str = String,\n\t    toFloat = parseFloat,\n\t    toInt = parseInt,\n\t    math = Math,\n\t    mmax = math.max,\n\t    mmin = math.min,\n\t    abs = math.abs,\n\t    pow = math.pow,\n\t    PI = math.PI,\n\t    round = math.round,\n\t    E = \"\",\n\t    S = \" \",\n\t    objectToString = Object.prototype.toString,\n\t    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n\t    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n\t    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n\t    reURLValue = /^url\\(#?([^)]+)\\)$/,\n\t    separator = Snap._.separator = /[,\\s]+/,\n\t    whitespace = /[\\s]/g,\n\t    commaSpaces = /[\\s]*,[\\s]*/,\n\t    hsrg = {hs: 1, rg: 1},\n\t    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n\t    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n\t    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\\\d+)?)[\\s]*,?[\\s]*/ig,\n\t    idgen = 0,\n\t    idprefix = \"S\" + (+new Date).toString(36),\n\t    ID = function (el) {\n\t        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n\t    },\n\t    xlink = \"http://www.w3.org/1999/xlink\",\n\t    xmlns = \"http://www.w3.org/2000/svg\",\n\t    hub = {},\n\t    URL = Snap.url = function (url) {\n\t        return \"url('#\" + url + \"')\";\n\t    };\n\t\n\tfunction $(el, attr) {\n\t    if (attr) {\n\t        if (el == \"#text\") {\n\t            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n\t        }\n\t        if (el == \"#comment\") {\n\t            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n\t        }\n\t        if (typeof el == \"string\") {\n\t            el = $(el);\n\t        }\n\t        if (typeof attr == \"string\") {\n\t            if (el.nodeType == 1) {\n\t                if (attr.substring(0, 6) == \"xlink:\") {\n\t                    return el.getAttributeNS(xlink, attr.substring(6));\n\t                }\n\t                if (attr.substring(0, 4) == \"xml:\") {\n\t                    return el.getAttributeNS(xmlns, attr.substring(4));\n\t                }\n\t                return el.getAttribute(attr);\n\t            } else if (attr == \"text\") {\n\t                return el.nodeValue;\n\t            } else {\n\t                return null;\n\t            }\n\t        }\n\t        if (el.nodeType == 1) {\n\t            for (var key in attr) if (attr[has](key)) {\n\t                var val = Str(attr[key]);\n\t                if (val) {\n\t                    if (key.substring(0, 6) == \"xlink:\") {\n\t                        el.setAttributeNS(xlink, key.substring(6), val);\n\t                    } else if (key.substring(0, 4) == \"xml:\") {\n\t                        el.setAttributeNS(xmlns, key.substring(4), val);\n\t                    } else {\n\t                        el.setAttribute(key, val);\n\t                    }\n\t                } else {\n\t                    el.removeAttribute(key);\n\t                }\n\t            }\n\t        } else if (\"text\" in attr) {\n\t            el.nodeValue = attr.text;\n\t        }\n\t    } else {\n\t        el = glob.doc.createElementNS(xmlns, el);\n\t    }\n\t    return el;\n\t}\n\tSnap._.$ = $;\n\tSnap._.id = ID;\n\tfunction getAttrs(el) {\n\t    var attrs = el.attributes,\n\t        name,\n\t        out = {};\n\t    for (var i = 0; i < attrs.length; i++) {\n\t        if (attrs[i].namespaceURI == xlink) {\n\t            name = \"xlink:\";\n\t        } else {\n\t            name = \"\";\n\t        }\n\t        name += attrs[i].name;\n\t        out[name] = attrs[i].textContent;\n\t    }\n\t    return out;\n\t}\n\tfunction is(o, type) {\n\t    type = Str.prototype.toLowerCase.call(type);\n\t    if (type == \"finite\") {\n\t        return isFinite(o);\n\t    }\n\t    if (type == \"array\" &&\n\t        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n\t        return true;\n\t    }\n\t    return  (type == \"null\" && o === null) ||\n\t            (type == typeof o && o !== null) ||\n\t            (type == \"object\" && o === Object(o)) ||\n\t            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n\t}\n\t/*\\\n\t * Snap.format\n\t [ method ]\n\t **\n\t * Replaces construction of type `{<name>}` to the corresponding argument\n\t **\n\t - token (string) string to format\n\t - json (object) object which properties are used as a replacement\n\t = (string) formatted string\n\t > Usage\n\t | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n\t |     x: 10,\n\t |     y: 20,\n\t |     dim: {\n\t |         width: 40,\n\t |         height: 50,\n\t |         \"negative width\": -40\n\t |     }\n\t | }));\n\t\\*/\n\tSnap.format = (function () {\n\t    var tokenRegex = /\\{([^\\}]+)\\}/g,\n\t        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\t        replacer = function (all, key, obj) {\n\t            var res = obj;\n\t            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n\t                name = name || quotedName;\n\t                if (res) {\n\t                    if (name in res) {\n\t                        res = res[name];\n\t                    }\n\t                    typeof res == \"function\" && isFunc && (res = res());\n\t                }\n\t            });\n\t            res = (res == null || res == obj ? all : res) + \"\";\n\t            return res;\n\t        };\n\t    return function (str, obj) {\n\t        return Str(str).replace(tokenRegex, function (all, key) {\n\t            return replacer(all, key, obj);\n\t        });\n\t    };\n\t})();\n\tfunction clone(obj) {\n\t    if (typeof obj == \"function\" || Object(obj) !== obj) {\n\t        return obj;\n\t    }\n\t    var res = new obj.constructor;\n\t    for (var key in obj) if (obj[has](key)) {\n\t        res[key] = clone(obj[key]);\n\t    }\n\t    return res;\n\t}\n\tSnap._.clone = clone;\n\tfunction repush(array, item) {\n\t    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n\t        return array.push(array.splice(i, 1)[0]);\n\t    }\n\t}\n\tfunction cacher(f, scope, postprocessor) {\n\t    function newf() {\n\t        var arg = Array.prototype.slice.call(arguments, 0),\n\t            args = arg.join(\"\\u2400\"),\n\t            cache = newf.cache = newf.cache || {},\n\t            count = newf.count = newf.count || [];\n\t        if (cache[has](args)) {\n\t            repush(count, args);\n\t            return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t        }\n\t        count.length >= 1e3 && delete cache[count.shift()];\n\t        count.push(args);\n\t        cache[args] = f.apply(scope, arg);\n\t        return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t    }\n\t    return newf;\n\t}\n\tSnap._.cacher = cacher;\n\tfunction angle(x1, y1, x2, y2, x3, y3) {\n\t    if (x3 == null) {\n\t        var x = x1 - x2,\n\t            y = y1 - y2;\n\t        if (!x && !y) {\n\t            return 0;\n\t        }\n\t        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n\t    } else {\n\t        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n\t    }\n\t}\n\tfunction rad(deg) {\n\t    return deg % 360 * PI / 180;\n\t}\n\tfunction deg(rad) {\n\t    return rad * 180 / PI % 360;\n\t}\n\tfunction x_y() {\n\t    return this.x + S + this.y;\n\t}\n\tfunction x_y_w_h() {\n\t    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n\t}\n\t\n\t/*\\\n\t * Snap.rad\n\t [ method ]\n\t **\n\t * Transform angle to radians\n\t - deg (number) angle in degrees\n\t = (number) angle in radians\n\t\\*/\n\tSnap.rad = rad;\n\t/*\\\n\t * Snap.deg\n\t [ method ]\n\t **\n\t * Transform angle to degrees\n\t - rad (number) angle in radians\n\t = (number) angle in degrees\n\t\\*/\n\tSnap.deg = deg;\n\t/*\\\n\t * Snap.sin\n\t [ method ]\n\t **\n\t * Equivalent to `Math.sin()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) sin\n\t\\*/\n\tSnap.sin = function (angle) {\n\t    return math.sin(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.tan\n\t [ method ]\n\t **\n\t * Equivalent to `Math.tan()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) tan\n\t\\*/\n\tSnap.tan = function (angle) {\n\t    return math.tan(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.cos\n\t [ method ]\n\t **\n\t * Equivalent to `Math.cos()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) cos\n\t\\*/\n\tSnap.cos = function (angle) {\n\t    return math.cos(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.asin\n\t [ method ]\n\t **\n\t * Equivalent to `Math.asin()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) asin in degrees\n\t\\*/\n\tSnap.asin = function (num) {\n\t    return Snap.deg(math.asin(num));\n\t};\n\t/*\\\n\t * Snap.acos\n\t [ method ]\n\t **\n\t * Equivalent to `Math.acos()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) acos in degrees\n\t\\*/\n\tSnap.acos = function (num) {\n\t    return Snap.deg(math.acos(num));\n\t};\n\t/*\\\n\t * Snap.atan\n\t [ method ]\n\t **\n\t * Equivalent to `Math.atan()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) atan in degrees\n\t\\*/\n\tSnap.atan = function (num) {\n\t    return Snap.deg(math.atan(num));\n\t};\n\t/*\\\n\t * Snap.atan2\n\t [ method ]\n\t **\n\t * Equivalent to `Math.atan2()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) atan2 in degrees\n\t\\*/\n\tSnap.atan2 = function (num) {\n\t    return Snap.deg(math.atan2(num));\n\t};\n\t/*\\\n\t * Snap.angle\n\t [ method ]\n\t **\n\t * Returns an angle between two or three points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t - x3 (number) #optional x coord of third point\n\t - y3 (number) #optional y coord of third point\n\t = (number) angle in degrees\n\t\\*/\n\tSnap.angle = angle;\n\t/*\\\n\t * Snap.len\n\t [ method ]\n\t **\n\t * Returns distance between two points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t = (number) distance\n\t\\*/\n\tSnap.len = function (x1, y1, x2, y2) {\n\t    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n\t};\n\t/*\\\n\t * Snap.len2\n\t [ method ]\n\t **\n\t * Returns squared distance between two points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t = (number) distance\n\t\\*/\n\tSnap.len2 = function (x1, y1, x2, y2) {\n\t    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\t};\n\t/*\\\n\t * Snap.closestPoint\n\t [ method ]\n\t **\n\t * Returns closest point to a given one on a given path.\n\t > Parameters\n\t - path (Element) path element\n\t - x (number) x coord of a point\n\t - y (number) y coord of a point\n\t = (object) in format\n\t {\n\t    x (number) x coord of the point on the path\n\t    y (number) y coord of the point on the path\n\t    length (number) length of the path to the point\n\t    distance (number) distance from the given point to the path\n\t }\n\t\\*/\n\t// Copied from http://bl.ocks.org/mbostock/8027637\n\tSnap.closestPoint = function (path, x, y) {\n\t    function distance2(p) {\n\t        var dx = p.x - x,\n\t            dy = p.y - y;\n\t        return dx * dx + dy * dy;\n\t    }\n\t    var pathNode = path.node,\n\t        pathLength = pathNode.getTotalLength(),\n\t        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n\t        best,\n\t        bestLength,\n\t        bestDistance = Infinity;\n\t\n\t    // linear scan for coarse approximation\n\t    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n\t        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n\t            best = scan, bestLength = scanLength, bestDistance = scanDistance;\n\t        }\n\t    }\n\t\n\t    // binary search for precise estimate\n\t    precision *= .5;\n\t    while (precision > .5) {\n\t        var before,\n\t            after,\n\t            beforeLength,\n\t            afterLength,\n\t            beforeDistance,\n\t            afterDistance;\n\t        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n\t            best = before, bestLength = beforeLength, bestDistance = beforeDistance;\n\t        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n\t            best = after, bestLength = afterLength, bestDistance = afterDistance;\n\t        } else {\n\t            precision *= .5;\n\t        }\n\t    }\n\t\n\t    best = {\n\t        x: best.x,\n\t        y: best.y,\n\t        length: bestLength,\n\t        distance: Math.sqrt(bestDistance)\n\t    };\n\t    return best;\n\t}\n\t/*\\\n\t * Snap.is\n\t [ method ]\n\t **\n\t * Handy replacement for the `typeof` operator\n\t - o (…) any object or primitive\n\t - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n\t = (boolean) `true` if given value is of given type\n\t\\*/\n\tSnap.is = is;\n\t/*\\\n\t * Snap.snapTo\n\t [ method ]\n\t **\n\t * Snaps given value to given grid\n\t - values (array|number) given array of values or step of the grid\n\t - value (number) value to adjust\n\t - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n\t = (number) adjusted value\n\t\\*/\n\tSnap.snapTo = function (values, value, tolerance) {\n\t    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n\t    if (is(values, \"array\")) {\n\t        var i = values.length;\n\t        while (i--) if (abs(values[i] - value) <= tolerance) {\n\t            return values[i];\n\t        }\n\t    } else {\n\t        values = +values;\n\t        var rem = value % values;\n\t        if (rem < tolerance) {\n\t            return value - rem;\n\t        }\n\t        if (rem > values - tolerance) {\n\t            return value - rem + values;\n\t        }\n\t    }\n\t    return value;\n\t};\n\t// Colour\n\t/*\\\n\t * Snap.getRGB\n\t [ method ]\n\t **\n\t * Parses color string as RGB object\n\t - color (string) color string in one of the following formats:\n\t # <ul>\n\t #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n\t #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>\n\t #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>\n\t #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>\n\t #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n\t #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>\n\t #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n\t #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>\n\t #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n\t #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>\n\t # </ul>\n\t * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••,\n\t o     error (boolean) true if string can't be parsed\n\t o }\n\t\\*/\n\tSnap.getRGB = cacher(function (colour) {\n\t    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t    }\n\t    if (colour == \"none\") {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n\t    }\n\t    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n\t    if (!colour) {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t    }\n\t    var res,\n\t        red,\n\t        green,\n\t        blue,\n\t        opacity,\n\t        t,\n\t        values,\n\t        rgb = colour.match(colourRegExp);\n\t    if (rgb) {\n\t        if (rgb[2]) {\n\t            blue = toInt(rgb[2].substring(5), 16);\n\t            green = toInt(rgb[2].substring(3, 5), 16);\n\t            red = toInt(rgb[2].substring(1, 3), 16);\n\t        }\n\t        if (rgb[3]) {\n\t            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n\t            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n\t            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n\t        }\n\t        if (rgb[4]) {\n\t            values = rgb[4].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t        }\n\t        if (rgb[5]) {\n\t            values = rgb[5].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red /= 100);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green /= 100);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue /= 100);\n\t            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            return Snap.hsb2rgb(red, green, blue, opacity);\n\t        }\n\t        if (rgb[6]) {\n\t            values = rgb[6].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red /= 100);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green /= 100);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue /= 100);\n\t            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            return Snap.hsl2rgb(red, green, blue, opacity);\n\t        }\n\t        red = mmin(math.round(red), 255);\n\t        green = mmin(math.round(green), 255);\n\t        blue = mmin(math.round(blue), 255);\n\t        opacity = mmin(mmax(opacity, 0), 1);\n\t        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n\t        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n\t        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n\t        return rgb;\n\t    }\n\t    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t}, Snap);\n\t/*\\\n\t * Snap.hsb\n\t [ method ]\n\t **\n\t * Converts HSB values to a hex representation of the color\n\t - h (number) hue\n\t - s (number) saturation\n\t - b (number) value or brightness\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.hsb = cacher(function (h, s, b) {\n\t    return Snap.hsb2rgb(h, s, b).hex;\n\t});\n\t/*\\\n\t * Snap.hsl\n\t [ method ]\n\t **\n\t * Converts HSL values to a hex representation of the color\n\t - h (number) hue\n\t - s (number) saturation\n\t - l (number) luminosity\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.hsl = cacher(function (h, s, l) {\n\t    return Snap.hsl2rgb(h, s, l).hex;\n\t});\n\t/*\\\n\t * Snap.rgb\n\t [ method ]\n\t **\n\t * Converts RGB values to a hex representation of the color\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.rgb = cacher(function (r, g, b, o) {\n\t    if (is(o, \"finite\")) {\n\t        var round = math.round;\n\t        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n\t    }\n\t    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n\t});\n\tvar toHex = function (color) {\n\t    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n\t        red = \"rgb(255, 0, 0)\";\n\t    toHex = cacher(function (color) {\n\t        if (color.toLowerCase() == \"red\") {\n\t            return red;\n\t        }\n\t        i.style.color = red;\n\t        i.style.color = color;\n\t        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n\t        return out == red ? null : out;\n\t    });\n\t    return toHex(color);\n\t},\n\thsbtoString = function () {\n\t    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n\t},\n\thsltoString = function () {\n\t    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n\t},\n\trgbtoString = function () {\n\t    return this.opacity == 1 || this.opacity == null ?\n\t            this.hex :\n\t            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n\t},\n\tprepareRGB = function (r, g, b) {\n\t    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n\t        b = r.b;\n\t        g = r.g;\n\t        r = r.r;\n\t    }\n\t    if (g == null && is(r, string)) {\n\t        var clr = Snap.getRGB(r);\n\t        r = clr.r;\n\t        g = clr.g;\n\t        b = clr.b;\n\t    }\n\t    if (r > 1 || g > 1 || b > 1) {\n\t        r /= 255;\n\t        g /= 255;\n\t        b /= 255;\n\t    }\n\t\n\t    return [r, g, b];\n\t},\n\tpackageRGB = function (r, g, b, o) {\n\t    r = math.round(r * 255);\n\t    g = math.round(g * 255);\n\t    b = math.round(b * 255);\n\t    var rgb = {\n\t        r: r,\n\t        g: g,\n\t        b: b,\n\t        opacity: is(o, \"finite\") ? o : 1,\n\t        hex: Snap.rgb(r, g, b),\n\t        toString: rgbtoString\n\t    };\n\t    is(o, \"finite\") && (rgb.opacity = o);\n\t    return rgb;\n\t};\n\t/*\\\n\t * Snap.color\n\t [ method ]\n\t **\n\t * Parses the color string and returns an object featuring the color's component values\n\t - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n\t = (object) Combined RGB/HSB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••,\n\t o     error (boolean) `true` if string can't be parsed,\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     v (number) value (brightness),\n\t o     l (number) lightness\n\t o }\n\t\\*/\n\tSnap.color = function (clr) {\n\t    var rgb;\n\t    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n\t        rgb = Snap.hsb2rgb(clr);\n\t        clr.r = rgb.r;\n\t        clr.g = rgb.g;\n\t        clr.b = rgb.b;\n\t        clr.opacity = 1;\n\t        clr.hex = rgb.hex;\n\t    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n\t        rgb = Snap.hsl2rgb(clr);\n\t        clr.r = rgb.r;\n\t        clr.g = rgb.g;\n\t        clr.b = rgb.b;\n\t        clr.opacity = 1;\n\t        clr.hex = rgb.hex;\n\t    } else {\n\t        if (is(clr, \"string\")) {\n\t            clr = Snap.getRGB(clr);\n\t        }\n\t        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n\t            rgb = Snap.rgb2hsl(clr);\n\t            clr.h = rgb.h;\n\t            clr.s = rgb.s;\n\t            clr.l = rgb.l;\n\t            rgb = Snap.rgb2hsb(clr);\n\t            clr.v = rgb.b;\n\t        } else {\n\t            clr = {hex: \"none\"};\n\t            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n\t            clr.error = 1;\n\t        }\n\t    }\n\t    clr.toString = rgbtoString;\n\t    return clr;\n\t};\n\t/*\\\n\t * Snap.hsb2rgb\n\t [ method ]\n\t **\n\t * Converts HSB values to an RGB object\n\t - h (number) hue\n\t - s (number) saturation\n\t - v (number) value or brightness\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••\n\t o }\n\t\\*/\n\tSnap.hsb2rgb = function (h, s, v, o) {\n\t    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n\t        v = h.b;\n\t        s = h.s;\n\t        o = h.o;\n\t        h = h.h;\n\t    }\n\t    h *= 360;\n\t    var R, G, B, X, C;\n\t    h = (h % 360) / 60;\n\t    C = v * s;\n\t    X = C * (1 - abs(h % 2 - 1));\n\t    R = G = B = v - C;\n\t\n\t    h = ~~h;\n\t    R += [C, X, 0, 0, X, C][h];\n\t    G += [X, C, C, X, 0, 0][h];\n\t    B += [0, 0, X, C, C, X][h];\n\t    return packageRGB(R, G, B, o);\n\t};\n\t/*\\\n\t * Snap.hsl2rgb\n\t [ method ]\n\t **\n\t * Converts HSL values to an RGB object\n\t - h (number) hue\n\t - s (number) saturation\n\t - l (number) luminosity\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••\n\t o }\n\t\\*/\n\tSnap.hsl2rgb = function (h, s, l, o) {\n\t    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n\t        l = h.l;\n\t        s = h.s;\n\t        h = h.h;\n\t    }\n\t    if (h > 1 || s > 1 || l > 1) {\n\t        h /= 360;\n\t        s /= 100;\n\t        l /= 100;\n\t    }\n\t    h *= 360;\n\t    var R, G, B, X, C;\n\t    h = (h % 360) / 60;\n\t    C = 2 * s * (l < .5 ? l : 1 - l);\n\t    X = C * (1 - abs(h % 2 - 1));\n\t    R = G = B = l - C / 2;\n\t\n\t    h = ~~h;\n\t    R += [C, X, 0, 0, X, C][h];\n\t    G += [X, C, C, X, 0, 0][h];\n\t    B += [0, 0, X, C, C, X][h];\n\t    return packageRGB(R, G, B, o);\n\t};\n\t/*\\\n\t * Snap.rgb2hsb\n\t [ method ]\n\t **\n\t * Converts RGB values to an HSB object\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (object) HSB object in the following format:\n\t o {\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     b (number) brightness\n\t o }\n\t\\*/\n\tSnap.rgb2hsb = function (r, g, b) {\n\t    b = prepareRGB(r, g, b);\n\t    r = b[0];\n\t    g = b[1];\n\t    b = b[2];\n\t\n\t    var H, S, V, C;\n\t    V = mmax(r, g, b);\n\t    C = V - mmin(r, g, b);\n\t    H = (C == 0 ? null :\n\t         V == r ? (g - b) / C :\n\t         V == g ? (b - r) / C + 2 :\n\t                  (r - g) / C + 4\n\t        );\n\t    H = ((H + 360) % 6) * 60 / 360;\n\t    S = C == 0 ? 0 : C / V;\n\t    return {h: H, s: S, b: V, toString: hsbtoString};\n\t};\n\t/*\\\n\t * Snap.rgb2hsl\n\t [ method ]\n\t **\n\t * Converts RGB values to an HSL object\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (object) HSL object in the following format:\n\t o {\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     l (number) luminosity\n\t o }\n\t\\*/\n\tSnap.rgb2hsl = function (r, g, b) {\n\t    b = prepareRGB(r, g, b);\n\t    r = b[0];\n\t    g = b[1];\n\t    b = b[2];\n\t\n\t    var H, S, L, M, m, C;\n\t    M = mmax(r, g, b);\n\t    m = mmin(r, g, b);\n\t    C = M - m;\n\t    H = (C == 0 ? null :\n\t         M == r ? (g - b) / C :\n\t         M == g ? (b - r) / C + 2 :\n\t                  (r - g) / C + 4);\n\t    H = ((H + 360) % 6) * 60 / 360;\n\t    L = (M + m) / 2;\n\t    S = (C == 0 ? 0 :\n\t         L < .5 ? C / (2 * L) :\n\t                  C / (2 - 2 * L));\n\t    return {h: H, s: S, l: L, toString: hsltoString};\n\t};\n\t\n\t// Transformations\n\t/*\\\n\t * Snap.parsePathString\n\t [ method ]\n\t **\n\t * Utility method\n\t **\n\t * Parses given path string into an array of arrays of path segments\n\t - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n\t = (array) array of segments\n\t\\*/\n\tSnap.parsePathString = function (pathString) {\n\t    if (!pathString) {\n\t        return null;\n\t    }\n\t    var pth = Snap.path(pathString);\n\t    if (pth.arr) {\n\t        return Snap.path.clone(pth.arr);\n\t    }\n\t\n\t    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n\t        data = [];\n\t    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n\t        data = Snap.path.clone(pathString);\n\t    }\n\t    if (!data.length) {\n\t        Str(pathString).replace(pathCommand, function (a, b, c) {\n\t            var params = [],\n\t                name = b.toLowerCase();\n\t            c.replace(pathValues, function (a, b) {\n\t                b && params.push(+b);\n\t            });\n\t            if (name == \"m\" && params.length > 2) {\n\t                data.push([b].concat(params.splice(0, 2)));\n\t                name = \"l\";\n\t                b = b == \"m\" ? \"l\" : \"L\";\n\t            }\n\t            if (name == \"o\" && params.length == 1) {\n\t                data.push([b, params[0]]);\n\t            }\n\t            if (name == \"r\") {\n\t                data.push([b].concat(params));\n\t            } else while (params.length >= paramCounts[name]) {\n\t                data.push([b].concat(params.splice(0, paramCounts[name])));\n\t                if (!paramCounts[name]) {\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t    }\n\t    data.toString = Snap.path.toString;\n\t    pth.arr = Snap.path.clone(data);\n\t    return data;\n\t};\n\t/*\\\n\t * Snap.parseTransformString\n\t [ method ]\n\t **\n\t * Utility method\n\t **\n\t * Parses given transform string into an array of transformations\n\t - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n\t = (array) array of transformations\n\t\\*/\n\tvar parseTransformString = Snap.parseTransformString = function (TString) {\n\t    if (!TString) {\n\t        return null;\n\t    }\n\t    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n\t        data = [];\n\t    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n\t        data = Snap.path.clone(TString);\n\t    }\n\t    if (!data.length) {\n\t        Str(TString).replace(tCommand, function (a, b, c) {\n\t            var params = [],\n\t                name = b.toLowerCase();\n\t            c.replace(pathValues, function (a, b) {\n\t                b && params.push(+b);\n\t            });\n\t            data.push([b].concat(params));\n\t        });\n\t    }\n\t    data.toString = Snap.path.toString;\n\t    return data;\n\t};\n\tfunction svgTransform2string(tstr) {\n\t    var res = [];\n\t    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n\t        params = params.split(/\\s*,\\s*|\\s+/);\n\t        if (name == \"rotate\" && params.length == 1) {\n\t            params.push(0, 0);\n\t        }\n\t        if (name == \"scale\") {\n\t            if (params.length > 2) {\n\t                params = params.slice(0, 2);\n\t            } else if (params.length == 2) {\n\t                params.push(0, 0);\n\t            }\n\t            if (params.length == 1) {\n\t                params.push(params[0], 0, 0);\n\t            }\n\t        }\n\t        if (name == \"skewX\") {\n\t            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n\t        } else if (name == \"skewY\") {\n\t            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n\t        } else {\n\t            res.push([name.charAt(0)].concat(params));\n\t        }\n\t        return all;\n\t    });\n\t    return res;\n\t}\n\tSnap._.svgTransform2string = svgTransform2string;\n\tSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\n\tfunction transform2matrix(tstr, bbox) {\n\t    var tdata = parseTransformString(tstr),\n\t        m = new Snap.Matrix;\n\t    if (tdata) {\n\t        for (var i = 0, ii = tdata.length; i < ii; i++) {\n\t            var t = tdata[i],\n\t                tlen = t.length,\n\t                command = Str(t[0]).toLowerCase(),\n\t                absolute = t[0] != command,\n\t                inver = absolute ? m.invert() : 0,\n\t                x1,\n\t                y1,\n\t                x2,\n\t                y2,\n\t                bb;\n\t            if (command == \"t\" && tlen == 2){\n\t                m.translate(t[1], 0);\n\t            } else if (command == \"t\" && tlen == 3) {\n\t                if (absolute) {\n\t                    x1 = inver.x(0, 0);\n\t                    y1 = inver.y(0, 0);\n\t                    x2 = inver.x(t[1], t[2]);\n\t                    y2 = inver.y(t[1], t[2]);\n\t                    m.translate(x2 - x1, y2 - y1);\n\t                } else {\n\t                    m.translate(t[1], t[2]);\n\t                }\n\t            } else if (command == \"r\") {\n\t                if (tlen == 2) {\n\t                    bb = bb || bbox;\n\t                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                } else if (tlen == 4) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[2], t[3]);\n\t                        y2 = inver.y(t[2], t[3]);\n\t                        m.rotate(t[1], x2, y2);\n\t                    } else {\n\t                        m.rotate(t[1], t[2], t[3]);\n\t                    }\n\t                }\n\t            } else if (command == \"s\") {\n\t                if (tlen == 2 || tlen == 3) {\n\t                    bb = bb || bbox;\n\t                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                } else if (tlen == 4) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[2], t[3]);\n\t                        y2 = inver.y(t[2], t[3]);\n\t                        m.scale(t[1], t[1], x2, y2);\n\t                    } else {\n\t                        m.scale(t[1], t[1], t[2], t[3]);\n\t                    }\n\t                } else if (tlen == 5) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[3], t[4]);\n\t                        y2 = inver.y(t[3], t[4]);\n\t                        m.scale(t[1], t[2], x2, y2);\n\t                    } else {\n\t                        m.scale(t[1], t[2], t[3], t[4]);\n\t                    }\n\t                }\n\t            } else if (command == \"m\" && tlen == 7) {\n\t                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n\t            }\n\t        }\n\t    }\n\t    return m;\n\t}\n\tSnap._.transform2matrix = transform2matrix;\n\tSnap._unit2px = unit2px;\n\tvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n\t    function (a, b) {\n\t        var adown = a.nodeType == 9 ? a.documentElement : a,\n\t            bup = b && b.parentNode;\n\t            return a == bup || !!(bup && bup.nodeType == 1 && (\n\t                adown.contains ?\n\t                    adown.contains(bup) :\n\t                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n\t            ));\n\t    } :\n\t    function (a, b) {\n\t        if (b) {\n\t            while (b) {\n\t                b = b.parentNode;\n\t                if (b == a) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\tfunction getSomeDefs(el) {\n\t    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n\t            (el.node.parentNode && wrap(el.node.parentNode)) ||\n\t            Snap.select(\"svg\") ||\n\t            Snap(0, 0),\n\t        pdefs = p.select(\"defs\"),\n\t        defs  = pdefs == null ? false : pdefs.node;\n\t    if (!defs) {\n\t        defs = make(\"defs\", p.node).node;\n\t    }\n\t    return defs;\n\t}\n\tfunction getSomeSVG(el) {\n\t    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n\t}\n\tSnap._.getSomeDefs = getSomeDefs;\n\tSnap._.getSomeSVG = getSomeSVG;\n\tfunction unit2px(el, name, value) {\n\t    var svg = getSomeSVG(el).node,\n\t        out = {},\n\t        mgr = svg.querySelector(\".svg---mgr\");\n\t    if (!mgr) {\n\t        mgr = $(\"rect\");\n\t        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n\t        svg.appendChild(mgr);\n\t    }\n\t    function getW(val) {\n\t        if (val == null) {\n\t            return E;\n\t        }\n\t        if (val == +val) {\n\t            return val;\n\t        }\n\t        $(mgr, {width: val});\n\t        try {\n\t            return mgr.getBBox().width;\n\t        } catch (e) {\n\t            return 0;\n\t        }\n\t    }\n\t    function getH(val) {\n\t        if (val == null) {\n\t            return E;\n\t        }\n\t        if (val == +val) {\n\t            return val;\n\t        }\n\t        $(mgr, {height: val});\n\t        try {\n\t            return mgr.getBBox().height;\n\t        } catch (e) {\n\t            return 0;\n\t        }\n\t    }\n\t    function set(nam, f) {\n\t        if (name == null) {\n\t            out[nam] = f(el.attr(nam) || 0);\n\t        } else if (nam == name) {\n\t            out = f(value == null ? el.attr(nam) || 0 : value);\n\t        }\n\t    }\n\t    switch (el.type) {\n\t        case \"rect\":\n\t            set(\"rx\", getW);\n\t            set(\"ry\", getH);\n\t        case \"image\":\n\t            set(\"width\", getW);\n\t            set(\"height\", getH);\n\t        case \"text\":\n\t            set(\"x\", getW);\n\t            set(\"y\", getH);\n\t        break;\n\t        case \"circle\":\n\t            set(\"cx\", getW);\n\t            set(\"cy\", getH);\n\t            set(\"r\", getW);\n\t        break;\n\t        case \"ellipse\":\n\t            set(\"cx\", getW);\n\t            set(\"cy\", getH);\n\t            set(\"rx\", getW);\n\t            set(\"ry\", getH);\n\t        break;\n\t        case \"line\":\n\t            set(\"x1\", getW);\n\t            set(\"x2\", getW);\n\t            set(\"y1\", getH);\n\t            set(\"y2\", getH);\n\t        break;\n\t        case \"marker\":\n\t            set(\"refX\", getW);\n\t            set(\"markerWidth\", getW);\n\t            set(\"refY\", getH);\n\t            set(\"markerHeight\", getH);\n\t        break;\n\t        case \"radialGradient\":\n\t            set(\"fx\", getW);\n\t            set(\"fy\", getH);\n\t        break;\n\t        case \"tspan\":\n\t            set(\"dx\", getW);\n\t            set(\"dy\", getH);\n\t        break;\n\t        default:\n\t            set(name, getW);\n\t    }\n\t    svg.removeChild(mgr);\n\t    return out;\n\t}\n\t/*\\\n\t * Snap.select\n\t [ method ]\n\t **\n\t * Wraps a DOM element specified by CSS selector as @Element\n\t - query (string) CSS selector of the element\n\t = (Element) the current element\n\t\\*/\n\tSnap.select = function (query) {\n\t    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n\t    return wrap(glob.doc.querySelector(query));\n\t};\n\t/*\\\n\t * Snap.selectAll\n\t [ method ]\n\t **\n\t * Wraps DOM elements specified by CSS selector as set or array of @Element\n\t - query (string) CSS selector of the element\n\t = (Element) the current element\n\t\\*/\n\tSnap.selectAll = function (query) {\n\t    var nodelist = glob.doc.querySelectorAll(query),\n\t        set = (Snap.set || Array)();\n\t    for (var i = 0; i < nodelist.length; i++) {\n\t        set.push(wrap(nodelist[i]));\n\t    }\n\t    return set;\n\t};\n\t\n\tfunction add2group(list) {\n\t    if (!is(list, \"array\")) {\n\t        list = Array.prototype.slice.call(arguments, 0);\n\t    }\n\t    var i = 0,\n\t        j = 0,\n\t        node = this.node;\n\t    while (this[i]) delete this[i++];\n\t    for (i = 0; i < list.length; i++) {\n\t        if (list[i].type == \"set\") {\n\t            list[i].forEach(function (el) {\n\t                node.appendChild(el.node);\n\t            });\n\t        } else {\n\t            node.appendChild(list[i].node);\n\t        }\n\t    }\n\t    var children = node.childNodes;\n\t    for (i = 0; i < children.length; i++) {\n\t        this[j++] = wrap(children[i]);\n\t    }\n\t    return this;\n\t}\n\t// Hub garbage collector every 10s\n\tsetInterval(function () {\n\t    for (var key in hub) if (hub[has](key)) {\n\t        var el = hub[key],\n\t            node = el.node;\n\t        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n\t            delete hub[key];\n\t        }\n\t    }\n\t}, 1e4);\n\tfunction Element(el) {\n\t    if (el.snap in hub) {\n\t        return hub[el.snap];\n\t    }\n\t    var svg;\n\t    try {\n\t        svg = el.ownerSVGElement;\n\t    } catch(e) {}\n\t    /*\\\n\t     * Element.node\n\t     [ property (object) ]\n\t     **\n\t     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n\t     > Usage\n\t     | // draw a circle at coordinate 10,10 with radius of 10\n\t     | var c = paper.circle(10, 10, 10);\n\t     | c.node.onclick = function () {\n\t     |     c.attr(\"fill\", \"red\");\n\t     | };\n\t    \\*/\n\t    this.node = el;\n\t    if (svg) {\n\t        this.paper = new Paper(svg);\n\t    }\n\t    /*\\\n\t     * Element.type\n\t     [ property (string) ]\n\t     **\n\t     * SVG tag name of the given element.\n\t    \\*/\n\t    this.type = el.tagName || el.nodeName;\n\t    var id = this.id = ID(this);\n\t    this.anims = {};\n\t    this._ = {\n\t        transform: []\n\t    };\n\t    el.snap = id;\n\t    hub[id] = this;\n\t    if (this.type == \"g\") {\n\t        this.add = add2group;\n\t    }\n\t    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n\t        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n\t            this[method] = Paper.prototype[method];\n\t        }\n\t    }\n\t}\n\t   /*\\\n\t     * Element.attr\n\t     [ method ]\n\t     **\n\t     * Gets or sets given attributes of the element.\n\t     **\n\t     - params (object) contains key-value pairs of attributes you want to set\n\t     * or\n\t     - param (string) name of the attribute\n\t     = (Element) the current element\n\t     * or\n\t     = (string) value of attribute\n\t     > Usage\n\t     | el.attr({\n\t     |     fill: \"#fc0\",\n\t     |     stroke: \"#000\",\n\t     |     strokeWidth: 2, // CamelCase...\n\t     |     \"fill-opacity\": 0.5, // or dash-separated names\n\t     |     width: \"*=2\" // prefixed values\n\t     | });\n\t     | console.log(el.attr(\"fill\")); // #fc0\n\t     * Prefixed values in format `\"+=10\"` supported. All four operations\n\t     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n\t     * and `-`: `\"+=2em\"`.\n\t    \\*/\n\t    Element.prototype.attr = function (params, value) {\n\t        var el = this,\n\t            node = el.node;\n\t        if (!params) {\n\t            if (node.nodeType != 1) {\n\t                return {\n\t                    text: node.nodeValue\n\t                };\n\t            }\n\t            var attr = node.attributes,\n\t                out = {};\n\t            for (var i = 0, ii = attr.length; i < ii; i++) {\n\t                out[attr[i].nodeName] = attr[i].nodeValue;\n\t            }\n\t            return out;\n\t        }\n\t        if (is(params, \"string\")) {\n\t            if (arguments.length > 1) {\n\t                var json = {};\n\t                json[params] = value;\n\t                params = json;\n\t            } else {\n\t                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n\t            }\n\t        }\n\t        for (var att in params) {\n\t            if (params[has](att)) {\n\t                eve(\"snap.util.attr.\" + att, el, params[att]);\n\t            }\n\t        }\n\t        return el;\n\t    };\n\t/*\\\n\t * Snap.parse\n\t [ method ]\n\t **\n\t * Parses SVG fragment and converts it into a @Fragment\n\t **\n\t - svg (string) SVG string\n\t = (Fragment) the @Fragment\n\t\\*/\n\tSnap.parse = function (svg) {\n\t    var f = glob.doc.createDocumentFragment(),\n\t        full = true,\n\t        div = glob.doc.createElement(\"div\");\n\t    svg = Str(svg);\n\t    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n\t        svg = \"<svg>\" + svg + \"</svg>\";\n\t        full = false;\n\t    }\n\t    div.innerHTML = svg;\n\t    svg = div.getElementsByTagName(\"svg\")[0];\n\t    if (svg) {\n\t        if (full) {\n\t            f = svg;\n\t        } else {\n\t            while (svg.firstChild) {\n\t                f.appendChild(svg.firstChild);\n\t            }\n\t        }\n\t    }\n\t    return new Fragment(f);\n\t};\n\tfunction Fragment(frag) {\n\t    this.node = frag;\n\t}\n\t/*\\\n\t * Snap.fragment\n\t [ method ]\n\t **\n\t * Creates a DOM fragment from a given list of elements or strings\n\t **\n\t - varargs (…) SVG string\n\t = (Fragment) the @Fragment\n\t\\*/\n\tSnap.fragment = function () {\n\t    var args = Array.prototype.slice.call(arguments, 0),\n\t        f = glob.doc.createDocumentFragment();\n\t    for (var i = 0, ii = args.length; i < ii; i++) {\n\t        var item = args[i];\n\t        if (item.node && item.node.nodeType) {\n\t            f.appendChild(item.node);\n\t        }\n\t        if (item.nodeType) {\n\t            f.appendChild(item);\n\t        }\n\t        if (typeof item == \"string\") {\n\t            f.appendChild(Snap.parse(item).node);\n\t        }\n\t    }\n\t    return new Fragment(f);\n\t};\n\t\n\tfunction make(name, parent) {\n\t    var res = $(name);\n\t    parent.appendChild(res);\n\t    var el = wrap(res);\n\t    return el;\n\t}\n\tfunction Paper(w, h) {\n\t    var res,\n\t        desc,\n\t        defs,\n\t        proto = Paper.prototype;\n\t    if (w && w.tagName == \"svg\") {\n\t        if (w.snap in hub) {\n\t            return hub[w.snap];\n\t        }\n\t        var doc = w.ownerDocument;\n\t        res = new Element(w);\n\t        desc = w.getElementsByTagName(\"desc\")[0];\n\t        defs = w.getElementsByTagName(\"defs\")[0];\n\t        if (!desc) {\n\t            desc = $(\"desc\");\n\t            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n\t            res.node.appendChild(desc);\n\t        }\n\t        if (!defs) {\n\t            defs = $(\"defs\");\n\t            res.node.appendChild(defs);\n\t        }\n\t        res.defs = defs;\n\t        for (var key in proto) if (proto[has](key)) {\n\t            res[key] = proto[key];\n\t        }\n\t        res.paper = res.root = res;\n\t    } else {\n\t        res = make(\"svg\", glob.doc.body);\n\t        $(res.node, {\n\t            height: h,\n\t            version: 1.1,\n\t            width: w,\n\t            xmlns: xmlns\n\t        });\n\t    }\n\t    return res;\n\t}\n\tfunction wrap(dom) {\n\t    if (!dom) {\n\t        return dom;\n\t    }\n\t    if (dom instanceof Element || dom instanceof Fragment) {\n\t        return dom;\n\t    }\n\t    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n\t        return new Paper(dom);\n\t    }\n\t    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n\t        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n\t    }\n\t    return new Element(dom);\n\t}\n\t\n\tSnap._.make = make;\n\tSnap._.wrap = wrap;\n\t/*\\\n\t * Paper.el\n\t [ method ]\n\t **\n\t * Creates an element on paper with a given name and no attributes\n\t **\n\t - name (string) tag name\n\t - attr (object) attributes\n\t = (Element) the current element\n\t > Usage\n\t | var c = paper.circle(10, 10, 10); // is the same as...\n\t | var c = paper.el(\"circle\").attr({\n\t |     cx: 10,\n\t |     cy: 10,\n\t |     r: 10\n\t | });\n\t | // and the same as\n\t | var c = paper.el(\"circle\", {\n\t |     cx: 10,\n\t |     cy: 10,\n\t |     r: 10\n\t | });\n\t\\*/\n\tPaper.prototype.el = function (name, attr) {\n\t    var el = make(name, this.node);\n\t    attr && el.attr(attr);\n\t    return el;\n\t};\n\t/*\\\n\t * Element.children\n\t [ method ]\n\t **\n\t * Returns array of all the children of the element.\n\t = (array) array of Elements\n\t\\*/\n\tElement.prototype.children = function () {\n\t    var out = [],\n\t        ch = this.node.childNodes;\n\t    for (var i = 0, ii = ch.length; i < ii; i++) {\n\t        out[i] = Snap(ch[i]);\n\t    }\n\t    return out;\n\t};\n\tfunction jsonFiller(root, o) {\n\t    for (var i = 0, ii = root.length; i < ii; i++) {\n\t        var item = {\n\t                type: root[i].type,\n\t                attr: root[i].attr()\n\t            },\n\t            children = root[i].children();\n\t        o.push(item);\n\t        if (children.length) {\n\t            jsonFiller(children, item.childNodes = []);\n\t        }\n\t    }\n\t}\n\t/*\\\n\t * Element.toJSON\n\t [ method ]\n\t **\n\t * Returns object representation of the given element and all its children.\n\t = (object) in format\n\t o {\n\t o     type (string) this.type,\n\t o     attr (object) attributes map,\n\t o     childNodes (array) optional array of children in the same format\n\t o }\n\t\\*/\n\tElement.prototype.toJSON = function () {\n\t    var out = [];\n\t    jsonFiller([this], out);\n\t    return out[0];\n\t};\n\t// default\n\teve.on(\"snap.util.getattr\", function () {\n\t    var att = eve.nt();\n\t    att = att.substring(att.lastIndexOf(\".\") + 1);\n\t    var css = att.replace(/[A-Z]/g, function (letter) {\n\t        return \"-\" + letter.toLowerCase();\n\t    });\n\t    if (cssAttr[has](css)) {\n\t        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n\t    } else {\n\t        return $(this.node, att);\n\t    }\n\t});\n\tvar cssAttr = {\n\t    \"alignment-baseline\": 0,\n\t    \"baseline-shift\": 0,\n\t    \"clip\": 0,\n\t    \"clip-path\": 0,\n\t    \"clip-rule\": 0,\n\t    \"color\": 0,\n\t    \"color-interpolation\": 0,\n\t    \"color-interpolation-filters\": 0,\n\t    \"color-profile\": 0,\n\t    \"color-rendering\": 0,\n\t    \"cursor\": 0,\n\t    \"direction\": 0,\n\t    \"display\": 0,\n\t    \"dominant-baseline\": 0,\n\t    \"enable-background\": 0,\n\t    \"fill\": 0,\n\t    \"fill-opacity\": 0,\n\t    \"fill-rule\": 0,\n\t    \"filter\": 0,\n\t    \"flood-color\": 0,\n\t    \"flood-opacity\": 0,\n\t    \"font\": 0,\n\t    \"font-family\": 0,\n\t    \"font-size\": 0,\n\t    \"font-size-adjust\": 0,\n\t    \"font-stretch\": 0,\n\t    \"font-style\": 0,\n\t    \"font-variant\": 0,\n\t    \"font-weight\": 0,\n\t    \"glyph-orientation-horizontal\": 0,\n\t    \"glyph-orientation-vertical\": 0,\n\t    \"image-rendering\": 0,\n\t    \"kerning\": 0,\n\t    \"letter-spacing\": 0,\n\t    \"lighting-color\": 0,\n\t    \"marker\": 0,\n\t    \"marker-end\": 0,\n\t    \"marker-mid\": 0,\n\t    \"marker-start\": 0,\n\t    \"mask\": 0,\n\t    \"opacity\": 0,\n\t    \"overflow\": 0,\n\t    \"pointer-events\": 0,\n\t    \"shape-rendering\": 0,\n\t    \"stop-color\": 0,\n\t    \"stop-opacity\": 0,\n\t    \"stroke\": 0,\n\t    \"stroke-dasharray\": 0,\n\t    \"stroke-dashoffset\": 0,\n\t    \"stroke-linecap\": 0,\n\t    \"stroke-linejoin\": 0,\n\t    \"stroke-miterlimit\": 0,\n\t    \"stroke-opacity\": 0,\n\t    \"stroke-width\": 0,\n\t    \"text-anchor\": 0,\n\t    \"text-decoration\": 0,\n\t    \"text-rendering\": 0,\n\t    \"unicode-bidi\": 0,\n\t    \"visibility\": 0,\n\t    \"word-spacing\": 0,\n\t    \"writing-mode\": 0\n\t};\n\t\n\teve.on(\"snap.util.attr\", function (value) {\n\t    var att = eve.nt(),\n\t        attr = {};\n\t    att = att.substring(att.lastIndexOf(\".\") + 1);\n\t    attr[att] = value;\n\t    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n\t            return letter.toUpperCase();\n\t        }),\n\t        css = att.replace(/[A-Z]/g, function (letter) {\n\t            return \"-\" + letter.toLowerCase();\n\t        });\n\t    if (cssAttr[has](css)) {\n\t        this.node.style[style] = value == null ? E : value;\n\t    } else {\n\t        $(this.node, attr);\n\t    }\n\t});\n\t(function (proto) {}(Paper.prototype));\n\t\n\t// simple ajax\n\t/*\\\n\t * Snap.ajax\n\t [ method ]\n\t **\n\t * Simple implementation of Ajax\n\t **\n\t - url (string) URL\n\t - postData (object|string) data for post request\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t * or\n\t - url (string) URL\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\t\\*/\n\tSnap.ajax = function (url, postData, callback, scope){\n\t    var req = new XMLHttpRequest,\n\t        id = ID();\n\t    if (req) {\n\t        if (is(postData, \"function\")) {\n\t            scope = callback;\n\t            callback = postData;\n\t            postData = null;\n\t        } else if (is(postData, \"object\")) {\n\t            var pd = [];\n\t            for (var key in postData) if (postData.hasOwnProperty(key)) {\n\t                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n\t            }\n\t            postData = pd.join(\"&\");\n\t        }\n\t        req.open((postData ? \"POST\" : \"GET\"), url, true);\n\t        if (postData) {\n\t            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n\t        }\n\t        if (callback) {\n\t            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n\t            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n\t            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n\t        }\n\t        req.onreadystatechange = function() {\n\t            if (req.readyState != 4) return;\n\t            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n\t        };\n\t        if (req.readyState == 4) {\n\t            return req;\n\t        }\n\t        req.send(postData);\n\t        return req;\n\t    }\n\t};\n\t/*\\\n\t * Snap.load\n\t [ method ]\n\t **\n\t * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n\t **\n\t - url (string) URL\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t\\*/\n\tSnap.load = function (url, callback, scope) {\n\t    Snap.ajax(url, function (req) {\n\t        var f = Snap.parse(req.responseText);\n\t        scope ? callback.call(scope, f) : callback(f);\n\t    });\n\t};\n\tvar getOffset = function (elem) {\n\t    var box = elem.getBoundingClientRect(),\n\t        doc = elem.ownerDocument,\n\t        body = doc.body,\n\t        docElem = doc.documentElement,\n\t        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n\t        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t    return {\n\t        y: top,\n\t        x: left\n\t    };\n\t};\n\t/*\\\n\t * Snap.getElementByPoint\n\t [ method ]\n\t **\n\t * Returns you topmost element under given point.\n\t **\n\t = (object) Snap element object\n\t - x (number) x coordinate from the top left corner of the window\n\t - y (number) y coordinate from the top left corner of the window\n\t > Usage\n\t | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\t\\*/\n\tSnap.getElementByPoint = function (x, y) {\n\t    var paper = this,\n\t        svg = paper.canvas,\n\t        target = glob.doc.elementFromPoint(x, y);\n\t    if (glob.win.opera && target.tagName == \"svg\") {\n\t        var so = getOffset(target),\n\t            sr = target.createSVGRect();\n\t        sr.x = x - so.x;\n\t        sr.y = y - so.y;\n\t        sr.width = sr.height = 1;\n\t        var hits = target.getIntersectionList(sr, null);\n\t        if (hits.length) {\n\t            target = hits[hits.length - 1];\n\t        }\n\t    }\n\t    if (!target) {\n\t        return null;\n\t    }\n\t    return wrap(target);\n\t};\n\t/*\\\n\t * Snap.plugin\n\t [ method ]\n\t **\n\t * Let you write plugins. You pass in a function with five arguments, like this:\n\t | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n\t |     Snap.newmethod = function () {};\n\t |     Element.prototype.newmethod = function () {};\n\t |     Paper.prototype.newmethod = function () {};\n\t | });\n\t * Inside the function you have access to all main objects (and their\n\t * prototypes). This allow you to extend anything you want.\n\t **\n\t - f (function) your plugin body\n\t\\*/\n\tSnap.plugin = function (f) {\n\t    f(Snap, Element, Paper, glob, Fragment);\n\t};\n\tglob.win.Snap = Snap;\n\treturn Snap;\n\t}(window || this));\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var elproto = Element.prototype,\n\t        is = Snap.is,\n\t        Str = String,\n\t        unit2px = Snap._unit2px,\n\t        $ = Snap._.$,\n\t        make = Snap._.make,\n\t        getSomeDefs = Snap._.getSomeDefs,\n\t        has = \"hasOwnProperty\",\n\t        wrap = Snap._.wrap;\n\t    /*\\\n\t     * Element.getBBox\n\t     [ method ]\n\t     **\n\t     * Returns the bounding box descriptor for the given element\n\t     **\n\t     = (object) bounding box descriptor:\n\t     o {\n\t     o     cx: (number) x of the center,\n\t     o     cy: (number) x of the center,\n\t     o     h: (number) height,\n\t     o     height: (number) height,\n\t     o     path: (string) path command for the box,\n\t     o     r0: (number) radius of a circle that fully encloses the box,\n\t     o     r1: (number) radius of the smallest circle that can be enclosed,\n\t     o     r2: (number) radius of the largest circle that can be enclosed,\n\t     o     vb: (string) box as a viewbox command,\n\t     o     w: (number) width,\n\t     o     width: (number) width,\n\t     o     x2: (number) x of the right side,\n\t     o     x: (number) x of the left side,\n\t     o     y2: (number) y of the bottom edge,\n\t     o     y: (number) y of the top edge\n\t     o }\n\t    \\*/\n\t    elproto.getBBox = function (isWithoutTransform) {\n\t        if (!Snap.Matrix || !Snap.path) {\n\t            return this.node.getBBox();\n\t        }\n\t        var el = this,\n\t            m = new Snap.Matrix;\n\t        if (el.removed) {\n\t            return Snap._.box();\n\t        }\n\t        while (el.type == \"use\") {\n\t            if (!isWithoutTransform) {\n\t                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n\t            }\n\t            if (el.original) {\n\t                el = el.original;\n\t            } else {\n\t                var href = el.attr(\"xlink:href\");\n\t                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n\t            }\n\t        }\n\t        var _ = el._,\n\t            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n\t        try {\n\t            if (isWithoutTransform) {\n\t                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n\t                return Snap._.box(_.bboxwt);\n\t            } else {\n\t                el.realPath = pathfinder(el);\n\t                el.matrix = el.transform().localMatrix;\n\t                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n\t                return Snap._.box(_.bbox);\n\t            }\n\t        } catch (e) {\n\t            // Firefox doesn’t give you bbox of hidden element\n\t            return Snap._.box();\n\t        }\n\t    };\n\t    var propString = function () {\n\t        return this.string;\n\t    };\n\t    function extractTransform(el, tstr) {\n\t        if (tstr == null) {\n\t            var doReturn = true;\n\t            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n\t                tstr = el.node.getAttribute(\"gradientTransform\");\n\t            } else if (el.type == \"pattern\") {\n\t                tstr = el.node.getAttribute(\"patternTransform\");\n\t            } else {\n\t                tstr = el.node.getAttribute(\"transform\");\n\t            }\n\t            if (!tstr) {\n\t                return new Snap.Matrix;\n\t            }\n\t            tstr = Snap._.svgTransform2string(tstr);\n\t        } else {\n\t            if (!Snap._.rgTransform.test(tstr)) {\n\t                tstr = Snap._.svgTransform2string(tstr);\n\t            } else {\n\t                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n\t            }\n\t            if (is(tstr, \"array\")) {\n\t                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n\t            }\n\t            el._.transform = tstr;\n\t        }\n\t        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n\t        if (doReturn) {\n\t            return m;\n\t        } else {\n\t            el.matrix = m;\n\t        }\n\t    }\n\t    /*\\\n\t     * Element.transform\n\t     [ method ]\n\t     **\n\t     * Gets or sets transformation of the element\n\t     **\n\t     - tstr (string) transform string in Snap or SVG format\n\t     = (Element) the current element\n\t     * or\n\t     = (object) transformation descriptor:\n\t     o {\n\t     o     string (string) transform string,\n\t     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n\t     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n\t     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n\t     o     global (string) global transformation as string,\n\t     o     local (string) local transformation as string,\n\t     o     toString (function) returns `string` property\n\t     o }\n\t    \\*/\n\t    elproto.transform = function (tstr) {\n\t        var _ = this._;\n\t        if (tstr == null) {\n\t            var papa = this,\n\t                global = new Snap.Matrix(this.node.getCTM()),\n\t                local = extractTransform(this),\n\t                ms = [local],\n\t                m = new Snap.Matrix,\n\t                i,\n\t                localString = local.toTransformString(),\n\t                string = Str(local) == Str(this.matrix) ?\n\t                            Str(_.transform) : localString;\n\t            while (papa.type != \"svg\" && (papa = papa.parent())) {\n\t                ms.push(extractTransform(papa));\n\t            }\n\t            i = ms.length;\n\t            while (i--) {\n\t                m.add(ms[i]);\n\t            }\n\t            return {\n\t                string: string,\n\t                globalMatrix: global,\n\t                totalMatrix: m,\n\t                localMatrix: local,\n\t                diffMatrix: global.clone().add(local.invert()),\n\t                global: global.toTransformString(),\n\t                total: m.toTransformString(),\n\t                local: localString,\n\t                toString: propString\n\t            };\n\t        }\n\t        if (tstr instanceof Snap.Matrix) {\n\t            this.matrix = tstr;\n\t            this._.transform = tstr.toTransformString();\n\t        } else {\n\t            extractTransform(this, tstr);\n\t        }\n\t\n\t        if (this.node) {\n\t            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n\t                $(this.node, {gradientTransform: this.matrix});\n\t            } else if (this.type == \"pattern\") {\n\t                $(this.node, {patternTransform: this.matrix});\n\t            } else {\n\t                $(this.node, {transform: this.matrix});\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.parent\n\t     [ method ]\n\t     **\n\t     * Returns the element's parent\n\t     **\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.parent = function () {\n\t        return wrap(this.node.parentNode);\n\t    };\n\t    /*\\\n\t     * Element.append\n\t     [ method ]\n\t     **\n\t     * Appends the given element to current one\n\t     **\n\t     - el (Element|Set) element to append\n\t     = (Element) the parent element\n\t    \\*/\n\t    /*\\\n\t     * Element.add\n\t     [ method ]\n\t     **\n\t     * See @Element.append\n\t    \\*/\n\t    elproto.append = elproto.add = function (el) {\n\t        if (el) {\n\t            if (el.type == \"set\") {\n\t                var it = this;\n\t                el.forEach(function (el) {\n\t                    it.add(el);\n\t                });\n\t                return this;\n\t            }\n\t            el = wrap(el);\n\t            this.node.appendChild(el.node);\n\t            el.paper = this.paper;\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.appendTo\n\t     [ method ]\n\t     **\n\t     * Appends the current element to the given one\n\t     **\n\t     - el (Element) parent element to append to\n\t     = (Element) the child element\n\t    \\*/\n\t    elproto.appendTo = function (el) {\n\t        if (el) {\n\t            el = wrap(el);\n\t            el.append(this);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.prepend\n\t     [ method ]\n\t     **\n\t     * Prepends the given element to the current one\n\t     **\n\t     - el (Element) element to prepend\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.prepend = function (el) {\n\t        if (el) {\n\t            if (el.type == \"set\") {\n\t                var it = this,\n\t                    first;\n\t                el.forEach(function (el) {\n\t                    if (first) {\n\t                        first.after(el);\n\t                    } else {\n\t                        it.prepend(el);\n\t                    }\n\t                    first = el;\n\t                });\n\t                return this;\n\t            }\n\t            el = wrap(el);\n\t            var parent = el.parent();\n\t            this.node.insertBefore(el.node, this.node.firstChild);\n\t            this.add && this.add();\n\t            el.paper = this.paper;\n\t            this.parent() && this.parent().add();\n\t            parent && parent.add();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.prependTo\n\t     [ method ]\n\t     **\n\t     * Prepends the current element to the given one\n\t     **\n\t     - el (Element) parent element to prepend to\n\t     = (Element) the child element\n\t    \\*/\n\t    elproto.prependTo = function (el) {\n\t        el = wrap(el);\n\t        el.prepend(this);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.before\n\t     [ method ]\n\t     **\n\t     * Inserts given element before the current one\n\t     **\n\t     - el (Element) element to insert\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.before = function (el) {\n\t        if (el.type == \"set\") {\n\t            var it = this;\n\t            el.forEach(function (el) {\n\t                var parent = el.parent();\n\t                it.node.parentNode.insertBefore(el.node, it.node);\n\t                parent && parent.add();\n\t            });\n\t            this.parent().add();\n\t            return this;\n\t        }\n\t        el = wrap(el);\n\t        var parent = el.parent();\n\t        this.node.parentNode.insertBefore(el.node, this.node);\n\t        this.parent() && this.parent().add();\n\t        parent && parent.add();\n\t        el.paper = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.after\n\t     [ method ]\n\t     **\n\t     * Inserts given element after the current one\n\t     **\n\t     - el (Element) element to insert\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.after = function (el) {\n\t        el = wrap(el);\n\t        var parent = el.parent();\n\t        if (this.node.nextSibling) {\n\t            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n\t        } else {\n\t            this.node.parentNode.appendChild(el.node);\n\t        }\n\t        this.parent() && this.parent().add();\n\t        parent && parent.add();\n\t        el.paper = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertBefore\n\t     [ method ]\n\t     **\n\t     * Inserts the element after the given one\n\t     **\n\t     - el (Element) element next to whom insert to\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.insertBefore = function (el) {\n\t        el = wrap(el);\n\t        var parent = this.parent();\n\t        el.node.parentNode.insertBefore(this.node, el.node);\n\t        this.paper = el.paper;\n\t        parent && parent.add();\n\t        el.parent() && el.parent().add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertAfter\n\t     [ method ]\n\t     **\n\t     * Inserts the element after the given one\n\t     **\n\t     - el (Element) element next to whom insert to\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.insertAfter = function (el) {\n\t        el = wrap(el);\n\t        var parent = this.parent();\n\t        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n\t        this.paper = el.paper;\n\t        parent && parent.add();\n\t        el.parent() && el.parent().add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.remove\n\t     [ method ]\n\t     **\n\t     * Removes element from the DOM\n\t     = (Element) the detached element\n\t    \\*/\n\t    elproto.remove = function () {\n\t        var parent = this.parent();\n\t        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n\t        delete this.paper;\n\t        this.removed = true;\n\t        parent && parent.add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.select\n\t     [ method ]\n\t     **\n\t     * Gathers the nested @Element matching the given set of CSS selectors\n\t     **\n\t     - query (string) CSS selector\n\t     = (Element) result of query selection\n\t    \\*/\n\t    elproto.select = function (query) {\n\t        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n\t        return wrap(this.node.querySelector(query));\n\t    };\n\t    /*\\\n\t     * Element.selectAll\n\t     [ method ]\n\t     **\n\t     * Gathers nested @Element objects matching the given set of CSS selectors\n\t     **\n\t     - query (string) CSS selector\n\t     = (Set|array) result of query selection\n\t    \\*/\n\t    elproto.selectAll = function (query) {\n\t        var nodelist = this.node.querySelectorAll(query),\n\t            set = (Snap.set || Array)();\n\t        for (var i = 0; i < nodelist.length; i++) {\n\t            set.push(wrap(nodelist[i]));\n\t        }\n\t        return set;\n\t    };\n\t    /*\\\n\t     * Element.asPX\n\t     [ method ]\n\t     **\n\t     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n\t     **\n\t     - attr (string) attribute name\n\t     - value (string) #optional attribute value\n\t     = (Element) result of query selection\n\t    \\*/\n\t    elproto.asPX = function (attr, value) {\n\t        if (value == null) {\n\t            value = this.attr(attr);\n\t        }\n\t        return +unit2px(this, attr, value);\n\t    };\n\t    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n\t    /*\\\n\t     * Element.use\n\t     [ method ]\n\t     **\n\t     * Creates a `<use>` element linked to the current element\n\t     **\n\t     = (Element) the `<use>` element\n\t    \\*/\n\t    elproto.use = function () {\n\t        var use,\n\t            id = this.node.id;\n\t        if (!id) {\n\t            id = this.id;\n\t            $(this.node, {\n\t                id: id\n\t            });\n\t        }\n\t        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n\t            this.type == \"pattern\") {\n\t            use = make(this.type, this.node.parentNode);\n\t        } else {\n\t            use = make(\"use\", this.node.parentNode);\n\t        }\n\t        $(use.node, {\n\t            \"xlink:href\": \"#\" + id\n\t        });\n\t        use.original = this;\n\t        return use;\n\t    };\n\t    function fixids(el) {\n\t        var els = el.selectAll(\"*\"),\n\t            it,\n\t            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n\t            ids = [],\n\t            uses = {};\n\t        function urltest(it, name) {\n\t            var val = $(it.node, name);\n\t            val = val && val.match(url);\n\t            val = val && val[2];\n\t            if (val && val.charAt() == \"#\") {\n\t                val = val.substring(1);\n\t            } else {\n\t                return;\n\t            }\n\t            if (val) {\n\t                uses[val] = (uses[val] || []).concat(function (id) {\n\t                    var attr = {};\n\t                    attr[name] = URL(id);\n\t                    $(it.node, attr);\n\t                });\n\t            }\n\t        }\n\t        function linktest(it) {\n\t            var val = $(it.node, \"xlink:href\");\n\t            if (val && val.charAt() == \"#\") {\n\t                val = val.substring(1);\n\t            } else {\n\t                return;\n\t            }\n\t            if (val) {\n\t                uses[val] = (uses[val] || []).concat(function (id) {\n\t                    it.attr(\"xlink:href\", \"#\" + id);\n\t                });\n\t            }\n\t        }\n\t        for (var i = 0, ii = els.length; i < ii; i++) {\n\t            it = els[i];\n\t            urltest(it, \"fill\");\n\t            urltest(it, \"stroke\");\n\t            urltest(it, \"filter\");\n\t            urltest(it, \"mask\");\n\t            urltest(it, \"clip-path\");\n\t            linktest(it);\n\t            var oldid = $(it.node, \"id\");\n\t            if (oldid) {\n\t                $(it.node, {id: it.id});\n\t                ids.push({\n\t                    old: oldid,\n\t                    id: it.id\n\t                });\n\t            }\n\t        }\n\t        for (i = 0, ii = ids.length; i < ii; i++) {\n\t            var fs = uses[ids[i].old];\n\t            if (fs) {\n\t                for (var j = 0, jj = fs.length; j < jj; j++) {\n\t                    fs[j](ids[i].id);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /*\\\n\t     * Element.clone\n\t     [ method ]\n\t     **\n\t     * Creates a clone of the element and inserts it after the element\n\t     **\n\t     = (Element) the clone\n\t    \\*/\n\t    elproto.clone = function () {\n\t        var clone = wrap(this.node.cloneNode(true));\n\t        if ($(clone.node, \"id\")) {\n\t            $(clone.node, {id: clone.id});\n\t        }\n\t        fixids(clone);\n\t        clone.insertAfter(this);\n\t        return clone;\n\t    };\n\t    /*\\\n\t     * Element.toDefs\n\t     [ method ]\n\t     **\n\t     * Moves element to the shared `<defs>` area\n\t     **\n\t     = (Element) the element\n\t    \\*/\n\t    elproto.toDefs = function () {\n\t        var defs = getSomeDefs(this);\n\t        defs.appendChild(this.node);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toPattern\n\t     [ method ]\n\t     **\n\t     * Creates a `<pattern>` element from the current element\n\t     **\n\t     * To create a pattern you have to specify the pattern rect:\n\t     - x (string|number)\n\t     - y (string|number)\n\t     - width (string|number)\n\t     - height (string|number)\n\t     = (Element) the `<pattern>` element\n\t     * You can use pattern later on as an argument for `fill` attribute:\n\t     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n\t     |         fill: \"none\",\n\t     |         stroke: \"#bada55\",\n\t     |         strokeWidth: 5\n\t     |     }).pattern(0, 0, 10, 10),\n\t     |     c = paper.circle(200, 200, 100);\n\t     | c.attr({\n\t     |     fill: p\n\t     | });\n\t    \\*/\n\t    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n\t        var p = make(\"pattern\", getSomeDefs(this));\n\t        if (x == null) {\n\t            x = this.getBBox();\n\t        }\n\t        if (is(x, \"object\") && \"x\" in x) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            x = x.x;\n\t        }\n\t        $(p.node, {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height,\n\t            patternUnits: \"userSpaceOnUse\",\n\t            id: p.id,\n\t            viewBox: [x, y, width, height].join(\" \")\n\t        });\n\t        p.node.appendChild(this.node);\n\t        return p;\n\t    };\n\t// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n\t// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n\t    /*\\\n\t     * Element.marker\n\t     [ method ]\n\t     **\n\t     * Creates a `<marker>` element from the current element\n\t     **\n\t     * To create a marker you have to specify the bounding rect and reference point:\n\t     - x (number)\n\t     - y (number)\n\t     - width (number)\n\t     - height (number)\n\t     - refX (number)\n\t     - refY (number)\n\t     = (Element) the `<marker>` element\n\t     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n\t    \\*/\n\t    // TODO add usage for markers\n\t    elproto.marker = function (x, y, width, height, refX, refY) {\n\t        var p = make(\"marker\", getSomeDefs(this));\n\t        if (x == null) {\n\t            x = this.getBBox();\n\t        }\n\t        if (is(x, \"object\") && \"x\" in x) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            refX = x.refX || x.cx;\n\t            refY = x.refY || x.cy;\n\t            x = x.x;\n\t        }\n\t        $(p.node, {\n\t            viewBox: [x, y, width, height].join(\" \"),\n\t            markerWidth: width,\n\t            markerHeight: height,\n\t            orient: \"auto\",\n\t            refX: refX || 0,\n\t            refY: refY || 0,\n\t            id: p.id\n\t        });\n\t        p.node.appendChild(this.node);\n\t        return p;\n\t    };\n\t    // animation\n\t    function slice(from, to, f) {\n\t        return function (arr) {\n\t            var res = arr.slice(from, to);\n\t            if (res.length == 1) {\n\t                res = res[0];\n\t            }\n\t            return f ? f(res) : res;\n\t        };\n\t    }\n\t    var Animation = function (attr, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        this.attr = attr;\n\t        this.dur = ms;\n\t        easing && (this.easing = easing);\n\t        callback && (this.callback = callback);\n\t    };\n\t    Snap._.Animation = Animation;\n\t    /*\\\n\t     * Snap.animation\n\t     [ method ]\n\t     **\n\t     * Creates an animation object\n\t     **\n\t     - attr (object) attributes of final destination\n\t     - duration (number) duration of the animation, in milliseconds\n\t     - easing (function) #optional one of easing functions of @mina or custom one\n\t     - callback (function) #optional callback function that fires when animation ends\n\t     = (object) animation object\n\t    \\*/\n\t    Snap.animation = function (attr, ms, easing, callback) {\n\t        return new Animation(attr, ms, easing, callback);\n\t    };\n\t    /*\\\n\t     * Element.inAnim\n\t     [ method ]\n\t     **\n\t     * Returns a set of animations that may be able to manipulate the current element\n\t     **\n\t     = (object) in format:\n\t     o {\n\t     o     anim (object) animation object,\n\t     o     mina (object) @mina object,\n\t     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,\n\t     o     status (function) gets or sets the status of the animation,\n\t     o     stop (function) stops the animation\n\t     o }\n\t    \\*/\n\t    elproto.inAnim = function () {\n\t        var el = this,\n\t            res = [];\n\t        for (var id in el.anims) if (el.anims[has](id)) {\n\t            (function (a) {\n\t                res.push({\n\t                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n\t                    mina: a,\n\t                    curStatus: a.status(),\n\t                    status: function (val) {\n\t                        return a.status(val);\n\t                    },\n\t                    stop: function () {\n\t                        a.stop();\n\t                    }\n\t                });\n\t            }(el.anims[id]));\n\t        }\n\t        return res;\n\t    };\n\t    /*\\\n\t     * Snap.animate\n\t     [ method ]\n\t     **\n\t     * Runs generic animation of one number into another with a caring function\n\t     **\n\t     - from (number|array) number or array of numbers\n\t     - to (number|array) number or array of numbers\n\t     - setter (function) caring function that accepts one number argument\n\t     - duration (number) duration, in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function to execute when animation ends\n\t     = (object) animation object in @mina format\n\t     o {\n\t     o     id (string) animation id, consider it read-only,\n\t     o     duration (function) gets or sets the duration of the animation,\n\t     o     easing (function) easing,\n\t     o     speed (function) gets or sets the speed of the animation,\n\t     o     status (function) gets or sets the status of the animation,\n\t     o     stop (function) stops the animation\n\t     o }\n\t     | var rect = Snap().rect(0, 0, 10, 10);\n\t     | Snap.animate(0, 10, function (val) {\n\t     |     rect.attr({\n\t     |         x: val\n\t     |     });\n\t     | }, 1000);\n\t     | // in given context is equivalent to\n\t     | rect.animate({x: 10}, 1000);\n\t    \\*/\n\t    Snap.animate = function (from, to, setter, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        var now = mina.time(),\n\t            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n\t        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n\t        return anim;\n\t    };\n\t    /*\\\n\t     * Element.stop\n\t     [ method ]\n\t     **\n\t     * Stops all the animations for the current element\n\t     **\n\t     = (Element) the current element\n\t    \\*/\n\t    elproto.stop = function () {\n\t        var anims = this.inAnim();\n\t        for (var i = 0, ii = anims.length; i < ii; i++) {\n\t            anims[i].stop();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.animate\n\t     [ method ]\n\t     **\n\t     * Animates the given attributes of the element\n\t     **\n\t     - attrs (object) key-value pairs of destination attributes\n\t     - duration (number) duration of the animation in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function that executes when the animation ends\n\t     = (Element) the current element\n\t    \\*/\n\t    elproto.animate = function (attrs, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        if (attrs instanceof Animation) {\n\t            callback = attrs.callback;\n\t            easing = attrs.easing;\n\t            ms = easing.dur;\n\t            attrs = attrs.attr;\n\t        }\n\t        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n\t            el = this;\n\t        for (var key in attrs) if (attrs[has](key)) {\n\t            if (el.equal) {\n\t                eq = el.equal(key, Str(attrs[key]));\n\t                from = eq.from;\n\t                to = eq.to;\n\t                f = eq.f;\n\t            } else {\n\t                from = +el.attr(key);\n\t                to = +attrs[key];\n\t            }\n\t            var len = is(from, \"array\") ? from.length : 1;\n\t            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n\t            fkeys = fkeys.concat(from);\n\t            tkeys = tkeys.concat(to);\n\t        }\n\t        var now = mina.time(),\n\t            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n\t                var attr = {};\n\t                for (var key in keys) if (keys[has](key)) {\n\t                    attr[key] = keys[key](val);\n\t                }\n\t                el.attr(attr);\n\t            }, easing);\n\t        el.anims[anim.id] = anim;\n\t        anim._attrs = attrs;\n\t        anim._callback = callback;\n\t        eve(\"snap.animcreated.\" + el.id, anim);\n\t        eve.once(\"mina.finish.\" + anim.id, function () {\n\t            delete el.anims[anim.id];\n\t            callback && callback.call(el);\n\t        });\n\t        eve.once(\"mina.stop.\" + anim.id, function () {\n\t            delete el.anims[anim.id];\n\t        });\n\t        return el;\n\t    };\n\t    var eldata = {};\n\t    /*\\\n\t     * Element.data\n\t     [ method ]\n\t     **\n\t     * Adds or retrieves given value associated with given key. (Don’t confuse\n\t     * with `data-` attributes)\n\t     *\n\t     * See also @Element.removeData\n\t     - key (string) key to store data\n\t     - value (any) #optional value to store\n\t     = (object) @Element\n\t     * or, if value is not specified:\n\t     = (any) value\n\t     > Usage\n\t     | for (var i = 0, i < 5, i++) {\n\t     |     paper.circle(10 + 15 * i, 10, 10)\n\t     |          .attr({fill: \"#000\"})\n\t     |          .data(\"i\", i)\n\t     |          .click(function () {\n\t     |             alert(this.data(\"i\"));\n\t     |          });\n\t     | }\n\t    \\*/\n\t    elproto.data = function (key, value) {\n\t        var data = eldata[this.id] = eldata[this.id] || {};\n\t        if (arguments.length == 0){\n\t            eve(\"snap.data.get.\" + this.id, this, data, null);\n\t            return data;\n\t        }\n\t        if (arguments.length == 1) {\n\t            if (Snap.is(key, \"object\")) {\n\t                for (var i in key) if (key[has](i)) {\n\t                    this.data(i, key[i]);\n\t                }\n\t                return this;\n\t            }\n\t            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n\t            return data[key];\n\t        }\n\t        data[key] = value;\n\t        eve(\"snap.data.set.\" + this.id, this, value, key);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeData\n\t     [ method ]\n\t     **\n\t     * Removes value associated with an element by given key.\n\t     * If key is not provided, removes all the data of the element.\n\t     - key (string) #optional key\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.removeData = function (key) {\n\t        if (key == null) {\n\t            eldata[this.id] = {};\n\t        } else {\n\t            eldata[this.id] && delete eldata[this.id][key];\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.outerSVG\n\t     [ method ]\n\t     **\n\t     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n\t     *\n\t     * See also @Element.innerSVG\n\t     = (string) SVG code for the element\n\t    \\*/\n\t    /*\\\n\t     * Element.toString\n\t     [ method ]\n\t     **\n\t     * See @Element.outerSVG\n\t    \\*/\n\t    elproto.outerSVG = elproto.toString = toString(1);\n\t    /*\\\n\t     * Element.innerSVG\n\t     [ method ]\n\t     **\n\t     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n\t     = (string) SVG code for the element\n\t    \\*/\n\t    elproto.innerSVG = toString();\n\t    function toString(type) {\n\t        return function () {\n\t            var res = type ? \"<\" + this.type : \"\",\n\t                attr = this.node.attributes,\n\t                chld = this.node.childNodes;\n\t            if (type) {\n\t                for (var i = 0, ii = attr.length; i < ii; i++) {\n\t                    res += \" \" + attr[i].name + '=\"' +\n\t                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n\t                }\n\t            }\n\t            if (chld.length) {\n\t                type && (res += \">\");\n\t                for (i = 0, ii = chld.length; i < ii; i++) {\n\t                    if (chld[i].nodeType == 3) {\n\t                        res += chld[i].nodeValue;\n\t                    } else if (chld[i].nodeType == 1) {\n\t                        res += wrap(chld[i]).toString();\n\t                    }\n\t                }\n\t                type && (res += \"</\" + this.type + \">\");\n\t            } else {\n\t                type && (res += \"/>\");\n\t            }\n\t            return res;\n\t        };\n\t    }\n\t    elproto.toDataURL = function () {\n\t        if (window && window.btoa) {\n\t            var bb = this.getBBox(),\n\t                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n\t                x: +bb.x.toFixed(3),\n\t                y: +bb.y.toFixed(3),\n\t                width: +bb.width.toFixed(3),\n\t                height: +bb.height.toFixed(3),\n\t                contents: this.outerSVG()\n\t            });\n\t            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n\t        }\n\t    };\n\t    /*\\\n\t     * Fragment.select\n\t     [ method ]\n\t     **\n\t     * See @Element.select\n\t    \\*/\n\t    Fragment.prototype.select = elproto.select;\n\t    /*\\\n\t     * Fragment.selectAll\n\t     [ method ]\n\t     **\n\t     * See @Element.selectAll\n\t    \\*/\n\t    Fragment.prototype.selectAll = elproto.selectAll;\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var objectToString = Object.prototype.toString,\n\t        Str = String,\n\t        math = Math,\n\t        E = \"\";\n\t    function Matrix(a, b, c, d, e, f) {\n\t        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n\t            this.a = a.a;\n\t            this.b = a.b;\n\t            this.c = a.c;\n\t            this.d = a.d;\n\t            this.e = a.e;\n\t            this.f = a.f;\n\t            return;\n\t        }\n\t        if (a != null) {\n\t            this.a = +a;\n\t            this.b = +b;\n\t            this.c = +c;\n\t            this.d = +d;\n\t            this.e = +e;\n\t            this.f = +f;\n\t        } else {\n\t            this.a = 1;\n\t            this.b = 0;\n\t            this.c = 0;\n\t            this.d = 1;\n\t            this.e = 0;\n\t            this.f = 0;\n\t        }\n\t    }\n\t    (function (matrixproto) {\n\t        /*\\\n\t         * Matrix.add\n\t         [ method ]\n\t         **\n\t         * Adds the given matrix to existing one\n\t         - a (number)\n\t         - b (number)\n\t         - c (number)\n\t         - d (number)\n\t         - e (number)\n\t         - f (number)\n\t         * or\n\t         - matrix (object) @Matrix\n\t        \\*/\n\t        matrixproto.add = function (a, b, c, d, e, f) {\n\t            var out = [[], [], []],\n\t                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n\t                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n\t                x, y, z, res;\n\t\n\t            if (a && a instanceof Matrix) {\n\t                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n\t            }\n\t\n\t            for (x = 0; x < 3; x++) {\n\t                for (y = 0; y < 3; y++) {\n\t                    res = 0;\n\t                    for (z = 0; z < 3; z++) {\n\t                        res += m[x][z] * matrix[z][y];\n\t                    }\n\t                    out[x][y] = res;\n\t                }\n\t            }\n\t            this.a = out[0][0];\n\t            this.b = out[1][0];\n\t            this.c = out[0][1];\n\t            this.d = out[1][1];\n\t            this.e = out[0][2];\n\t            this.f = out[1][2];\n\t            return this;\n\t        };\n\t        /*\\\n\t         * Matrix.invert\n\t         [ method ]\n\t         **\n\t         * Returns an inverted version of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.invert = function () {\n\t            var me = this,\n\t                x = me.a * me.d - me.b * me.c;\n\t            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n\t        };\n\t        /*\\\n\t         * Matrix.clone\n\t         [ method ]\n\t         **\n\t         * Returns a copy of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.clone = function () {\n\t            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n\t        };\n\t        /*\\\n\t         * Matrix.translate\n\t         [ method ]\n\t         **\n\t         * Translate the matrix\n\t         - x (number) horizontal offset distance\n\t         - y (number) vertical offset distance\n\t        \\*/\n\t        matrixproto.translate = function (x, y) {\n\t            return this.add(1, 0, 0, 1, x, y);\n\t        };\n\t        /*\\\n\t         * Matrix.scale\n\t         [ method ]\n\t         **\n\t         * Scales the matrix\n\t         - x (number) amount to be scaled, with `1` resulting in no change\n\t         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n\t         - cx (number) #optional horizontal origin point from which to scale\n\t         - cy (number) #optional vertical origin point from which to scale\n\t         * Default cx, cy is the middle point of the element.\n\t        \\*/\n\t        matrixproto.scale = function (x, y, cx, cy) {\n\t            y == null && (y = x);\n\t            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n\t            this.add(x, 0, 0, y, 0, 0);\n\t            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n\t            return this;\n\t        };\n\t        /*\\\n\t         * Matrix.rotate\n\t         [ method ]\n\t         **\n\t         * Rotates the matrix\n\t         - a (number) angle of rotation, in degrees\n\t         - x (number) horizontal origin point from which to rotate\n\t         - y (number) vertical origin point from which to rotate\n\t        \\*/\n\t        matrixproto.rotate = function (a, x, y) {\n\t            a = Snap.rad(a);\n\t            x = x || 0;\n\t            y = y || 0;\n\t            var cos = +math.cos(a).toFixed(9),\n\t                sin = +math.sin(a).toFixed(9);\n\t            this.add(cos, sin, -sin, cos, x, y);\n\t            return this.add(1, 0, 0, 1, -x, -y);\n\t        };\n\t        /*\\\n\t         * Matrix.x\n\t         [ method ]\n\t         **\n\t         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n\t         - x (number)\n\t         - y (number)\n\t         = (number) x\n\t        \\*/\n\t        matrixproto.x = function (x, y) {\n\t            return x * this.a + y * this.c + this.e;\n\t        };\n\t        /*\\\n\t         * Matrix.y\n\t         [ method ]\n\t         **\n\t         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n\t         - x (number)\n\t         - y (number)\n\t         = (number) y\n\t        \\*/\n\t        matrixproto.y = function (x, y) {\n\t            return x * this.b + y * this.d + this.f;\n\t        };\n\t        matrixproto.get = function (i) {\n\t            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n\t        };\n\t        matrixproto.toString = function () {\n\t            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n\t        };\n\t        matrixproto.offset = function () {\n\t            return [this.e.toFixed(4), this.f.toFixed(4)];\n\t        };\n\t        function norm(a) {\n\t            return a[0] * a[0] + a[1] * a[1];\n\t        }\n\t        function normalize(a) {\n\t            var mag = math.sqrt(norm(a));\n\t            a[0] && (a[0] /= mag);\n\t            a[1] && (a[1] /= mag);\n\t        }\n\t        /*\\\n\t         * Matrix.determinant\n\t         [ method ]\n\t         **\n\t         * Finds determinant of the given matrix.\n\t         = (number) determinant\n\t        \\*/\n\t        matrixproto.determinant = function () {\n\t            return this.a * this.d - this.b * this.c;\n\t        };\n\t        /*\\\n\t         * Matrix.split\n\t         [ method ]\n\t         **\n\t         * Splits matrix into primitive transformations\n\t         = (object) in format:\n\t         o dx (number) translation by x\n\t         o dy (number) translation by y\n\t         o scalex (number) scale by x\n\t         o scaley (number) scale by y\n\t         o shear (number) shear\n\t         o rotate (number) rotation in deg\n\t         o isSimple (boolean) could it be represented via simple transformations\n\t        \\*/\n\t        matrixproto.split = function () {\n\t            var out = {};\n\t            // translation\n\t            out.dx = this.e;\n\t            out.dy = this.f;\n\t\n\t            // scale and shear\n\t            var row = [[this.a, this.c], [this.b, this.d]];\n\t            out.scalex = math.sqrt(norm(row[0]));\n\t            normalize(row[0]);\n\t\n\t            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n\t            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\t\n\t            out.scaley = math.sqrt(norm(row[1]));\n\t            normalize(row[1]);\n\t            out.shear /= out.scaley;\n\t\n\t            if (this.determinant() < 0) {\n\t                out.scalex = -out.scalex;\n\t            }\n\t\n\t            // rotation\n\t            var sin = -row[0][1],\n\t                cos = row[1][1];\n\t            if (cos < 0) {\n\t                out.rotate = Snap.deg(math.acos(cos));\n\t                if (sin < 0) {\n\t                    out.rotate = 360 - out.rotate;\n\t                }\n\t            } else {\n\t                out.rotate = Snap.deg(math.asin(sin));\n\t            }\n\t\n\t            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n\t            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n\t            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n\t            return out;\n\t        };\n\t        /*\\\n\t         * Matrix.toTransformString\n\t         [ method ]\n\t         **\n\t         * Returns transform string that represents given matrix\n\t         = (string) transform string\n\t        \\*/\n\t        matrixproto.toTransformString = function (shorter) {\n\t            var s = shorter || this.split();\n\t            if (!+s.shear.toFixed(9)) {\n\t                s.scalex = +s.scalex.toFixed(4);\n\t                s.scaley = +s.scaley.toFixed(4);\n\t                s.rotate = +s.rotate.toFixed(4);\n\t                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +\n\t                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n\t                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n\t            } else {\n\t                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n\t            }\n\t        };\n\t    })(Matrix.prototype);\n\t    /*\\\n\t     * Snap.Matrix\n\t     [ method ]\n\t     **\n\t     * Matrix constructor, extend on your own risk.\n\t     * To create matrices use @Snap.matrix.\n\t    \\*/\n\t    Snap.Matrix = Matrix;\n\t    /*\\\n\t     * Snap.matrix\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns a matrix based on the given parameters\n\t     - a (number)\n\t     - b (number)\n\t     - c (number)\n\t     - d (number)\n\t     - e (number)\n\t     - f (number)\n\t     * or\n\t     - svgMatrix (SVGMatrix)\n\t     = (object) @Matrix\n\t    \\*/\n\t    Snap.matrix = function (a, b, c, d, e, f) {\n\t        return new Matrix(a, b, c, d, e, f);\n\t    };\n\t});\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var has = \"hasOwnProperty\",\n\t        make = Snap._.make,\n\t        wrap = Snap._.wrap,\n\t        is = Snap.is,\n\t        getSomeDefs = Snap._.getSomeDefs,\n\t        reURLValue = /^url\\(#?([^)]+)\\)$/,\n\t        $ = Snap._.$,\n\t        URL = Snap.url,\n\t        Str = String,\n\t        separator = Snap._.separator,\n\t        E = \"\";\n\t    // Attributes event handlers\n\t    eve.on(\"snap.util.attr.mask\", function (value) {\n\t        if (value instanceof Element || value instanceof Fragment) {\n\t            eve.stop();\n\t            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n\t                value = value.node.firstChild;\n\t                getSomeDefs(this).appendChild(value);\n\t                value = wrap(value);\n\t            }\n\t            if (value.type == \"mask\") {\n\t                var mask = value;\n\t            } else {\n\t                mask = make(\"mask\", getSomeDefs(this));\n\t                mask.node.appendChild(value.node);\n\t            }\n\t            !mask.node.id && $(mask.node, {\n\t                id: mask.id\n\t            });\n\t            $(this.node, {\n\t                mask: URL(mask.id)\n\t            });\n\t        }\n\t    });\n\t    (function (clipIt) {\n\t        eve.on(\"snap.util.attr.clip\", clipIt);\n\t        eve.on(\"snap.util.attr.clip-path\", clipIt);\n\t        eve.on(\"snap.util.attr.clipPath\", clipIt);\n\t    }(function (value) {\n\t        if (value instanceof Element || value instanceof Fragment) {\n\t            eve.stop();\n\t            if (value.type == \"clipPath\") {\n\t                var clip = value;\n\t            } else {\n\t                clip = make(\"clipPath\", getSomeDefs(this));\n\t                clip.node.appendChild(value.node);\n\t                !clip.node.id && $(clip.node, {\n\t                    id: clip.id\n\t                });\n\t            }\n\t            $(this.node, {\n\t                \"clip-path\": URL(clip.node.id || clip.id)\n\t            });\n\t        }\n\t    }));\n\t    function fillStroke(name) {\n\t        return function (value) {\n\t            eve.stop();\n\t            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n\t                (value.node.firstChild.tagName == \"radialGradient\" ||\n\t                value.node.firstChild.tagName == \"linearGradient\" ||\n\t                value.node.firstChild.tagName == \"pattern\")) {\n\t                value = value.node.firstChild;\n\t                getSomeDefs(this).appendChild(value);\n\t                value = wrap(value);\n\t            }\n\t            if (value instanceof Element) {\n\t                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n\t                   || value.type == \"pattern\") {\n\t                    if (!value.node.id) {\n\t                        $(value.node, {\n\t                            id: value.id\n\t                        });\n\t                    }\n\t                    var fill = URL(value.node.id);\n\t                } else {\n\t                    fill = value.attr(name);\n\t                }\n\t            } else {\n\t                fill = Snap.color(value);\n\t                if (fill.error) {\n\t                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n\t                    if (grad) {\n\t                        if (!grad.node.id) {\n\t                            $(grad.node, {\n\t                                id: grad.id\n\t                            });\n\t                        }\n\t                        fill = URL(grad.node.id);\n\t                    } else {\n\t                        fill = value;\n\t                    }\n\t                } else {\n\t                    fill = Str(fill);\n\t                }\n\t            }\n\t            var attrs = {};\n\t            attrs[name] = fill;\n\t            $(this.node, attrs);\n\t            this.node.style[name] = E;\n\t        };\n\t    }\n\t    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n\t    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n\t    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n\t    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n\t        string = Str(string);\n\t        var tokens = string.match(gradrg);\n\t        if (!tokens) {\n\t            return null;\n\t        }\n\t        var type = tokens[1],\n\t            params = tokens[2],\n\t            stops = tokens[3];\n\t        params = params.split(/\\s*,\\s*/).map(function (el) {\n\t            return +el == el ? +el : el;\n\t        });\n\t        if (params.length == 1 && params[0] == 0) {\n\t            params = [];\n\t        }\n\t        stops = stops.split(\"-\");\n\t        stops = stops.map(function (el) {\n\t            el = el.split(\":\");\n\t            var out = {\n\t                color: el[0]\n\t            };\n\t            if (el[1]) {\n\t                out.offset = parseFloat(el[1]);\n\t            }\n\t            return out;\n\t        });\n\t        return {\n\t            type: type,\n\t            params: params,\n\t            stops: stops\n\t        };\n\t    });\n\t\n\t    eve.on(\"snap.util.attr.d\", function (value) {\n\t        eve.stop();\n\t        if (is(value, \"array\") && is(value[0], \"array\")) {\n\t            value = Snap.path.toString.call(value);\n\t        }\n\t        value = Str(value);\n\t        if (value.match(/[ruo]/i)) {\n\t            value = Snap.path.toAbsolute(value);\n\t        }\n\t        $(this.node, {d: value});\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.#text\", function (value) {\n\t        eve.stop();\n\t        value = Str(value);\n\t        var txt = glob.doc.createTextNode(value);\n\t        while (this.node.firstChild) {\n\t            this.node.removeChild(this.node.firstChild);\n\t        }\n\t        this.node.appendChild(txt);\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.path\", function (value) {\n\t        eve.stop();\n\t        this.attr({d: value});\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.class\", function (value) {\n\t        eve.stop();\n\t        this.node.className.baseVal = value;\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.viewBox\", function (value) {\n\t        var vb;\n\t        if (is(value, \"object\") && \"x\" in value) {\n\t            vb = [value.x, value.y, value.width, value.height].join(\" \");\n\t        } else if (is(value, \"array\")) {\n\t            vb = value.join(\" \");\n\t        } else {\n\t            vb = value;\n\t        }\n\t        $(this.node, {\n\t            viewBox: vb\n\t        });\n\t        eve.stop();\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.transform\", function (value) {\n\t        this.transform(value);\n\t        eve.stop();\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.r\", function (value) {\n\t        if (this.type == \"rect\") {\n\t            eve.stop();\n\t            $(this.node, {\n\t                rx: value,\n\t                ry: value\n\t            });\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.textpath\", function (value) {\n\t        eve.stop();\n\t        if (this.type == \"text\") {\n\t            var id, tp, node;\n\t            if (!value && this.textPath) {\n\t                tp = this.textPath;\n\t                while (tp.node.firstChild) {\n\t                    this.node.appendChild(tp.node.firstChild);\n\t                }\n\t                tp.remove();\n\t                delete this.textPath;\n\t                return;\n\t            }\n\t            if (is(value, \"string\")) {\n\t                var defs = getSomeDefs(this),\n\t                    path = wrap(defs.parentNode).path(value);\n\t                defs.appendChild(path.node);\n\t                id = path.id;\n\t                path.attr({id: id});\n\t            } else {\n\t                value = wrap(value);\n\t                if (value instanceof Element) {\n\t                    id = value.attr(\"id\");\n\t                    if (!id) {\n\t                        id = value.id;\n\t                        value.attr({id: id});\n\t                    }\n\t                }\n\t            }\n\t            if (id) {\n\t                tp = this.textPath;\n\t                node = this.node;\n\t                if (tp) {\n\t                    tp.attr({\"xlink:href\": \"#\" + id});\n\t                } else {\n\t                    tp = $(\"textPath\", {\n\t                        \"xlink:href\": \"#\" + id\n\t                    });\n\t                    while (node.firstChild) {\n\t                        tp.appendChild(node.firstChild);\n\t                    }\n\t                    node.appendChild(tp);\n\t                    this.textPath = wrap(tp);\n\t                }\n\t            }\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.text\", function (value) {\n\t        if (this.type == \"text\") {\n\t            var i = 0,\n\t                node = this.node,\n\t                tuner = function (chunk) {\n\t                    var out = $(\"tspan\");\n\t                    if (is(chunk, \"array\")) {\n\t                        for (var i = 0; i < chunk.length; i++) {\n\t                            out.appendChild(tuner(chunk[i]));\n\t                        }\n\t                    } else {\n\t                        out.appendChild(glob.doc.createTextNode(chunk));\n\t                    }\n\t                    out.normalize && out.normalize();\n\t                    return out;\n\t                };\n\t            while (node.firstChild) {\n\t                node.removeChild(node.firstChild);\n\t            }\n\t            var tuned = tuner(value);\n\t            while (tuned.firstChild) {\n\t                node.appendChild(tuned.firstChild);\n\t            }\n\t        }\n\t        eve.stop();\n\t    })(-1);\n\t    function setFontSize(value) {\n\t        eve.stop();\n\t        if (value == +value) {\n\t            value += \"px\";\n\t        }\n\t        this.node.style.fontSize = value;\n\t    }\n\t    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n\t    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\t\n\t\n\t    eve.on(\"snap.util.getattr.transform\", function () {\n\t        eve.stop();\n\t        return this.transform();\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.textpath\", function () {\n\t        eve.stop();\n\t        return this.textPath;\n\t    })(-1);\n\t    // Markers\n\t    (function () {\n\t        function getter(end) {\n\t            return function () {\n\t                eve.stop();\n\t                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n\t                if (style == \"none\") {\n\t                    return style;\n\t                } else {\n\t                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n\t                }\n\t            };\n\t        }\n\t        function setter(end) {\n\t            return function (value) {\n\t                eve.stop();\n\t                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n\t                if (value == \"\" || !value) {\n\t                    this.node.style[name] = \"none\";\n\t                    return;\n\t                }\n\t                if (value.type == \"marker\") {\n\t                    var id = value.node.id;\n\t                    if (!id) {\n\t                        $(value.node, {id: value.id});\n\t                    }\n\t                    this.node.style[name] = URL(id);\n\t                    return;\n\t                }\n\t            };\n\t        }\n\t        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n\t        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n\t        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n\t        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n\t        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n\t    }());\n\t    eve.on(\"snap.util.getattr.r\", function () {\n\t        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n\t            eve.stop();\n\t            return $(this.node, \"rx\");\n\t        }\n\t    })(-1);\n\t    function textExtract(node) {\n\t        var out = [];\n\t        var children = node.childNodes;\n\t        for (var i = 0, ii = children.length; i < ii; i++) {\n\t            var chi = children[i];\n\t            if (chi.nodeType == 3) {\n\t                out.push(chi.nodeValue);\n\t            }\n\t            if (chi.tagName == \"tspan\") {\n\t                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n\t                    out.push(chi.firstChild.nodeValue);\n\t                } else {\n\t                    out.push(textExtract(chi));\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t    eve.on(\"snap.util.getattr.text\", function () {\n\t        if (this.type == \"text\" || this.type == \"tspan\") {\n\t            eve.stop();\n\t            var out = textExtract(this.node);\n\t            return out.length == 1 ? out[0] : out;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.#text\", function () {\n\t        return this.node.textContent;\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.viewBox\", function () {\n\t        eve.stop();\n\t        var vb = $(this.node, \"viewBox\");\n\t        if (vb) {\n\t            vb = vb.split(separator);\n\t            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n\t        } else {\n\t            return;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.points\", function () {\n\t        var p = $(this.node, \"points\");\n\t        eve.stop();\n\t        if (p) {\n\t            return p.split(separator);\n\t        } else {\n\t            return;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.path\", function () {\n\t        var p = $(this.node, \"d\");\n\t        eve.stop();\n\t        return p;\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.class\", function () {\n\t        return this.node.className.baseVal;\n\t    })(-1);\n\t    function getFontSize() {\n\t        eve.stop();\n\t        return this.node.style.fontSize;\n\t    }\n\t    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n\t    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n\t});\n\t\n\t// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var rgNotSpace = /\\S+/g,\n\t        rgBadSpace = /[\\t\\r\\n\\f]/g,\n\t        rgTrim = /(^\\s+|\\s+$)/g,\n\t        Str = String,\n\t        elproto = Element.prototype;\n\t    /*\\\n\t     * Element.addClass\n\t     [ method ]\n\t     **\n\t     * Adds given class name or list of class names to the element.\n\t     - value (string) class name or space separated list of class names\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.addClass = function (value) {\n\t        var classes = Str(value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t\n\t        if (classes.length) {\n\t            j = 0;\n\t            while ((clazz = classes[j++])) {\n\t                pos = curClasses.indexOf(clazz);\n\t                if (!~pos) {\n\t                    curClasses.push(clazz);\n\t                }\n\t            }\n\t\n\t            finalValue = curClasses.join(\" \");\n\t            if (className != finalValue) {\n\t                elem.className.baseVal = finalValue;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeClass\n\t     [ method ]\n\t     **\n\t     * Removes given class name or list of class names from the element.\n\t     - value (string) class name or space separated list of class names\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.removeClass = function (value) {\n\t        var classes = Str(value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t        if (curClasses.length) {\n\t            j = 0;\n\t            while ((clazz = classes[j++])) {\n\t                pos = curClasses.indexOf(clazz);\n\t                if (~pos) {\n\t                    curClasses.splice(pos, 1);\n\t                }\n\t            }\n\t\n\t            finalValue = curClasses.join(\" \");\n\t            if (className != finalValue) {\n\t                elem.className.baseVal = finalValue;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.hasClass\n\t     [ method ]\n\t     **\n\t     * Checks if the element has a given class name in the list of class names applied to it.\n\t     - value (string) class name\n\t     **\n\t     = (boolean) `true` if the element has given class\n\t    \\*/\n\t    elproto.hasClass = function (value) {\n\t        var elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [];\n\t        return !!~curClasses.indexOf(value);\n\t    };\n\t    /*\\\n\t     * Element.toggleClass\n\t     [ method ]\n\t     **\n\t     * Add or remove one or more classes from the element, depending on either\n\t     * the class’s presence or the value of the `flag` argument.\n\t     - value (string) class name or space separated list of class names\n\t     - flag (boolean) value to determine whether the class should be added or removed\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.toggleClass = function (value, flag) {\n\t        if (flag != null) {\n\t            if (flag) {\n\t                return this.addClass(value);\n\t            } else {\n\t                return this.removeClass(value);\n\t            }\n\t        }\n\t        var classes = (value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t        j = 0;\n\t        while ((clazz = classes[j++])) {\n\t            pos = curClasses.indexOf(clazz);\n\t            if (~pos) {\n\t                curClasses.splice(pos, 1);\n\t            } else {\n\t                curClasses.push(clazz);\n\t            }\n\t        }\n\t\n\t        finalValue = curClasses.join(\" \");\n\t        if (className != finalValue) {\n\t            elem.className.baseVal = finalValue;\n\t        }\n\t        return this;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var operators = {\n\t            \"+\": function (x, y) {\n\t                    return x + y;\n\t                },\n\t            \"-\": function (x, y) {\n\t                    return x - y;\n\t                },\n\t            \"/\": function (x, y) {\n\t                    return x / y;\n\t                },\n\t            \"*\": function (x, y) {\n\t                    return x * y;\n\t                }\n\t        },\n\t        Str = String,\n\t        reUnit = /[a-z]+$/i,\n\t        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n\t    function getNumber(val) {\n\t        return val;\n\t    }\n\t    function getUnit(unit) {\n\t        return function (val) {\n\t            return +val.toFixed(3) + unit;\n\t        };\n\t    }\n\t    eve.on(\"snap.util.attr\", function (val) {\n\t        var plus = Str(val).match(reAddon);\n\t        if (plus) {\n\t            var evnt = eve.nt(),\n\t                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n\t                a = this.attr(name),\n\t                atr = {};\n\t            eve.stop();\n\t            var unit = plus[3] || \"\",\n\t                aUnit = a.match(reUnit),\n\t                op = operators[plus[1]];\n\t            if (aUnit && aUnit == unit) {\n\t                val = op(parseFloat(a), +plus[2]);\n\t            } else {\n\t                a = this.asPX(name);\n\t                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n\t            }\n\t            if (isNaN(a) || isNaN(val)) {\n\t                return;\n\t            }\n\t            atr[name] = val;\n\t            this.attr(atr);\n\t        }\n\t    })(-10);\n\t    eve.on(\"snap.util.equal\", function (name, b) {\n\t        var A, B, a = Str(this.attr(name) || \"\"),\n\t            el = this,\n\t            bplus = Str(b).match(reAddon);\n\t        if (bplus) {\n\t            eve.stop();\n\t            var unit = bplus[3] || \"\",\n\t                aUnit = a.match(reUnit),\n\t                op = operators[bplus[1]];\n\t            if (aUnit && aUnit == unit) {\n\t                return {\n\t                    from: parseFloat(a),\n\t                    to: op(parseFloat(a), +bplus[2]),\n\t                    f: getUnit(aUnit)\n\t                };\n\t            } else {\n\t                a = this.asPX(name);\n\t                return {\n\t                    from: a,\n\t                    to: op(a, this.asPX(name, bplus[2] + unit)),\n\t                    f: getNumber\n\t                };\n\t            }\n\t        }\n\t    })(-10);\n\t});\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var proto = Paper.prototype,\n\t        is = Snap.is;\n\t    /*\\\n\t     * Paper.rect\n\t     [ method ]\n\t     *\n\t     * Draws a rectangle\n\t     **\n\t     - x (number) x coordinate of the top left corner\n\t     - y (number) y coordinate of the top left corner\n\t     - width (number) width\n\t     - height (number) height\n\t     - rx (number) #optional horizontal radius for rounded corners, default is 0\n\t     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n\t     = (object) the `rect` element\n\t     **\n\t     > Usage\n\t     | // regular rectangle\n\t     | var c = paper.rect(10, 10, 50, 50);\n\t     | // rectangle with rounded corners\n\t     | var c = paper.rect(40, 40, 50, 50, 10);\n\t    \\*/\n\t    proto.rect = function (x, y, w, h, rx, ry) {\n\t        var attr;\n\t        if (ry == null) {\n\t            ry = rx;\n\t        }\n\t        if (is(x, \"object\") && x == \"[object Object]\") {\n\t            attr = x;\n\t        } else if (x != null) {\n\t            attr = {\n\t                x: x,\n\t                y: y,\n\t                width: w,\n\t                height: h\n\t            };\n\t            if (rx != null) {\n\t                attr.rx = rx;\n\t                attr.ry = ry;\n\t            }\n\t        }\n\t        return this.el(\"rect\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.circle\n\t     [ method ]\n\t     **\n\t     * Draws a circle\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - r (number) radius\n\t     = (object) the `circle` element\n\t     **\n\t     > Usage\n\t     | var c = paper.circle(50, 50, 40);\n\t    \\*/\n\t    proto.circle = function (cx, cy, r) {\n\t        var attr;\n\t        if (is(cx, \"object\") && cx == \"[object Object]\") {\n\t            attr = cx;\n\t        } else if (cx != null) {\n\t            attr = {\n\t                cx: cx,\n\t                cy: cy,\n\t                r: r\n\t            };\n\t        }\n\t        return this.el(\"circle\", attr);\n\t    };\n\t\n\t    var preload = (function () {\n\t        function onerror() {\n\t            this.parentNode.removeChild(this);\n\t        }\n\t        return function (src, f) {\n\t            var img = glob.doc.createElement(\"img\"),\n\t                body = glob.doc.body;\n\t            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\t            img.onload = function () {\n\t                f.call(img);\n\t                img.onload = img.onerror = null;\n\t                body.removeChild(img);\n\t            };\n\t            img.onerror = onerror;\n\t            body.appendChild(img);\n\t            img.src = src;\n\t        };\n\t    }());\n\t\n\t    /*\\\n\t     * Paper.image\n\t     [ method ]\n\t     **\n\t     * Places an image on the surface\n\t     **\n\t     - src (string) URI of the source image\n\t     - x (number) x offset position\n\t     - y (number) y offset position\n\t     - width (number) width of the image\n\t     - height (number) height of the image\n\t     = (object) the `image` element\n\t     * or\n\t     = (object) Snap element object with type `image`\n\t     **\n\t     > Usage\n\t     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n\t    \\*/\n\t    proto.image = function (src, x, y, width, height) {\n\t        var el = this.el(\"image\");\n\t        if (is(src, \"object\") && \"src\" in src) {\n\t            el.attr(src);\n\t        } else if (src != null) {\n\t            var set = {\n\t                \"xlink:href\": src,\n\t                preserveAspectRatio: \"none\"\n\t            };\n\t            if (x != null && y != null) {\n\t                set.x = x;\n\t                set.y = y;\n\t            }\n\t            if (width != null && height != null) {\n\t                set.width = width;\n\t                set.height = height;\n\t            } else {\n\t                preload(src, function () {\n\t                    Snap._.$(el.node, {\n\t                        width: this.offsetWidth,\n\t                        height: this.offsetHeight\n\t                    });\n\t                });\n\t            }\n\t            Snap._.$(el.node, set);\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.ellipse\n\t     [ method ]\n\t     **\n\t     * Draws an ellipse\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - rx (number) horizontal radius\n\t     - ry (number) vertical radius\n\t     = (object) the `ellipse` element\n\t     **\n\t     > Usage\n\t     | var c = paper.ellipse(50, 50, 40, 20);\n\t    \\*/\n\t    proto.ellipse = function (cx, cy, rx, ry) {\n\t        var attr;\n\t        if (is(cx, \"object\") && cx == \"[object Object]\") {\n\t            attr = cx;\n\t        } else if (cx != null) {\n\t            attr ={\n\t                cx: cx,\n\t                cy: cy,\n\t                rx: rx,\n\t                ry: ry\n\t            };\n\t        }\n\t        return this.el(\"ellipse\", attr);\n\t    };\n\t    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n\t    /*\\\n\t     * Paper.path\n\t     [ method ]\n\t     **\n\t     * Creates a `<path>` element using the given string as the path's definition\n\t     - pathString (string) #optional path string in SVG format\n\t     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n\t     | \"M10,20L30,40\"\n\t     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n\t     *\n\t     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n\t     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n\t     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n\t     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n\t     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n\t     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n\t     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n\t     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n\t     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n\t     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n\t     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n\t     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n\t     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.\n\t     > Usage\n\t     | var c = paper.path(\"M10 10L90 90\");\n\t     | // draw a diagonal line:\n\t     | // move to 10,10, line to 90,90\n\t    \\*/\n\t    proto.path = function (d) {\n\t        var attr;\n\t        if (is(d, \"object\") && !is(d, \"array\")) {\n\t            attr = d;\n\t        } else if (d) {\n\t            attr = {d: d};\n\t        }\n\t        return this.el(\"path\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.g\n\t     [ method ]\n\t     **\n\t     * Creates a group element\n\t     **\n\t     - varargs (…) #optional elements to nest within the group\n\t     = (object) the `g` element\n\t     **\n\t     > Usage\n\t     | var c1 = paper.circle(),\n\t     |     c2 = paper.rect(),\n\t     |     g = paper.g(c2, c1); // note that the order of elements is different\n\t     * or\n\t     | var c1 = paper.circle(),\n\t     |     c2 = paper.rect(),\n\t     |     g = paper.g();\n\t     | g.add(c2, c1);\n\t    \\*/\n\t    /*\\\n\t     * Paper.group\n\t     [ method ]\n\t     **\n\t     * See @Paper.g\n\t    \\*/\n\t    proto.group = proto.g = function (first) {\n\t        var attr,\n\t            el = this.el(\"g\");\n\t        if (arguments.length == 1 && first && !first.type) {\n\t            el.attr(first);\n\t        } else if (arguments.length) {\n\t            el.add(Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.svg\n\t     [ method ]\n\t     **\n\t     * Creates a nested SVG element.\n\t     - x (number) @optional X of the element\n\t     - y (number) @optional Y of the element\n\t     - width (number) @optional width of the element\n\t     - height (number) @optional height of the element\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     **\n\t     = (object) the `svg` element\n\t     **\n\t    \\*/\n\t    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n\t        var attrs = {};\n\t        if (is(x, \"object\") && y == null) {\n\t            attrs = x;\n\t        } else {\n\t            if (x != null) {\n\t                attrs.x = x;\n\t            }\n\t            if (y != null) {\n\t                attrs.y = y;\n\t            }\n\t            if (width != null) {\n\t                attrs.width = width;\n\t            }\n\t            if (height != null) {\n\t                attrs.height = height;\n\t            }\n\t            if (vbx != null && vby != null && vbw != null && vbh != null) {\n\t                attrs.viewBox = [vbx, vby, vbw, vbh];\n\t            }\n\t        }\n\t        return this.el(\"svg\", attrs);\n\t    };\n\t    /*\\\n\t     * Paper.mask\n\t     [ method ]\n\t     **\n\t     * Equivalent in behaviour to @Paper.g, except it’s a mask.\n\t     **\n\t     = (object) the `mask` element\n\t     **\n\t    \\*/\n\t    proto.mask = function (first) {\n\t        var attr,\n\t            el = this.el(\"mask\");\n\t        if (arguments.length == 1 && first && !first.type) {\n\t            el.attr(first);\n\t        } else if (arguments.length) {\n\t            el.add(Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.ptrn\n\t     [ method ]\n\t     **\n\t     * Equivalent in behaviour to @Paper.g, except it’s a pattern.\n\t     - x (number) @optional X of the element\n\t     - y (number) @optional Y of the element\n\t     - width (number) @optional width of the element\n\t     - height (number) @optional height of the element\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     **\n\t     = (object) the `pattern` element\n\t     **\n\t    \\*/\n\t    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n\t        if (is(x, \"object\")) {\n\t            var attr = x;\n\t        } else {\n\t            attr = {patternUnits: \"userSpaceOnUse\"};\n\t            if (x) {\n\t                attr.x = x;\n\t            }\n\t            if (y) {\n\t                attr.y = y;\n\t            }\n\t            if (width != null) {\n\t                attr.width = width;\n\t            }\n\t            if (height != null) {\n\t                attr.height = height;\n\t            }\n\t            if (vx != null && vy != null && vw != null && vh != null) {\n\t                attr.viewBox = [vx, vy, vw, vh];\n\t            } else {\n\t                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n\t            }\n\t        }\n\t        return this.el(\"pattern\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.use\n\t     [ method ]\n\t     **\n\t     * Creates a <use> element.\n\t     - id (string) @optional id of element to link\n\t     * or\n\t     - id (Element) @optional element to link\n\t     **\n\t     = (object) the `use` element\n\t     **\n\t    \\*/\n\t    proto.use = function (id) {\n\t        if (id != null) {\n\t            if (id instanceof Element) {\n\t                if (!id.attr(\"id\")) {\n\t                    id.attr({id: Snap._.id(id)});\n\t                }\n\t                id = id.attr(\"id\");\n\t            }\n\t            if (String(id).charAt() == \"#\") {\n\t                id = id.substring(1);\n\t            }\n\t            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n\t        } else {\n\t            return Element.prototype.use.call(this);\n\t        }\n\t    };\n\t    /*\\\n\t     * Paper.symbol\n\t     [ method ]\n\t     **\n\t     * Creates a <symbol> element.\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     = (object) the `symbol` element\n\t     **\n\t    \\*/\n\t    proto.symbol = function (vx, vy, vw, vh) {\n\t        var attr = {};\n\t        if (vx != null && vy != null && vw != null && vh != null) {\n\t            attr.viewBox = [vx, vy, vw, vh];\n\t        }\n\t\n\t        return this.el(\"symbol\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.text\n\t     [ method ]\n\t     **\n\t     * Draws a text string\n\t     **\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n\t     = (object) the `text` element\n\t     **\n\t     > Usage\n\t     | var t1 = paper.text(50, 50, \"Snap\");\n\t     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n\t     | // Text path usage\n\t     | t1.attr({textpath: \"M10,10L100,100\"});\n\t     | // or\n\t     | var pth = paper.path(\"M10,10L100,100\");\n\t     | t1.attr({textpath: pth});\n\t    \\*/\n\t    proto.text = function (x, y, text) {\n\t        var attr = {};\n\t        if (is(x, \"object\")) {\n\t            attr = x;\n\t        } else if (x != null) {\n\t            attr = {\n\t                x: x,\n\t                y: y,\n\t                text: text || \"\"\n\t            };\n\t        }\n\t        return this.el(\"text\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.line\n\t     [ method ]\n\t     **\n\t     * Draws a line\n\t     **\n\t     - x1 (number) x coordinate position of the start\n\t     - y1 (number) y coordinate position of the start\n\t     - x2 (number) x coordinate position of the end\n\t     - y2 (number) y coordinate position of the end\n\t     = (object) the `line` element\n\t     **\n\t     > Usage\n\t     | var t1 = paper.line(50, 50, 100, 100);\n\t    \\*/\n\t    proto.line = function (x1, y1, x2, y2) {\n\t        var attr = {};\n\t        if (is(x1, \"object\")) {\n\t            attr = x1;\n\t        } else if (x1 != null) {\n\t            attr = {\n\t                x1: x1,\n\t                x2: x2,\n\t                y1: y1,\n\t                y2: y2\n\t            };\n\t        }\n\t        return this.el(\"line\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.polyline\n\t     [ method ]\n\t     **\n\t     * Draws a polyline\n\t     **\n\t     - points (array) array of points\n\t     * or\n\t     - varargs (…) points\n\t     = (object) the `polyline` element\n\t     **\n\t     > Usage\n\t     | var p1 = paper.polyline([10, 10, 100, 100]);\n\t     | var p2 = paper.polyline(10, 10, 100, 100);\n\t    \\*/\n\t    proto.polyline = function (points) {\n\t        if (arguments.length > 1) {\n\t            points = Array.prototype.slice.call(arguments, 0);\n\t        }\n\t        var attr = {};\n\t        if (is(points, \"object\") && !is(points, \"array\")) {\n\t            attr = points;\n\t        } else if (points != null) {\n\t            attr = {points: points};\n\t        }\n\t        return this.el(\"polyline\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.polygon\n\t     [ method ]\n\t     **\n\t     * Draws a polygon. See @Paper.polyline\n\t    \\*/\n\t    proto.polygon = function (points) {\n\t        if (arguments.length > 1) {\n\t            points = Array.prototype.slice.call(arguments, 0);\n\t        }\n\t        var attr = {};\n\t        if (is(points, \"object\") && !is(points, \"array\")) {\n\t            attr = points;\n\t        } else if (points != null) {\n\t            attr = {points: points};\n\t        }\n\t        return this.el(\"polygon\", attr);\n\t    };\n\t    // gradients\n\t    (function () {\n\t        var $ = Snap._.$;\n\t        // gradients' helpers\n\t        function Gstops() {\n\t            return this.selectAll(\"stop\");\n\t        }\n\t        function GaddStop(color, offset) {\n\t            var stop = $(\"stop\"),\n\t                attr = {\n\t                    offset: +offset + \"%\"\n\t                };\n\t            color = Snap.color(color);\n\t            attr[\"stop-color\"] = color.hex;\n\t            if (color.opacity < 1) {\n\t                attr[\"stop-opacity\"] = color.opacity;\n\t            }\n\t            $(stop, attr);\n\t            this.node.appendChild(stop);\n\t            return this;\n\t        }\n\t        function GgetBBox() {\n\t            if (this.type == \"linearGradient\") {\n\t                var x1 = $(this.node, \"x1\") || 0,\n\t                    x2 = $(this.node, \"x2\") || 1,\n\t                    y1 = $(this.node, \"y1\") || 0,\n\t                    y2 = $(this.node, \"y2\") || 0;\n\t                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n\t            } else {\n\t                var cx = this.node.cx || .5,\n\t                    cy = this.node.cy || .5,\n\t                    r = this.node.r || 0;\n\t                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n\t            }\n\t        }\n\t        function gradient(defs, str) {\n\t            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n\t                el;\n\t            if (!grad) {\n\t                return null;\n\t            }\n\t            grad.params.unshift(defs);\n\t            if (grad.type.toLowerCase() == \"l\") {\n\t                el = gradientLinear.apply(0, grad.params);\n\t            } else {\n\t                el = gradientRadial.apply(0, grad.params);\n\t            }\n\t            if (grad.type != grad.type.toLowerCase()) {\n\t                $(el.node, {\n\t                    gradientUnits: \"userSpaceOnUse\"\n\t                });\n\t            }\n\t            var stops = grad.stops,\n\t                len = stops.length,\n\t                start = 0,\n\t                j = 0;\n\t            function seed(i, end) {\n\t                var step = (end - start) / (i - j);\n\t                for (var k = j; k < i; k++) {\n\t                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n\t                }\n\t                j = i;\n\t                start = end;\n\t            }\n\t            len--;\n\t            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n\t                seed(i, stops[i].offset);\n\t            }\n\t            stops[len].offset = stops[len].offset || 100;\n\t            seed(len, stops[len].offset);\n\t            for (i = 0; i <= len; i++) {\n\t                var stop = stops[i];\n\t                el.addStop(stop.color, stop.offset);\n\t            }\n\t            return el;\n\t        }\n\t        function gradientLinear(defs, x1, y1, x2, y2) {\n\t            var el = Snap._.make(\"linearGradient\", defs);\n\t            el.stops = Gstops;\n\t            el.addStop = GaddStop;\n\t            el.getBBox = GgetBBox;\n\t            if (x1 != null) {\n\t                $(el.node, {\n\t                    x1: x1,\n\t                    y1: y1,\n\t                    x2: x2,\n\t                    y2: y2\n\t                });\n\t            }\n\t            return el;\n\t        }\n\t        function gradientRadial(defs, cx, cy, r, fx, fy) {\n\t            var el = Snap._.make(\"radialGradient\", defs);\n\t            el.stops = Gstops;\n\t            el.addStop = GaddStop;\n\t            el.getBBox = GgetBBox;\n\t            if (cx != null) {\n\t                $(el.node, {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r: r\n\t                });\n\t            }\n\t            if (fx != null && fy != null) {\n\t                $(el.node, {\n\t                    fx: fx,\n\t                    fy: fy\n\t                });\n\t            }\n\t            return el;\n\t        }\n\t        /*\\\n\t         * Paper.gradient\n\t         [ method ]\n\t         **\n\t         * Creates a gradient element\n\t         **\n\t         - gradient (string) gradient descriptor\n\t         > Gradient Descriptor\n\t         * The gradient descriptor is an expression formatted as\n\t         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n\t         * either linear or radial.  The uppercase `L` or `R` letters\n\t         * indicate absolute coordinates offset from the SVG surface.\n\t         * Lowercase `l` or `r` letters indicate coordinates\n\t         * calculated relative to the element to which the gradient is\n\t         * applied.  Coordinates specify a linear gradient vector as\n\t         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n\t         * `r` and optional `fx`, `fy` specifying a focal point away\n\t         * from the center of the circle. Specify `<colors>` as a list\n\t         * of dash-separated CSS color values.  Each color may be\n\t         * followed by a custom offset value, separated with a colon\n\t         * character.\n\t         > Examples\n\t         * Linear gradient, relative from top-left corner to bottom-right\n\t         * corner, from black through red to white:\n\t         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n\t         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n\t         * through red at 25% to white:\n\t         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n\t         * Radial gradient, relative from the center of the element with radius\n\t         * half the width, from black to white:\n\t         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n\t         * To apply the gradient:\n\t         | paper.circle(50, 50, 40).attr({\n\t         |     fill: g\n\t         | });\n\t         = (object) the `gradient` element\n\t        \\*/\n\t        proto.gradient = function (str) {\n\t            return gradient(this.defs, str);\n\t        };\n\t        proto.gradientLinear = function (x1, y1, x2, y2) {\n\t            return gradientLinear(this.defs, x1, y1, x2, y2);\n\t        };\n\t        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n\t            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n\t        };\n\t        /*\\\n\t         * Paper.toString\n\t         [ method ]\n\t         **\n\t         * Returns SVG code for the @Paper\n\t         = (string) SVG code for the @Paper\n\t        \\*/\n\t        proto.toString = function () {\n\t            var doc = this.node.ownerDocument,\n\t                f = doc.createDocumentFragment(),\n\t                d = doc.createElement(\"div\"),\n\t                svg = this.node.cloneNode(true),\n\t                res;\n\t            f.appendChild(d);\n\t            d.appendChild(svg);\n\t            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n\t            res = d.innerHTML;\n\t            f.removeChild(f.firstChild);\n\t            return res;\n\t        };\n\t        /*\\\n\t         * Paper.toDataURL\n\t         [ method ]\n\t         **\n\t         * Returns SVG code for the @Paper as Data URI string.\n\t         = (string) Data URI string\n\t        \\*/\n\t        proto.toDataURL = function () {\n\t            if (window && window.btoa) {\n\t                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n\t            }\n\t        };\n\t        /*\\\n\t         * Paper.clear\n\t         [ method ]\n\t         **\n\t         * Removes all child nodes of the paper, except <defs>.\n\t        \\*/\n\t        proto.clear = function () {\n\t            var node = this.node.firstChild,\n\t                next;\n\t            while (node) {\n\t                next = node.nextSibling;\n\t                if (node.tagName != \"defs\") {\n\t                    node.parentNode.removeChild(node);\n\t                } else {\n\t                    proto.clear.call({node: node});\n\t                }\n\t                node = next;\n\t            }\n\t        };\n\t    }());\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t        is = Snap.is,\n\t        clone = Snap._.clone,\n\t        has = \"hasOwnProperty\",\n\t        p2s = /,?([a-z]),?/gi,\n\t        toFloat = parseFloat,\n\t        math = Math,\n\t        PI = math.PI,\n\t        mmin = math.min,\n\t        mmax = math.max,\n\t        pow = math.pow,\n\t        abs = math.abs;\n\t    function paths(ps) {\n\t        var p = paths.ps = paths.ps || {};\n\t        if (p[ps]) {\n\t            p[ps].sleep = 100;\n\t        } else {\n\t            p[ps] = {\n\t                sleep: 100\n\t            };\n\t        }\n\t        setTimeout(function () {\n\t            for (var key in p) if (p[has](key) && key != ps) {\n\t                p[key].sleep--;\n\t                !p[key].sleep && delete p[key];\n\t            }\n\t        });\n\t        return p[ps];\n\t    }\n\t    function box(x, y, width, height) {\n\t        if (x == null) {\n\t            x = y = width = height = 0;\n\t        }\n\t        if (y == null) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            x = x.x;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            w: width,\n\t            height: height,\n\t            h: height,\n\t            x2: x + width,\n\t            y2: y + height,\n\t            cx: x + width / 2,\n\t            cy: y + height / 2,\n\t            r1: math.min(width, height) / 2,\n\t            r2: math.max(width, height) / 2,\n\t            r0: math.sqrt(width * width + height * height) / 2,\n\t            path: rectPath(x, y, width, height),\n\t            vb: [x, y, width, height].join(\" \")\n\t        };\n\t    }\n\t    function toString() {\n\t        return this.join(\",\").replace(p2s, \"$1\");\n\t    }\n\t    function pathClone(pathArray) {\n\t        var res = clone(pathArray);\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n\t        if (length == null) {\n\t            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n\t        } else {\n\t            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n\t                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n\t        }\n\t    }\n\t    function getLengthFactory(istotal, subpath) {\n\t        function O(val) {\n\t            return +(+val).toFixed(3);\n\t        }\n\t        return Snap._.cacher(function (path, length, onlystart) {\n\t            if (path instanceof Element) {\n\t                path = path.attr(\"d\");\n\t            }\n\t            path = path2curve(path);\n\t            var x, y, p, l, sp = \"\", subpaths = {}, point,\n\t                len = 0;\n\t            for (var i = 0, ii = path.length; i < ii; i++) {\n\t                p = path[i];\n\t                if (p[0] == \"M\") {\n\t                    x = +p[1];\n\t                    y = +p[2];\n\t                } else {\n\t                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                    if (len + l > length) {\n\t                        if (subpath && !subpaths.start) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            sp += [\n\t                                \"C\" + O(point.start.x),\n\t                                O(point.start.y),\n\t                                O(point.m.x),\n\t                                O(point.m.y),\n\t                                O(point.x),\n\t                                O(point.y)\n\t                            ];\n\t                            if (onlystart) {return sp;}\n\t                            subpaths.start = sp;\n\t                            sp = [\n\t                                \"M\" + O(point.x),\n\t                                O(point.y) + \"C\" + O(point.n.x),\n\t                                O(point.n.y),\n\t                                O(point.end.x),\n\t                                O(point.end.y),\n\t                                O(p[5]),\n\t                                O(p[6])\n\t                            ].join();\n\t                            len += l;\n\t                            x = +p[5];\n\t                            y = +p[6];\n\t                            continue;\n\t                        }\n\t                        if (!istotal && !subpath) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            return point;\n\t                        }\n\t                    }\n\t                    len += l;\n\t                    x = +p[5];\n\t                    y = +p[6];\n\t                }\n\t                sp += p.shift() + p;\n\t            }\n\t            subpaths.end = sp;\n\t            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n\t            return point;\n\t        }, null, Snap._.clone);\n\t    }\n\t    var getTotalLength = getLengthFactory(1),\n\t        getPointAtLength = getLengthFactory(),\n\t        getSubpathsAtLength = getLengthFactory(0, 1);\n\t    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t,\n\t            t13 = pow(t1, 3),\n\t            t12 = pow(t1, 2),\n\t            t2 = t * t,\n\t            t3 = t2 * t,\n\t            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n\t            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n\t            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n\t            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n\t            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n\t            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n\t            ax = t1 * p1x + t * c1x,\n\t            ay = t1 * p1y + t * c1y,\n\t            cx = t1 * c2x + t * p2x,\n\t            cy = t1 * c2y + t * p2y,\n\t            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n\t        // (mx > nx || my < ny) && (alpha += 180);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            m: {x: mx, y: my},\n\t            n: {x: nx, y: ny},\n\t            start: {x: ax, y: ay},\n\t            end: {x: cx, y: cy},\n\t            alpha: alpha\n\t        };\n\t    }\n\t    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t        if (!Snap.is(p1x, \"array\")) {\n\t            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n\t        }\n\t        var bbox = curveDim.apply(null, p1x);\n\t        return box(\n\t            bbox.min.x,\n\t            bbox.min.y,\n\t            bbox.max.x - bbox.min.x,\n\t            bbox.max.y - bbox.min.y\n\t        );\n\t    }\n\t    function isPointInsideBBox(bbox, x, y) {\n\t        return  x >= bbox.x &&\n\t                x <= bbox.x + bbox.width &&\n\t                y >= bbox.y &&\n\t                y <= bbox.y + bbox.height;\n\t    }\n\t    function isBBoxIntersect(bbox1, bbox2) {\n\t        bbox1 = box(bbox1);\n\t        bbox2 = box(bbox2);\n\t        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n\t            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n\t            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n\t            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n\t            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n\t            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n\t            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n\t            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n\t            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n\t                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n\t            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n\t                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n\t    }\n\t    function base3(t, p1, p2, p3, p4) {\n\t        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n\t            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n\t        return t * t2 - 3 * p1 + 3 * p2;\n\t    }\n\t    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n\t        if (z == null) {\n\t            z = 1;\n\t        }\n\t        z = z > 1 ? 1 : z < 0 ? 0 : z;\n\t        var z2 = z / 2,\n\t            n = 12,\n\t            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n\t            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n\t            sum = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var ct = z2 * Tvalues[i] + z2,\n\t                xbase = base3(ct, x1, x2, x3, x4),\n\t                ybase = base3(ct, y1, y2, y3, y4),\n\t                comb = xbase * xbase + ybase * ybase;\n\t            sum += Cvalues[i] * math.sqrt(comb);\n\t        }\n\t        return z2 * sum;\n\t    }\n\t    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n\t        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n\t            return;\n\t        }\n\t        var t = 1,\n\t            step = t / 2,\n\t            t2 = t - step,\n\t            l,\n\t            e = .01;\n\t        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        while (abs(l - ll) > e) {\n\t            step /= 2;\n\t            t2 += (l < ll ? 1 : -1) * step;\n\t            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        }\n\t        return t2;\n\t    }\n\t    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\t        if (\n\t            mmax(x1, x2) < mmin(x3, x4) ||\n\t            mmin(x1, x2) > mmax(x3, x4) ||\n\t            mmax(y1, y2) < mmin(y3, y4) ||\n\t            mmin(y1, y2) > mmax(y3, y4)\n\t        ) {\n\t            return;\n\t        }\n\t        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n\t            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n\t            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\t\n\t        if (!denominator) {\n\t            return;\n\t        }\n\t        var px = nx / denominator,\n\t            py = ny / denominator,\n\t            px2 = +px.toFixed(2),\n\t            py2 = +py.toFixed(2);\n\t        if (\n\t            px2 < +mmin(x1, x2).toFixed(2) ||\n\t            px2 > +mmax(x1, x2).toFixed(2) ||\n\t            px2 < +mmin(x3, x4).toFixed(2) ||\n\t            px2 > +mmax(x3, x4).toFixed(2) ||\n\t            py2 < +mmin(y1, y2).toFixed(2) ||\n\t            py2 > +mmax(y1, y2).toFixed(2) ||\n\t            py2 < +mmin(y3, y4).toFixed(2) ||\n\t            py2 > +mmax(y3, y4).toFixed(2)\n\t        ) {\n\t            return;\n\t        }\n\t        return {x: px, y: py};\n\t    }\n\t    function inter(bez1, bez2) {\n\t        return interHelper(bez1, bez2);\n\t    }\n\t    function interCount(bez1, bez2) {\n\t        return interHelper(bez1, bez2, 1);\n\t    }\n\t    function interHelper(bez1, bez2, justCount) {\n\t        var bbox1 = bezierBBox(bez1),\n\t            bbox2 = bezierBBox(bez2);\n\t        if (!isBBoxIntersect(bbox1, bbox2)) {\n\t            return justCount ? 0 : [];\n\t        }\n\t        var l1 = bezlen.apply(0, bez1),\n\t            l2 = bezlen.apply(0, bez2),\n\t            n1 = ~~(l1 / 8),\n\t            n2 = ~~(l2 / 8),\n\t            dots1 = [],\n\t            dots2 = [],\n\t            xy = {},\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0; i < n1 + 1; i++) {\n\t            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n\t            dots1.push({x: p.x, y: p.y, t: i / n1});\n\t        }\n\t        for (i = 0; i < n2 + 1; i++) {\n\t            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n\t            dots2.push({x: p.x, y: p.y, t: i / n2});\n\t        }\n\t        for (i = 0; i < n1; i++) {\n\t            for (var j = 0; j < n2; j++) {\n\t                var di = dots1[i],\n\t                    di1 = dots1[i + 1],\n\t                    dj = dots2[j],\n\t                    dj1 = dots2[j + 1],\n\t                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n\t                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n\t                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\t                if (is) {\n\t                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n\t                        continue;\n\t                    }\n\t                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n\t                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n\t                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\t                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n\t                        if (justCount) {\n\t                            res++;\n\t                        } else {\n\t                            res.push({\n\t                                x: is.x,\n\t                                y: is.y,\n\t                                t1: t1,\n\t                                t2: t2\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function pathIntersection(path1, path2) {\n\t        return interPathHelper(path1, path2);\n\t    }\n\t    function pathIntersectionNumber(path1, path2) {\n\t        return interPathHelper(path1, path2, 1);\n\t    }\n\t    function interPathHelper(path1, path2, justCount) {\n\t        path1 = path2curve(path1);\n\t        path2 = path2curve(path2);\n\t        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0, ii = path1.length; i < ii; i++) {\n\t            var pi = path1[i];\n\t            if (pi[0] == \"M\") {\n\t                x1 = x1m = pi[1];\n\t                y1 = y1m = pi[2];\n\t            } else {\n\t                if (pi[0] == \"C\") {\n\t                    bez1 = [x1, y1].concat(pi.slice(1));\n\t                    x1 = bez1[6];\n\t                    y1 = bez1[7];\n\t                } else {\n\t                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n\t                    x1 = x1m;\n\t                    y1 = y1m;\n\t                }\n\t                for (var j = 0, jj = path2.length; j < jj; j++) {\n\t                    var pj = path2[j];\n\t                    if (pj[0] == \"M\") {\n\t                        x2 = x2m = pj[1];\n\t                        y2 = y2m = pj[2];\n\t                    } else {\n\t                        if (pj[0] == \"C\") {\n\t                            bez2 = [x2, y2].concat(pj.slice(1));\n\t                            x2 = bez2[6];\n\t                            y2 = bez2[7];\n\t                        } else {\n\t                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n\t                            x2 = x2m;\n\t                            y2 = y2m;\n\t                        }\n\t                        var intr = interHelper(bez1, bez2, justCount);\n\t                        if (justCount) {\n\t                            res += intr;\n\t                        } else {\n\t                            for (var k = 0, kk = intr.length; k < kk; k++) {\n\t                                intr[k].segment1 = i;\n\t                                intr[k].segment2 = j;\n\t                                intr[k].bez1 = bez1;\n\t                                intr[k].bez2 = bez2;\n\t                            }\n\t                            res = res.concat(intr);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function isPointInsidePath(path, x, y) {\n\t        var bbox = pathBBox(path);\n\t        return isPointInsideBBox(bbox, x, y) &&\n\t               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n\t    }\n\t    function pathBBox(path) {\n\t        var pth = paths(path);\n\t        if (pth.bbox) {\n\t            return clone(pth.bbox);\n\t        }\n\t        if (!path) {\n\t            return box();\n\t        }\n\t        path = path2curve(path);\n\t        var x = 0,\n\t            y = 0,\n\t            X = [],\n\t            Y = [],\n\t            p;\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            p = path[i];\n\t            if (p[0] == \"M\") {\n\t                x = p[1];\n\t                y = p[2];\n\t                X.push(x);\n\t                Y.push(y);\n\t            } else {\n\t                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                X = X.concat(dim.min.x, dim.max.x);\n\t                Y = Y.concat(dim.min.y, dim.max.y);\n\t                x = p[5];\n\t                y = p[6];\n\t            }\n\t        }\n\t        var xmin = mmin.apply(0, X),\n\t            ymin = mmin.apply(0, Y),\n\t            xmax = mmax.apply(0, X),\n\t            ymax = mmax.apply(0, Y),\n\t            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n\t        pth.bbox = clone(bb);\n\t        return bb;\n\t    }\n\t    function rectPath(x, y, w, h, r) {\n\t        if (r) {\n\t            return [\n\t                [\"M\", +x + (+r), y],\n\t                [\"l\", w - r * 2, 0],\n\t                [\"a\", r, r, 0, 0, 1, r, r],\n\t                [\"l\", 0, h - r * 2],\n\t                [\"a\", r, r, 0, 0, 1, -r, r],\n\t                [\"l\", r * 2 - w, 0],\n\t                [\"a\", r, r, 0, 0, 1, -r, -r],\n\t                [\"l\", 0, r * 2 - h],\n\t                [\"a\", r, r, 0, 0, 1, r, -r],\n\t                [\"z\"]\n\t            ];\n\t        }\n\t        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    function ellipsePath(x, y, rx, ry, a) {\n\t        if (a == null && ry == null) {\n\t            ry = rx;\n\t        }\n\t        x = +x;\n\t        y = +y;\n\t        rx = +rx;\n\t        ry = +ry;\n\t        if (a != null) {\n\t            var rad = Math.PI / 180,\n\t                x1 = x + rx * Math.cos(-ry * rad),\n\t                x2 = x + rx * Math.cos(-a * rad),\n\t                y1 = y + rx * Math.sin(-ry * rad),\n\t                y2 = y + rx * Math.sin(-a * rad),\n\t                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n\t        } else {\n\t            res = [\n\t                [\"M\", x, y],\n\t                [\"m\", 0, -ry],\n\t                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n\t                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n\t                [\"z\"]\n\t            ];\n\t        }\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    var unit2px = Snap._unit2px,\n\t        getPath = {\n\t        path: function (el) {\n\t            return el.attr(\"path\");\n\t        },\n\t        circle: function (el) {\n\t            var attr = unit2px(el);\n\t            return ellipsePath(attr.cx, attr.cy, attr.r);\n\t        },\n\t        ellipse: function (el) {\n\t            var attr = unit2px(el);\n\t            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n\t        },\n\t        rect: function (el) {\n\t            var attr = unit2px(el);\n\t            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n\t        },\n\t        image: function (el) {\n\t            var attr = unit2px(el);\n\t            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n\t        },\n\t        line: function (el) {\n\t            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n\t        },\n\t        polyline: function (el) {\n\t            return \"M\" + el.attr(\"points\");\n\t        },\n\t        polygon: function (el) {\n\t            return \"M\" + el.attr(\"points\") + \"z\";\n\t        },\n\t        deflt: function (el) {\n\t            var bbox = el.node.getBBox();\n\t            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t        }\n\t    };\n\t    function pathToRelative(pathArray) {\n\t        var pth = paths(pathArray),\n\t            lowerCase = String.prototype.toLowerCase;\n\t        if (pth.rel) {\n\t            return pathClone(pth.rel);\n\t        }\n\t        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n\t            pathArray = Snap.parsePathString(pathArray);\n\t        }\n\t        var res = [],\n\t            x = 0,\n\t            y = 0,\n\t            mx = 0,\n\t            my = 0,\n\t            start = 0;\n\t        if (pathArray[0][0] == \"M\") {\n\t            x = pathArray[0][1];\n\t            y = pathArray[0][2];\n\t            mx = x;\n\t            my = y;\n\t            start++;\n\t            res.push([\"M\", x, y]);\n\t        }\n\t        for (var i = start, ii = pathArray.length; i < ii; i++) {\n\t            var r = res[i] = [],\n\t                pa = pathArray[i];\n\t            if (pa[0] != lowerCase.call(pa[0])) {\n\t                r[0] = lowerCase.call(pa[0]);\n\t                switch (r[0]) {\n\t                    case \"a\":\n\t                        r[1] = pa[1];\n\t                        r[2] = pa[2];\n\t                        r[3] = pa[3];\n\t                        r[4] = pa[4];\n\t                        r[5] = pa[5];\n\t                        r[6] = +(pa[6] - x).toFixed(3);\n\t                        r[7] = +(pa[7] - y).toFixed(3);\n\t                        break;\n\t                    case \"v\":\n\t                        r[1] = +(pa[1] - y).toFixed(3);\n\t                        break;\n\t                    case \"m\":\n\t                        mx = pa[1];\n\t                        my = pa[2];\n\t                    default:\n\t                        for (var j = 1, jj = pa.length; j < jj; j++) {\n\t                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n\t                        }\n\t                }\n\t            } else {\n\t                r = res[i] = [];\n\t                if (pa[0] == \"m\") {\n\t                    mx = pa[1] + x;\n\t                    my = pa[2] + y;\n\t                }\n\t                for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                    res[i][k] = pa[k];\n\t                }\n\t            }\n\t            var len = res[i].length;\n\t            switch (res[i][0]) {\n\t                case \"z\":\n\t                    x = mx;\n\t                    y = my;\n\t                    break;\n\t                case \"h\":\n\t                    x += +res[i][len - 1];\n\t                    break;\n\t                case \"v\":\n\t                    y += +res[i][len - 1];\n\t                    break;\n\t                default:\n\t                    x += +res[i][len - 2];\n\t                    y += +res[i][len - 1];\n\t            }\n\t        }\n\t        res.toString = toString;\n\t        pth.rel = pathClone(res);\n\t        return res;\n\t    }\n\t    function pathToAbsolute(pathArray) {\n\t        var pth = paths(pathArray);\n\t        if (pth.abs) {\n\t            return pathClone(pth.abs);\n\t        }\n\t        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n\t            pathArray = Snap.parsePathString(pathArray);\n\t        }\n\t        if (!pathArray || !pathArray.length) {\n\t            return [[\"M\", 0, 0]];\n\t        }\n\t        var res = [],\n\t            x = 0,\n\t            y = 0,\n\t            mx = 0,\n\t            my = 0,\n\t            start = 0,\n\t            pa0;\n\t        if (pathArray[0][0] == \"M\") {\n\t            x = +pathArray[0][1];\n\t            y = +pathArray[0][2];\n\t            mx = x;\n\t            my = y;\n\t            start++;\n\t            res[0] = [\"M\", x, y];\n\t        }\n\t        var crz = pathArray.length == 3 &&\n\t            pathArray[0][0] == \"M\" &&\n\t            pathArray[1][0].toUpperCase() == \"R\" &&\n\t            pathArray[2][0].toUpperCase() == \"Z\";\n\t        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n\t            res.push(r = []);\n\t            pa = pathArray[i];\n\t            pa0 = pa[0];\n\t            if (pa0 != pa0.toUpperCase()) {\n\t                r[0] = pa0.toUpperCase();\n\t                switch (r[0]) {\n\t                    case \"A\":\n\t                        r[1] = pa[1];\n\t                        r[2] = pa[2];\n\t                        r[3] = pa[3];\n\t                        r[4] = pa[4];\n\t                        r[5] = pa[5];\n\t                        r[6] = +pa[6] + x;\n\t                        r[7] = +pa[7] + y;\n\t                        break;\n\t                    case \"V\":\n\t                        r[1] = +pa[1] + y;\n\t                        break;\n\t                    case \"H\":\n\t                        r[1] = +pa[1] + x;\n\t                        break;\n\t                    case \"R\":\n\t                        var dots = [x, y].concat(pa.slice(1));\n\t                        for (var j = 2, jj = dots.length; j < jj; j++) {\n\t                            dots[j] = +dots[j] + x;\n\t                            dots[++j] = +dots[j] + y;\n\t                        }\n\t                        res.pop();\n\t                        res = res.concat(catmullRom2bezier(dots, crz));\n\t                        break;\n\t                    case \"O\":\n\t                        res.pop();\n\t                        dots = ellipsePath(x, y, pa[1], pa[2]);\n\t                        dots.push(dots[0]);\n\t                        res = res.concat(dots);\n\t                        break;\n\t                    case \"U\":\n\t                        res.pop();\n\t                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n\t                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n\t                        break;\n\t                    case \"M\":\n\t                        mx = +pa[1] + x;\n\t                        my = +pa[2] + y;\n\t                    default:\n\t                        for (j = 1, jj = pa.length; j < jj; j++) {\n\t                            r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                        }\n\t                }\n\t            } else if (pa0 == \"R\") {\n\t                dots = [x, y].concat(pa.slice(1));\n\t                res.pop();\n\t                res = res.concat(catmullRom2bezier(dots, crz));\n\t                r = [\"R\"].concat(pa.slice(-2));\n\t            } else if (pa0 == \"O\") {\n\t                res.pop();\n\t                dots = ellipsePath(x, y, pa[1], pa[2]);\n\t                dots.push(dots[0]);\n\t                res = res.concat(dots);\n\t            } else if (pa0 == \"U\") {\n\t                res.pop();\n\t                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n\t                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n\t            } else {\n\t                for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                    r[k] = pa[k];\n\t                }\n\t            }\n\t            pa0 = pa0.toUpperCase();\n\t            if (pa0 != \"O\") {\n\t                switch (r[0]) {\n\t                    case \"Z\":\n\t                        x = +mx;\n\t                        y = +my;\n\t                        break;\n\t                    case \"H\":\n\t                        x = r[1];\n\t                        break;\n\t                    case \"V\":\n\t                        y = r[1];\n\t                        break;\n\t                    case \"M\":\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                }\n\t            }\n\t        }\n\t        res.toString = toString;\n\t        pth.abs = pathClone(res);\n\t        return res;\n\t    }\n\t    function l2c(x1, y1, x2, y2) {\n\t        return [x1, y1, x2, y2, x2, y2];\n\t    }\n\t    function q2c(x1, y1, ax, ay, x2, y2) {\n\t        var _13 = 1 / 3,\n\t            _23 = 2 / 3;\n\t        return [\n\t                _13 * x1 + _23 * ax,\n\t                _13 * y1 + _23 * ay,\n\t                _13 * x2 + _23 * ax,\n\t                _13 * y2 + _23 * ay,\n\t                x2,\n\t                y2\n\t            ];\n\t    }\n\t    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t        // for more information of where this math came from visit:\n\t        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t        var _120 = PI * 120 / 180,\n\t            rad = PI / 180 * (+angle || 0),\n\t            res = [],\n\t            xy,\n\t            rotate = Snap._.cacher(function (x, y, rad) {\n\t                var X = x * math.cos(rad) - y * math.sin(rad),\n\t                    Y = x * math.sin(rad) + y * math.cos(rad);\n\t                return {x: X, y: Y};\n\t            });\n\t        if (!recursive) {\n\t            xy = rotate(x1, y1, -rad);\n\t            x1 = xy.x;\n\t            y1 = xy.y;\n\t            xy = rotate(x2, y2, -rad);\n\t            x2 = xy.x;\n\t            y2 = xy.y;\n\t            var cos = math.cos(PI / 180 * angle),\n\t                sin = math.sin(PI / 180 * angle),\n\t                x = (x1 - x2) / 2,\n\t                y = (y1 - y2) / 2;\n\t            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n\t            if (h > 1) {\n\t                h = math.sqrt(h);\n\t                rx = h * rx;\n\t                ry = h * ry;\n\t            }\n\t            var rx2 = rx * rx,\n\t                ry2 = ry * ry,\n\t                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n\t                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n\t                cx = k * rx * y / ry + (x1 + x2) / 2,\n\t                cy = k * -ry * x / rx + (y1 + y2) / 2,\n\t                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n\t                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\t\n\t            f1 = x1 < cx ? PI - f1 : f1;\n\t            f2 = x2 < cx ? PI - f2 : f2;\n\t            f1 < 0 && (f1 = PI * 2 + f1);\n\t            f2 < 0 && (f2 = PI * 2 + f2);\n\t            if (sweep_flag && f1 > f2) {\n\t                f1 = f1 - PI * 2;\n\t            }\n\t            if (!sweep_flag && f2 > f1) {\n\t                f2 = f2 - PI * 2;\n\t            }\n\t        } else {\n\t            f1 = recursive[0];\n\t            f2 = recursive[1];\n\t            cx = recursive[2];\n\t            cy = recursive[3];\n\t        }\n\t        var df = f2 - f1;\n\t        if (abs(df) > _120) {\n\t            var f2old = f2,\n\t                x2old = x2,\n\t                y2old = y2;\n\t            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t            x2 = cx + rx * math.cos(f2);\n\t            y2 = cy + ry * math.sin(f2);\n\t            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t        }\n\t        df = f2 - f1;\n\t        var c1 = math.cos(f1),\n\t            s1 = math.sin(f1),\n\t            c2 = math.cos(f2),\n\t            s2 = math.sin(f2),\n\t            t = math.tan(df / 4),\n\t            hx = 4 / 3 * rx * t,\n\t            hy = 4 / 3 * ry * t,\n\t            m1 = [x1, y1],\n\t            m2 = [x1 + hx * s1, y1 - hy * c1],\n\t            m3 = [x2 + hx * s2, y2 - hy * c2],\n\t            m4 = [x2, y2];\n\t        m2[0] = 2 * m1[0] - m2[0];\n\t        m2[1] = 2 * m1[1] - m2[1];\n\t        if (recursive) {\n\t            return [m2, m3, m4].concat(res);\n\t        } else {\n\t            res = [m2, m3, m4].concat(res).join().split(\",\");\n\t            var newres = [];\n\t            for (var i = 0, ii = res.length; i < ii; i++) {\n\t                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t            }\n\t            return newres;\n\t        }\n\t    }\n\t    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t;\n\t        return {\n\t            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n\t            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n\t        };\n\t    }\n\t\n\t    // Returns bounding box of cubic bezier curve.\n\t    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t    // Original version: NISHIO Hirokazu\n\t    // Modifications: https://github.com/timo22345\n\t    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n\t        var tvalues = [],\n\t            bounds = [[], []],\n\t            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\t        for (var i = 0; i < 2; ++i) {\n\t            if (i == 0) {\n\t                b = 6 * x0 - 12 * x1 + 6 * x2;\n\t                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t                c = 3 * x1 - 3 * x0;\n\t            } else {\n\t                b = 6 * y0 - 12 * y1 + 6 * y2;\n\t                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t                c = 3 * y1 - 3 * y0;\n\t            }\n\t            if (abs(a) < 1e-12) {\n\t                if (abs(b) < 1e-12) {\n\t                    continue;\n\t                }\n\t                t = -c / b;\n\t                if (0 < t && t < 1) {\n\t                    tvalues.push(t);\n\t                }\n\t                continue;\n\t            }\n\t            b2ac = b * b - 4 * c * a;\n\t            sqrtb2ac = math.sqrt(b2ac);\n\t            if (b2ac < 0) {\n\t                continue;\n\t            }\n\t            t1 = (-b + sqrtb2ac) / (2 * a);\n\t            if (0 < t1 && t1 < 1) {\n\t                tvalues.push(t1);\n\t            }\n\t            t2 = (-b - sqrtb2ac) / (2 * a);\n\t            if (0 < t2 && t2 < 1) {\n\t                tvalues.push(t2);\n\t            }\n\t        }\n\t\n\t        var x, y, j = tvalues.length,\n\t            jlen = j,\n\t            mt;\n\t        while (j--) {\n\t            t = tvalues[j];\n\t            mt = 1 - t;\n\t            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n\t            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n\t        }\n\t\n\t        bounds[0][jlen] = x0;\n\t        bounds[1][jlen] = y0;\n\t        bounds[0][jlen + 1] = x3;\n\t        bounds[1][jlen + 1] = y3;\n\t        bounds[0].length = bounds[1].length = jlen + 2;\n\t\n\t\n\t        return {\n\t          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n\t          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n\t        };\n\t    }\n\t\n\t    function path2curve(path, path2) {\n\t        var pth = !path2 && paths(path);\n\t        if (!path2 && pth.curve) {\n\t            return pathClone(pth.curve);\n\t        }\n\t        var p = pathToAbsolute(path),\n\t            p2 = path2 && pathToAbsolute(path2),\n\t            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t            processPath = function (path, d, pcom) {\n\t                var nx, ny;\n\t                if (!path) {\n\t                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n\t                }\n\t                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n\t                switch (path[0]) {\n\t                    case \"M\":\n\t                        d.X = path[1];\n\t                        d.Y = path[2];\n\t                        break;\n\t                    case \"A\":\n\t                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t                        break;\n\t                    case \"S\":\n\t                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n\t                            nx = d.x * 2 - d.bx;          // And reflect the previous\n\t                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n\t                        }\n\t                        else {                            // or some else or nothing\n\t                            nx = d.x;\n\t                            ny = d.y;\n\t                        }\n\t                        path = [\"C\", nx, ny].concat(path.slice(1));\n\t                        break;\n\t                    case \"T\":\n\t                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n\t                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n\t                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n\t                        }\n\t                        else {                            // or something else or nothing\n\t                            d.qx = d.x;\n\t                            d.qy = d.y;\n\t                        }\n\t                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                        break;\n\t                    case \"Q\":\n\t                        d.qx = path[1];\n\t                        d.qy = path[2];\n\t                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                        break;\n\t                    case \"L\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n\t                        break;\n\t                    case \"H\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n\t                        break;\n\t                    case \"V\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n\t                        break;\n\t                    case \"Z\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n\t                        break;\n\t                }\n\t                return path;\n\t            },\n\t            fixArc = function (pp, i) {\n\t                if (pp[i].length > 7) {\n\t                    pp[i].shift();\n\t                    var pi = pp[i];\n\t                    while (pi.length) {\n\t                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n\t                        p2 && (pcoms2[i] = \"A\"); // the same as above\n\t                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n\t                    }\n\t                    pp.splice(i, 1);\n\t                    ii = mmax(p.length, p2 && p2.length || 0);\n\t                }\n\t            },\n\t            fixM = function (path1, path2, a1, a2, i) {\n\t                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n\t                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n\t                    a1.bx = 0;\n\t                    a1.by = 0;\n\t                    a1.x = path1[i][1];\n\t                    a1.y = path1[i][2];\n\t                    ii = mmax(p.length, p2 && p2.length || 0);\n\t                }\n\t            },\n\t            pcoms1 = [], // path commands of original path p\n\t            pcoms2 = [], // path commands of original path p2\n\t            pfirst = \"\", // temporary holder for original path command\n\t            pcom = \"\"; // holder for previous path command of original path\n\t        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n\t            p[i] && (pfirst = p[i][0]); // save current path command\n\t\n\t            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n\t            {\n\t                pcoms1[i] = pfirst; // Save current path command\n\t                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n\t            }\n\t            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\t\n\t            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n\t            // which may produce multiple C:s\n\t            // so we have to make sure that C is also C in original path\n\t\n\t            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\t\n\t            if (p2) { // the same procedures is done to p2\n\t                p2[i] && (pfirst = p2[i][0]);\n\t                if (pfirst != \"C\") {\n\t                    pcoms2[i] = pfirst;\n\t                    i && (pcom = pcoms2[i - 1]);\n\t                }\n\t                p2[i] = processPath(p2[i], attrs2, pcom);\n\t\n\t                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n\t                    pcoms2[i] = \"C\";\n\t                }\n\t\n\t                fixArc(p2, i);\n\t            }\n\t            fixM(p, p2, attrs, attrs2, i);\n\t            fixM(p2, p, attrs2, attrs, i);\n\t            var seg = p[i],\n\t                seg2 = p2 && p2[i],\n\t                seglen = seg.length,\n\t                seg2len = p2 && seg2.length;\n\t            attrs.x = seg[seglen - 2];\n\t            attrs.y = seg[seglen - 1];\n\t            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n\t            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n\t            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n\t            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n\t            attrs2.x = p2 && seg2[seg2len - 2];\n\t            attrs2.y = p2 && seg2[seg2len - 1];\n\t        }\n\t        if (!p2) {\n\t            pth.curve = pathClone(p);\n\t        }\n\t        return p2 ? [p, p2] : p;\n\t    }\n\t    function mapPath(path, matrix) {\n\t        if (!matrix) {\n\t            return path;\n\t        }\n\t        var x, y, i, j, ii, jj, pathi;\n\t        path = path2curve(path);\n\t        for (i = 0, ii = path.length; i < ii; i++) {\n\t            pathi = path[i];\n\t            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n\t                x = matrix.x(pathi[j], pathi[j + 1]);\n\t                y = matrix.y(pathi[j], pathi[j + 1]);\n\t                pathi[j] = x;\n\t                pathi[j + 1] = y;\n\t            }\n\t        }\n\t        return path;\n\t    }\n\t\n\t    // http://schepers.cc/getting-to-the-point\n\t    function catmullRom2bezier(crp, z) {\n\t        var d = [];\n\t        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n\t            var p = [\n\t                        {x: +crp[i - 2], y: +crp[i - 1]},\n\t                        {x: +crp[i],     y: +crp[i + 1]},\n\t                        {x: +crp[i + 2], y: +crp[i + 3]},\n\t                        {x: +crp[i + 4], y: +crp[i + 5]}\n\t                    ];\n\t            if (z) {\n\t                if (!i) {\n\t                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n\t                } else if (iLen - 4 == i) {\n\t                    p[3] = {x: +crp[0], y: +crp[1]};\n\t                } else if (iLen - 2 == i) {\n\t                    p[2] = {x: +crp[0], y: +crp[1]};\n\t                    p[3] = {x: +crp[2], y: +crp[3]};\n\t                }\n\t            } else {\n\t                if (iLen - 4 == i) {\n\t                    p[3] = p[2];\n\t                } else if (!i) {\n\t                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n\t                }\n\t            }\n\t            d.push([\"C\",\n\t                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n\t                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n\t                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n\t                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n\t                  p[2].x,\n\t                  p[2].y\n\t            ]);\n\t        }\n\t\n\t        return d;\n\t    }\n\t\n\t    // export\n\t    Snap.path = paths;\n\t\n\t    /*\\\n\t     * Snap.path.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns the length of the given path in pixels\n\t     **\n\t     - path (string) SVG path string\n\t     **\n\t     = (number) length\n\t    \\*/\n\t    Snap.path.getTotalLength = getTotalLength;\n\t    /*\\\n\t     * Snap.path.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Returns the coordinates of the point located at the given length along the given path\n\t     **\n\t     - path (string) SVG path string\n\t     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate,\n\t     o     y: (number) y coordinate,\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    Snap.path.getPointAtLength = getPointAtLength;\n\t    /*\\\n\t     * Snap.path.getSubpath\n\t     [ method ]\n\t     **\n\t     * Returns the subpath of a given path between given start and end lengths\n\t     **\n\t     - path (string) SVG path string\n\t     - from (number) length, in pixels, from the start of the path to the start of the segment\n\t     - to (number) length, in pixels, from the start of the path to the end of the segment\n\t     **\n\t     = (string) path string definition for the segment\n\t    \\*/\n\t    Snap.path.getSubpath = function (path, from, to) {\n\t        if (this.getTotalLength(path) - to < 1e-6) {\n\t            return getSubpathsAtLength(path, from).end;\n\t        }\n\t        var a = getSubpathsAtLength(path, to, 1);\n\t        return from ? getSubpathsAtLength(a, from).end : a;\n\t    };\n\t    /*\\\n\t     * Element.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns the length of the path in pixels (only works for `path` elements)\n\t     = (number) length\n\t    \\*/\n\t    elproto.getTotalLength = function () {\n\t        if (this.node.getTotalLength) {\n\t            return this.node.getTotalLength();\n\t        }\n\t    };\n\t    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n\t    /*\\\n\t     * Element.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n\t     **\n\t     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate,\n\t     o     y: (number) y coordinate,\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    elproto.getPointAtLength = function (length) {\n\t        return getPointAtLength(this.attr(\"d\"), length);\n\t    };\n\t    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n\t    /*\\\n\t     * Element.getSubpath\n\t     [ method ]\n\t     **\n\t     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n\t     **\n\t     - from (number) length, in pixels, from the start of the path to the start of the segment\n\t     - to (number) length, in pixels, from the start of the path to the end of the segment\n\t     **\n\t     = (string) path string definition for the segment\n\t    \\*/\n\t    elproto.getSubpath = function (from, to) {\n\t        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n\t    };\n\t    Snap._.box = box;\n\t    /*\\\n\t     * Snap.path.findDotsAtSegment\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds dot coordinates on the given cubic beziér curve at the given t\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     - t (number) position on the curve (0..1)\n\t     = (object) point information in format:\n\t     o {\n\t     o     x: (number) x coordinate of the point,\n\t     o     y: (number) y coordinate of the point,\n\t     o     m: {\n\t     o         x: (number) x coordinate of the left anchor,\n\t     o         y: (number) y coordinate of the left anchor\n\t     o     },\n\t     o     n: {\n\t     o         x: (number) x coordinate of the right anchor,\n\t     o         y: (number) y coordinate of the right anchor\n\t     o     },\n\t     o     start: {\n\t     o         x: (number) x coordinate of the start of the curve,\n\t     o         y: (number) y coordinate of the start of the curve\n\t     o     },\n\t     o     end: {\n\t     o         x: (number) x coordinate of the end of the curve,\n\t     o         y: (number) y coordinate of the end of the curve\n\t     o     },\n\t     o     alpha: (number) angle of the curve derivative at the point\n\t     o }\n\t    \\*/\n\t    Snap.path.findDotsAtSegment = findDotsAtSegment;\n\t    /*\\\n\t     * Snap.path.bezierBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns the bounding box of a given cubic beziér curve\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     * or\n\t     - bez (array) array of six points for beziér curve\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box,\n\t     o     y: (number) y coordinate of the left top point of the box,\n\t     o     x2: (number) x coordinate of the right bottom point of the box,\n\t     o     y2: (number) y coordinate of the right bottom point of the box,\n\t     o     width: (number) width of the box,\n\t     o     height: (number) height of the box\n\t     o }\n\t    \\*/\n\t    Snap.path.bezierBBox = bezierBBox;\n\t    /*\\\n\t     * Snap.path.isPointInsideBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside bounding box\n\t     - bbox (string) bounding box\n\t     - x (string) x coordinate of the point\n\t     - y (string) y coordinate of the point\n\t     = (boolean) `true` if point is inside\n\t    \\*/\n\t    Snap.path.isPointInsideBBox = isPointInsideBBox;\n\t    Snap.closest = function (x, y, X, Y) {\n\t        var r = 100,\n\t            b = box(x - r / 2, y - r / 2, r, r),\n\t            inside = [],\n\t            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n\t                return {\n\t                    x: X[i].x,\n\t                    y: X[i].y\n\t                };\n\t            } : function (i) {\n\t                return {\n\t                    x: X[i],\n\t                    y: Y[i]\n\t                };\n\t            },\n\t            found = 0;\n\t        while (r <= 1e6 && !found) {\n\t            for (var i = 0, ii = X.length; i < ii; i++) {\n\t                var xy = getter(i);\n\t                if (isPointInsideBBox(b, xy.x, xy.y)) {\n\t                    found++;\n\t                    inside.push(xy);\n\t                    break;\n\t                }\n\t            }\n\t            if (!found) {\n\t                r *= 2;\n\t                b = box(x - r / 2, y - r / 2, r, r)\n\t            }\n\t        }\n\t        if (r == 1e6) {\n\t            return;\n\t        }\n\t        var len = Infinity,\n\t            res;\n\t        for (i = 0, ii = inside.length; i < ii; i++) {\n\t            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n\t            if (len > l) {\n\t                len = l;\n\t                inside[i].len = l;\n\t                res = inside[i];\n\t            }\n\t        }\n\t        return res;\n\t    };\n\t    /*\\\n\t     * Snap.path.isBBoxIntersect\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if two bounding boxes intersect\n\t     - bbox1 (string) first bounding box\n\t     - bbox2 (string) second bounding box\n\t     = (boolean) `true` if bounding boxes intersect\n\t    \\*/\n\t    Snap.path.isBBoxIntersect = isBBoxIntersect;\n\t    /*\\\n\t     * Snap.path.intersection\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds intersections of two paths\n\t     - path1 (string) path string\n\t     - path2 (string) path string\n\t     = (array) dots of intersection\n\t     o [\n\t     o     {\n\t     o         x: (number) x coordinate of the point,\n\t     o         y: (number) y coordinate of the point,\n\t     o         t1: (number) t value for segment of path1,\n\t     o         t2: (number) t value for segment of path2,\n\t     o         segment1: (number) order number for segment of path1,\n\t     o         segment2: (number) order number for segment of path2,\n\t     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,\n\t     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n\t     o     }\n\t     o ]\n\t    \\*/\n\t    Snap.path.intersection = pathIntersection;\n\t    Snap.path.intersectionNumber = pathIntersectionNumber;\n\t    /*\\\n\t     * Snap.path.isPointInside\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside a given closed path.\n\t     *\n\t     * Note: fill mode doesn’t affect the result of this method.\n\t     - path (string) path string\n\t     - x (number) x of the point\n\t     - y (number) y of the point\n\t     = (boolean) `true` if point is inside the path\n\t    \\*/\n\t    Snap.path.isPointInside = isPointInsidePath;\n\t    /*\\\n\t     * Snap.path.getBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns the bounding box of a given path\n\t     - path (string) path string\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box,\n\t     o     y: (number) y coordinate of the left top point of the box,\n\t     o     x2: (number) x coordinate of the right bottom point of the box,\n\t     o     y2: (number) y coordinate of the right bottom point of the box,\n\t     o     width: (number) width of the box,\n\t     o     height: (number) height of the box\n\t     o }\n\t    \\*/\n\t    Snap.path.getBBox = pathBBox;\n\t    Snap.path.get = getPath;\n\t    /*\\\n\t     * Snap.path.toRelative\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path coordinates into relative values\n\t     - path (string) path string\n\t     = (array) path string\n\t    \\*/\n\t    Snap.path.toRelative = pathToRelative;\n\t    /*\\\n\t     * Snap.path.toAbsolute\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path coordinates into absolute values\n\t     - path (string) path string\n\t     = (array) path string\n\t    \\*/\n\t    Snap.path.toAbsolute = pathToAbsolute;\n\t    /*\\\n\t     * Snap.path.toCubic\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to a new path where all segments are cubic beziér curves\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments\n\t    \\*/\n\t    Snap.path.toCubic = path2curve;\n\t    /*\\\n\t     * Snap.path.map\n\t     [ method ]\n\t     **\n\t     * Transform the path string with the given matrix\n\t     - path (string) path string\n\t     - matrix (object) see @Matrix\n\t     = (string) transformed path string\n\t    \\*/\n\t    Snap.path.map = mapPath;\n\t    Snap.path.toString = toString;\n\t    Snap.path.clone = pathClone;\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var mmax = Math.max,\n\t        mmin = Math.min;\n\t\n\t    // Set\n\t    var Set = function (items) {\n\t        this.items = [];\n\t\tthis.bindings = {};\n\t        this.length = 0;\n\t        this.type = \"set\";\n\t        if (items) {\n\t            for (var i = 0, ii = items.length; i < ii; i++) {\n\t                if (items[i]) {\n\t                    this[this.items.length] = this.items[this.items.length] = items[i];\n\t                    this.length++;\n\t                }\n\t            }\n\t        }\n\t    },\n\t    setproto = Set.prototype;\n\t    /*\\\n\t     * Set.push\n\t     [ method ]\n\t     **\n\t     * Adds each argument to the current set\n\t     = (object) original element\n\t    \\*/\n\t    setproto.push = function () {\n\t        var item,\n\t            len;\n\t        for (var i = 0, ii = arguments.length; i < ii; i++) {\n\t            item = arguments[i];\n\t            if (item) {\n\t                len = this.items.length;\n\t                this[len] = this.items[len] = item;\n\t                this.length++;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.pop\n\t     [ method ]\n\t     **\n\t     * Removes last element and returns it\n\t     = (object) element\n\t    \\*/\n\t    setproto.pop = function () {\n\t        this.length && delete this[this.length--];\n\t        return this.items.pop();\n\t    };\n\t    /*\\\n\t     * Set.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element in the set\n\t     *\n\t     * If the function returns `false`, the loop stops running.\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.forEach = function (callback, thisArg) {\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            if (callback.call(thisArg, this.items[i], i) === false) {\n\t                return this;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.animate\n\t     [ method ]\n\t     **\n\t     * Animates each element in set in sync.\n\t     *\n\t     **\n\t     - attrs (object) key-value pairs of destination attributes\n\t     - duration (number) duration of the animation in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function that executes when the animation ends\n\t     * or\n\t     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n\t     > Usage\n\t     | // animate all elements in set to radius 10\n\t     | set.animate({r: 10}, 500, mina.easein);\n\t     | // or\n\t     | // animate first element to radius 10, but second to radius 20 and in different time\n\t     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n\t     = (Element) the current element\n\t    \\*/\n\t    setproto.animate = function (attrs, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        if (attrs instanceof Snap._.Animation) {\n\t            callback = attrs.callback;\n\t            easing = attrs.easing;\n\t            ms = easing.dur;\n\t            attrs = attrs.attr;\n\t        }\n\t        var args = arguments;\n\t        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n\t            var each = true;\n\t        }\n\t        var begin,\n\t            handler = function () {\n\t                if (begin) {\n\t                    this.b = begin;\n\t                } else {\n\t                    begin = this.b;\n\t                }\n\t            },\n\t            cb = 0,\n\t            set = this,\n\t            callbacker = callback && function () {\n\t                if (++cb == set.length) {\n\t                    callback.call(this);\n\t                }\n\t            };\n\t        return this.forEach(function (el, i) {\n\t            eve.once(\"snap.animcreated.\" + el.id, handler);\n\t            if (each) {\n\t                args[i] && el.animate.apply(el, args[i]);\n\t            } else {\n\t                el.animate(attrs, ms, easing, callbacker);\n\t            }\n\t        });\n\t    };\n\t    setproto.remove = function () {\n\t        while (this.length) {\n\t            this.pop().remove();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.bind\n\t     [ method ]\n\t     **\n\t     * Specifies how to handle a specific attribute when applied\n\t     * to a set.\n\t     *\n\t     **\n\t     - attr (string) attribute name\n\t     - callback (function) function to run\n\t     * or\n\t     - attr (string) attribute name\n\t     - element (Element) specific element in the set to apply the attribute to\n\t     * or\n\t     - attr (string) attribute name\n\t     - element (Element) specific element in the set to apply the attribute to\n\t     - eattr (string) attribute on the element to bind the attribute to\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.bind = function (attr, a, b) {\n\t        var data = {};\n\t        if (typeof a == \"function\") {\n\t            this.bindings[attr] = a;\n\t        } else {\n\t            var aname = b || attr;\n\t            this.bindings[attr] = function (v) {\n\t                data[aname] = v;\n\t                a.attr(data);\n\t            };\n\t        }\n\t        return this;\n\t    };\n\t    setproto.attr = function (value) {\n\t        var unbound = {};\n\t        for (var k in value) {\n\t            if (this.bindings[k]) {\n\t                this.bindings[k](value[k]);\n\t            } else {\n\t                unbound[k] = value[k];\n\t            }\n\t        }\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            this.items[i].attr(unbound);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.clear\n\t     [ method ]\n\t     **\n\t     * Removes all elements from the set\n\t    \\*/\n\t    setproto.clear = function () {\n\t        while (this.length) {\n\t            this.pop();\n\t        }\n\t    };\n\t    /*\\\n\t     * Set.splice\n\t     [ method ]\n\t     **\n\t     * Removes range of elements from the set\n\t     **\n\t     - index (number) position of the deletion\n\t     - count (number) number of element to remove\n\t     - insertion… (object) #optional elements to insert\n\t     = (object) set elements that were deleted\n\t    \\*/\n\t    setproto.splice = function (index, count, insertion) {\n\t        index = index < 0 ? mmax(this.length + index, 0) : index;\n\t        count = mmax(0, mmin(this.length - index, count));\n\t        var tail = [],\n\t            todel = [],\n\t            args = [],\n\t            i;\n\t        for (i = 2; i < arguments.length; i++) {\n\t            args.push(arguments[i]);\n\t        }\n\t        for (i = 0; i < count; i++) {\n\t            todel.push(this[index + i]);\n\t        }\n\t        for (; i < this.length - index; i++) {\n\t            tail.push(this[index + i]);\n\t        }\n\t        var arglen = args.length;\n\t        for (i = 0; i < arglen + tail.length; i++) {\n\t            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n\t        }\n\t        i = this.items.length = this.length -= count - arglen;\n\t        while (this[i]) {\n\t            delete this[i++];\n\t        }\n\t        return new Set(todel);\n\t    };\n\t    /*\\\n\t     * Set.exclude\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     - element (object) element to remove\n\t     = (boolean) `true` if object was found and removed from the set\n\t    \\*/\n\t    setproto.exclude = function (el) {\n\t        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n\t            this.splice(i, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    setproto.insertAfter = function (el) {\n\t        var i = this.items.length;\n\t        while (i--) {\n\t            this.items[i].insertAfter(el);\n\t        }\n\t        return this;\n\t    };\n\t    setproto.getBBox = function () {\n\t        var x = [],\n\t            y = [],\n\t            x2 = [],\n\t            y2 = [];\n\t        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n\t            var box = this.items[i].getBBox();\n\t            x.push(box.x);\n\t            y.push(box.y);\n\t            x2.push(box.x + box.width);\n\t            y2.push(box.y + box.height);\n\t        }\n\t        x = mmin.apply(0, x);\n\t        y = mmin.apply(0, y);\n\t        x2 = mmax.apply(0, x2);\n\t        y2 = mmax.apply(0, y2);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            x2: x2,\n\t            y2: y2,\n\t            width: x2 - x,\n\t            height: y2 - y,\n\t            cx: x + (x2 - x) / 2,\n\t            cy: y + (y2 - y) / 2\n\t        };\n\t    };\n\t    setproto.clone = function (s) {\n\t        s = new Set;\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            s.push(this.items[i].clone());\n\t        }\n\t        return s;\n\t    };\n\t    setproto.toString = function () {\n\t        return \"Snap\\u2018s set\";\n\t    };\n\t    setproto.type = \"set\";\n\t    // export\n\t    Snap.Set = Set;\n\t    Snap.set = function () {\n\t        var set = new Set;\n\t        if (arguments.length) {\n\t            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return set;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var names = {},\n\t        reUnit = /[a-z]+$/i,\n\t        Str = String;\n\t    names.stroke = names.fill = \"colour\";\n\t    function getEmpty(item) {\n\t        var l = item[0];\n\t        switch (l.toLowerCase()) {\n\t            case \"t\": return [l, 0, 0];\n\t            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n\t            case \"r\": if (item.length == 4) {\n\t                return [l, 0, item[2], item[3]];\n\t            } else {\n\t                return [l, 0];\n\t            }\n\t            case \"s\": if (item.length == 5) {\n\t                return [l, 1, 1, item[3], item[4]];\n\t            } else if (item.length == 3) {\n\t                return [l, 1, 1];\n\t            } else {\n\t                return [l, 1];\n\t            }\n\t        }\n\t    }\n\t    function equaliseTransform(t1, t2, getBBox) {\n\t        t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n\t        t1 = Snap.parseTransformString(t1) || [];\n\t        t2 = Snap.parseTransformString(t2) || [];\n\t        var maxlength = Math.max(t1.length, t2.length),\n\t            from = [],\n\t            to = [],\n\t            i = 0, j, jj,\n\t            tt1, tt2;\n\t        for (; i < maxlength; i++) {\n\t            tt1 = t1[i] || getEmpty(t2[i]);\n\t            tt2 = t2[i] || getEmpty(tt1);\n\t            if ((tt1[0] != tt2[0]) ||\n\t                (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n\t                (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n\t                ) {\n\t                    t1 = Snap._.transform2matrix(t1, getBBox());\n\t                    t2 = Snap._.transform2matrix(t2, getBBox());\n\t                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n\t                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n\t                    break;\n\t            }\n\t            from[i] = [];\n\t            to[i] = [];\n\t            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n\t                j in tt1 && (from[i][j] = tt1[j]);\n\t                j in tt2 && (to[i][j] = tt2[j]);\n\t            }\n\t        }\n\t        return {\n\t            from: path2array(from),\n\t            to: path2array(to),\n\t            f: getPath(from)\n\t        };\n\t    }\n\t    function getNumber(val) {\n\t        return val;\n\t    }\n\t    function getUnit(unit) {\n\t        return function (val) {\n\t            return +val.toFixed(3) + unit;\n\t        };\n\t    }\n\t    function getViewBox(val) {\n\t        return val.join(\" \");\n\t    }\n\t    function getColour(clr) {\n\t        return Snap.rgb(clr[0], clr[1], clr[2]);\n\t    }\n\t    function getPath(path) {\n\t        var k = 0, i, ii, j, jj, out, a, b = [];\n\t        for (i = 0, ii = path.length; i < ii; i++) {\n\t            out = \"[\";\n\t            a = ['\"' + path[i][0] + '\"'];\n\t            for (j = 1, jj = path[i].length; j < jj; j++) {\n\t                a[j] = \"val[\" + (k++) + \"]\";\n\t            }\n\t            out += a + \"]\";\n\t            b[i] = out;\n\t        }\n\t        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n\t    }\n\t    function path2array(path) {\n\t        var out = [];\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            for (var j = 1, jj = path[i].length; j < jj; j++) {\n\t                out.push(path[i][j]);\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t    function isNumeric(obj) {\n\t        return isFinite(parseFloat(obj));\n\t    }\n\t    function arrayEqual(arr1, arr2) {\n\t        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n\t            return false;\n\t        }\n\t        return arr1.toString() == arr2.toString();\n\t    }\n\t    Element.prototype.equal = function (name, b) {\n\t        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n\t    };\n\t    eve.on(\"snap.util.equal\", function (name, b) {\n\t        var A, B, a = Str(this.attr(name) || \"\"),\n\t            el = this;\n\t        if (isNumeric(a) && isNumeric(b)) {\n\t            return {\n\t                from: parseFloat(a),\n\t                to: parseFloat(b),\n\t                f: getNumber\n\t            };\n\t        }\n\t        if (names[name] == \"colour\") {\n\t            A = Snap.color(a);\n\t            B = Snap.color(b);\n\t            return {\n\t                from: [A.r, A.g, A.b, A.opacity],\n\t                to: [B.r, B.g, B.b, B.opacity],\n\t                f: getColour\n\t            };\n\t        }\n\t        if (name == \"viewBox\") {\n\t            A = this.attr(name).vb.split(\" \").map(Number);\n\t            B = b.split(\" \").map(Number);\n\t            return {\n\t                from: A,\n\t                to: B,\n\t                f: getViewBox\n\t            };\n\t        }\n\t        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n\t            if (b instanceof Snap.Matrix) {\n\t                b = b.toTransformString();\n\t            }\n\t            if (!Snap._.rgTransform.test(b)) {\n\t                b = Snap._.svgTransform2string(b);\n\t            }\n\t            return equaliseTransform(a, b, function () {\n\t                return el.getBBox(1);\n\t            });\n\t        }\n\t        if (name == \"d\" || name == \"path\") {\n\t            A = Snap.path.toCubic(a, b);\n\t            return {\n\t                from: path2array(A[0]),\n\t                to: path2array(A[1]),\n\t                f: getPath(A[0])\n\t            };\n\t        }\n\t        if (name == \"points\") {\n\t            A = Str(a).split(Snap._.separator);\n\t            B = Str(b).split(Snap._.separator);\n\t            return {\n\t                from: A,\n\t                to: B,\n\t                f: function (val) { return val; }\n\t            };\n\t        }\n\t        var aUnit = a.match(reUnit),\n\t            bUnit = Str(b).match(reUnit);\n\t        if (aUnit && arrayEqual(aUnit, bUnit)) {\n\t            return {\n\t                from: parseFloat(a),\n\t                to: parseFloat(b),\n\t                f: getUnit(aUnit)\n\t            };\n\t        } else {\n\t            return {\n\t                from: this.asPX(name),\n\t                to: this.asPX(name, b),\n\t                f: getNumber\n\t            };\n\t        }\n\t    });\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t    has = \"hasOwnProperty\",\n\t    supportsTouch = \"createTouch\" in glob.doc,\n\t    events = [\n\t        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n\t        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n\t        \"touchcancel\"\n\t    ],\n\t    touchMap = {\n\t        mousedown: \"touchstart\",\n\t        mousemove: \"touchmove\",\n\t        mouseup: \"touchend\"\n\t    },\n\t    getScroll = function (xy, el) {\n\t        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n\t            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n\t        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n\t    },\n\t    preventDefault = function () {\n\t        this.returnValue = false;\n\t    },\n\t    preventTouch = function () {\n\t        return this.originalEvent.preventDefault();\n\t    },\n\t    stopPropagation = function () {\n\t        this.cancelBubble = true;\n\t    },\n\t    stopTouch = function () {\n\t        return this.originalEvent.stopPropagation();\n\t    },\n\t    addEvent = function (obj, type, fn, element) {\n\t        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n\t            f = function (e) {\n\t                var scrollY = getScroll(\"y\", element),\n\t                    scrollX = getScroll(\"x\", element);\n\t                if (supportsTouch && touchMap[has](type)) {\n\t                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n\t                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n\t                            var olde = e;\n\t                            e = e.targetTouches[i];\n\t                            e.originalEvent = olde;\n\t                            e.preventDefault = preventTouch;\n\t                            e.stopPropagation = stopTouch;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                var x = e.clientX + scrollX,\n\t                    y = e.clientY + scrollY;\n\t                return fn.call(element, e, x, y);\n\t            };\n\t\n\t        if (type !== realName) {\n\t            obj.addEventListener(type, f, false);\n\t        }\n\t\n\t        obj.addEventListener(realName, f, false);\n\t\n\t        return function () {\n\t            if (type !== realName) {\n\t                obj.removeEventListener(type, f, false);\n\t            }\n\t\n\t            obj.removeEventListener(realName, f, false);\n\t            return true;\n\t        };\n\t    },\n\t    drag = [],\n\t    dragMove = function (e) {\n\t        var x = e.clientX,\n\t            y = e.clientY,\n\t            scrollY = getScroll(\"y\"),\n\t            scrollX = getScroll(\"x\"),\n\t            dragi,\n\t            j = drag.length;\n\t        while (j--) {\n\t            dragi = drag[j];\n\t            if (supportsTouch) {\n\t                var i = e.touches && e.touches.length,\n\t                    touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                e.preventDefault();\n\t            }\n\t            var node = dragi.el.node,\n\t                o,\n\t                next = node.nextSibling,\n\t                parent = node.parentNode,\n\t                display = node.style.display;\n\t            // glob.win.opera && parent.removeChild(node);\n\t            // node.style.display = \"none\";\n\t            // o = dragi.el.paper.getElementByPoint(x, y);\n\t            // node.style.display = display;\n\t            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n\t            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n\t            x += scrollX;\n\t            y += scrollY;\n\t            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n\t        }\n\t    },\n\t    dragUp = function (e) {\n\t        Snap.unmousemove(dragMove).unmouseup(dragUp);\n\t        var i = drag.length,\n\t            dragi;\n\t        while (i--) {\n\t            dragi = drag[i];\n\t            dragi.el._drag = {};\n\t            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n\t            eve.off(\"snap.drag.*.\" + dragi.el.id);\n\t        }\n\t        drag = [];\n\t    };\n\t    /*\\\n\t     * Element.click\n\t     [ method ]\n\t     **\n\t     * Adds a click event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unclick\n\t     [ method ]\n\t     **\n\t     * Removes a click event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.dblclick\n\t     [ method ]\n\t     **\n\t     * Adds a double click event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.undblclick\n\t     [ method ]\n\t     **\n\t     * Removes a double click event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mousedown\n\t     [ method ]\n\t     **\n\t     * Adds a mousedown event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousedown\n\t     [ method ]\n\t     **\n\t     * Removes a mousedown event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mousemove\n\t     [ method ]\n\t     **\n\t     * Adds a mousemove event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousemove\n\t     [ method ]\n\t     **\n\t     * Removes a mousemove event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mouseout\n\t     [ method ]\n\t     **\n\t     * Adds a mouseout event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseout\n\t     [ method ]\n\t     **\n\t     * Removes a mouseout event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mouseover\n\t     [ method ]\n\t     **\n\t     * Adds a mouseover event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseover\n\t     [ method ]\n\t     **\n\t     * Removes a mouseover event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mouseup\n\t     [ method ]\n\t     **\n\t     * Adds a mouseup event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseup\n\t     [ method ]\n\t     **\n\t     * Removes a mouseup event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchstart\n\t     [ method ]\n\t     **\n\t     * Adds a touchstart event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchstart\n\t     [ method ]\n\t     **\n\t     * Removes a touchstart event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchmove\n\t     [ method ]\n\t     **\n\t     * Adds a touchmove event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchmove\n\t     [ method ]\n\t     **\n\t     * Removes a touchmove event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchend\n\t     [ method ]\n\t     **\n\t     * Adds a touchend event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchend\n\t     [ method ]\n\t     **\n\t     * Removes a touchend event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchcancel\n\t     [ method ]\n\t     **\n\t     * Adds a touchcancel event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchcancel\n\t     [ method ]\n\t     **\n\t     * Removes a touchcancel event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    for (var i = events.length; i--;) {\n\t        (function (eventName) {\n\t            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n\t                if (Snap.is(fn, \"function\")) {\n\t                    this.events = this.events || [];\n\t                    this.events.push({\n\t                        name: eventName,\n\t                        f: fn,\n\t                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n\t                    });\n\t                } else {\n\t                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n\t                        try {\n\t                            this.events[i].f.call(this);\n\t                        } catch (e) {}\n\t                    }\n\t                }\n\t                return this;\n\t            };\n\t            Snap[\"un\" + eventName] =\n\t            elproto[\"un\" + eventName] = function (fn) {\n\t                var events = this.events || [],\n\t                    l = events.length;\n\t                while (l--) if (events[l].name == eventName &&\n\t                               (events[l].f == fn || !fn)) {\n\t                    events[l].unbind();\n\t                    events.splice(l, 1);\n\t                    !events.length && delete this.events;\n\t                    return this;\n\t                }\n\t                return this;\n\t            };\n\t        })(events[i]);\n\t    }\n\t    /*\\\n\t     * Element.hover\n\t     [ method ]\n\t     **\n\t     * Adds hover event handlers to the element\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     - icontext (object) #optional context for hover in handler\n\t     - ocontext (object) #optional context for hover out handler\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n\t        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n\t    };\n\t    /*\\\n\t     * Element.unhover\n\t     [ method ]\n\t     **\n\t     * Removes hover event handlers from the element\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.unhover = function (f_in, f_out) {\n\t        return this.unmouseover(f_in).unmouseout(f_out);\n\t    };\n\t    var draggable = [];\n\t    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n\t    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n\t    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n\t    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n\t    /*\\\n\t     * Element.drag\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for an element's drag gesture\n\t     **\n\t     - onmove (function) handler for moving\n\t     - onstart (function) handler for drag start\n\t     - onend (function) handler for drag end\n\t     - mcontext (object) #optional context for moving handler\n\t     - scontext (object) #optional context for drag start handler\n\t     - econtext (object) #optional context for drag end handler\n\t     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start,\n\t     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element\n\t     * `drag.over.<id>` fires as well.\n\t     *\n\t     * Start event and start handler are called in specified context or in context of the element with following parameters:\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * Move event and move handler are called in specified context or in context of the element with following parameters:\n\t     o dx (number) shift by x from the start point\n\t     o dy (number) shift by y from the start point\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * End event and end handler are called in specified context or in context of the element with following parameters:\n\t     o event (object) DOM event object\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n\t        var el = this;\n\t        if (!arguments.length) {\n\t            var origTransform;\n\t            return el.drag(function (dx, dy) {\n\t                this.attr({\n\t                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n\t                });\n\t            }, function () {\n\t                origTransform = this.transform().local;\n\t            });\n\t        }\n\t        function start(e, x, y) {\n\t            (e.originalEvent || e).preventDefault();\n\t            el._drag.x = x;\n\t            el._drag.y = y;\n\t            el._drag.id = e.identifier;\n\t            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n\t            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n\t            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n\t            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n\t            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n\t            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n\t        }\n\t        function init(e, x, y) {\n\t            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n\t        }\n\t        eve.on(\"snap.draginit.\" + el.id, start);\n\t        el._drag = {};\n\t        draggable.push({el: el, start: start, init: init});\n\t        el.mousedown(init);\n\t        return el;\n\t    };\n\t    /*\n\t     * Element.onDragOver\n\t     [ method ]\n\t     **\n\t     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n\t     - f (function) handler for event, first argument would be the element you are dragging over\n\t    \\*/\n\t    // elproto.onDragOver = function (f) {\n\t    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n\t    // };\n\t    /*\\\n\t     * Element.undrag\n\t     [ method ]\n\t     **\n\t     * Removes all drag event handlers from the given element\n\t    \\*/\n\t    elproto.undrag = function () {\n\t        var i = draggable.length;\n\t        while (i--) if (draggable[i].el == this) {\n\t            this.unmousedown(draggable[i].init);\n\t            draggable.splice(i, 1);\n\t            eve.unbind(\"snap.drag.*.\" + this.id);\n\t            eve.unbind(\"snap.draginit.\" + this.id);\n\t        }\n\t        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n\t        return this;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t        pproto = Paper.prototype,\n\t        rgurl = /^\\s*url\\((.+)\\)/,\n\t        Str = String,\n\t        $ = Snap._.$;\n\t    Snap.filter = {};\n\t    /*\\\n\t     * Paper.filter\n\t     [ method ]\n\t     **\n\t     * Creates a `<filter>` element\n\t     **\n\t     - filstr (string) SVG fragment of filter provided as a string\n\t     = (object) @Element\n\t     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n\t     > Usage\n\t     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    pproto.filter = function (filstr) {\n\t        var paper = this;\n\t        if (paper.type != \"svg\") {\n\t            paper = paper.paper;\n\t        }\n\t        var f = Snap.parse(Str(filstr)),\n\t            id = Snap._.id(),\n\t            width = paper.node.offsetWidth,\n\t            height = paper.node.offsetHeight,\n\t            filter = $(\"filter\");\n\t        $(filter, {\n\t            id: id,\n\t            filterUnits: \"userSpaceOnUse\"\n\t        });\n\t        filter.appendChild(f.node);\n\t        paper.defs.appendChild(filter);\n\t        return new Element(filter);\n\t    };\n\t\n\t    eve.on(\"snap.util.getattr.filter\", function () {\n\t        eve.stop();\n\t        var p = $(this.node, \"filter\");\n\t        if (p) {\n\t            var match = Str(p).match(rgurl);\n\t            return match && Snap.select(match[1]);\n\t        }\n\t    });\n\t    eve.on(\"snap.util.attr.filter\", function (value) {\n\t        if (value instanceof Element && value.type == \"filter\") {\n\t            eve.stop();\n\t            var id = value.node.id;\n\t            if (!id) {\n\t                $(value.node, {id: value.id});\n\t                id = value.id;\n\t            }\n\t            $(this.node, {\n\t                filter: Snap.url(id)\n\t            });\n\t        }\n\t        if (!value || value == \"none\") {\n\t            eve.stop();\n\t            this.node.removeAttribute(\"filter\");\n\t        }\n\t    });\n\t    /*\\\n\t     * Snap.filter.blur\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the blur filter\n\t     **\n\t     - x (number) amount of horizontal blur, in pixels\n\t     - y (number) #optional amount of vertical blur, in pixels\n\t     = (string) filter representation\n\t     > Usage\n\t     | var f = paper.filter(Snap.filter.blur(5, 10)),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    Snap.filter.blur = function (x, y) {\n\t        if (x == null) {\n\t            x = 2;\n\t        }\n\t        var def = y == null ? x : [x, y];\n\t        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n\t            def: def\n\t        });\n\t    };\n\t    Snap.filter.blur.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.shadow\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the shadow filter\n\t     **\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - blur (number) #optional amount of blur\n\t     - color (string) #optional color of the shadow\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     * or\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - color (string) #optional color of the shadow\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     * which makes blur default to `4`. Or\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     = (string) filter representation\n\t     > Usage\n\t     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n\t        if (typeof blur == \"string\") {\n\t            color = blur;\n\t            opacity = color;\n\t            blur = 4;\n\t        }\n\t        if (typeof color != \"string\") {\n\t            opacity = color;\n\t            color = \"#000\";\n\t        }\n\t        color = color || \"#000\";\n\t        if (blur == null) {\n\t            blur = 4;\n\t        }\n\t        if (opacity == null) {\n\t            opacity = 1;\n\t        }\n\t        if (dx == null) {\n\t            dx = 0;\n\t            dy = 2;\n\t        }\n\t        if (dy == null) {\n\t            dy = dx;\n\t        }\n\t        color = Snap.color(color);\n\t        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n\t            color: color,\n\t            dx: dx,\n\t            dy: dy,\n\t            blur: blur,\n\t            opacity: opacity\n\t        });\n\t    };\n\t    Snap.filter.shadow.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.grayscale\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the grayscale filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.grayscale = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n\t            a: 0.2126 + 0.7874 * (1 - amount),\n\t            b: 0.7152 - 0.7152 * (1 - amount),\n\t            c: 0.0722 - 0.0722 * (1 - amount),\n\t            d: 0.2126 - 0.2126 * (1 - amount),\n\t            e: 0.7152 + 0.2848 * (1 - amount),\n\t            f: 0.0722 - 0.0722 * (1 - amount),\n\t            g: 0.2126 - 0.2126 * (1 - amount),\n\t            h: 0.0722 + 0.9278 * (1 - amount)\n\t        });\n\t    };\n\t    Snap.filter.grayscale.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.sepia\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the sepia filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.sepia = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n\t            a: 0.393 + 0.607 * (1 - amount),\n\t            b: 0.769 - 0.769 * (1 - amount),\n\t            c: 0.189 - 0.189 * (1 - amount),\n\t            d: 0.349 - 0.349 * (1 - amount),\n\t            e: 0.686 + 0.314 * (1 - amount),\n\t            f: 0.168 - 0.168 * (1 - amount),\n\t            g: 0.272 - 0.272 * (1 - amount),\n\t            h: 0.534 - 0.534 * (1 - amount),\n\t            i: 0.131 + 0.869 * (1 - amount)\n\t        });\n\t    };\n\t    Snap.filter.sepia.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.saturate\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the saturate filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.saturate = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n\t            amount: 1 - amount\n\t        });\n\t    };\n\t    Snap.filter.saturate.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.hueRotate\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the hue-rotate filter\n\t     **\n\t     - angle (number) angle of rotation\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.hueRotate = function (angle) {\n\t        angle = angle || 0;\n\t        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n\t            angle: angle\n\t        });\n\t    };\n\t    Snap.filter.hueRotate.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.invert\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the invert filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.invert = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n\t            amount: amount,\n\t            amount2: 1 - amount\n\t        });\n\t    };\n\t    Snap.filter.invert.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.brightness\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the brightness filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.brightness = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n\t            amount: amount\n\t        });\n\t    };\n\t    Snap.filter.brightness.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.contrast\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the contrast filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.contrast = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n\t            amount: amount,\n\t            amount2: .5 - amount / 2\n\t        });\n\t    };\n\t    Snap.filter.contrast.toString = function () {\n\t        return this();\n\t    };\n\t});\n\t\n\t// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var box = Snap._.box,\n\t        is = Snap.is,\n\t        firstLetter = /^[^a-z]*([tbmlrc])/i,\n\t        toString = function () {\n\t            return \"T\" + this.dx + \",\" + this.dy;\n\t        };\n\t    /*\\\n\t     * Element.getAlign\n\t     [ method ]\n\t     **\n\t     * Returns shift needed to align the element relatively to given element.\n\t     * If no elements specified, parent `<svg>` container will be used.\n\t     - el (object) @optional alignment element\n\t     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n\t     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n\t     > Usage\n\t     | el.transform(el.getAlign(el2, \"top\"));\n\t     * or\n\t     | var dy = el.getAlign(el2, \"top\").dy;\n\t    \\*/\n\t    Element.prototype.getAlign = function (el, way) {\n\t        if (way == null && is(el, \"string\")) {\n\t            way = el;\n\t            el = null;\n\t        }\n\t        el = el || this.paper;\n\t        var bx = el.getBBox ? el.getBBox() : box(el),\n\t            bb = this.getBBox(),\n\t            out = {};\n\t        way = way && way.match(firstLetter);\n\t        way = way ? way[1].toLowerCase() : \"c\";\n\t        switch (way) {\n\t            case \"t\":\n\t                out.dx = 0;\n\t                out.dy = bx.y - bb.y;\n\t            break;\n\t            case \"b\":\n\t                out.dx = 0;\n\t                out.dy = bx.y2 - bb.y2;\n\t            break;\n\t            case \"m\":\n\t                out.dx = 0;\n\t                out.dy = bx.cy - bb.cy;\n\t            break;\n\t            case \"l\":\n\t                out.dx = bx.x - bb.x;\n\t                out.dy = 0;\n\t            break;\n\t            case \"r\":\n\t                out.dx = bx.x2 - bb.x2;\n\t                out.dy = 0;\n\t            break;\n\t            default:\n\t                out.dx = bx.cx - bb.cx;\n\t                out.dy = 0;\n\t            break;\n\t        }\n\t        out.toString = toString;\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Element.align\n\t     [ method ]\n\t     **\n\t     * Aligns the element relatively to given one via transformation.\n\t     * If no elements specified, parent `<svg>` container will be used.\n\t     - el (object) @optional alignment element\n\t     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n\t     = (object) this element\n\t     > Usage\n\t     | el.align(el2, \"top\");\n\t     * or\n\t     | el.align(\"middle\");\n\t    \\*/\n\t    Element.prototype.align = function (el, way) {\n\t        return this.transform(\"...\" + this.getAlign(el, way));\n\t    };\n\t});\n\t\n\tmodule.exports = Snap\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 6a0c953562cd1df1a961.worker.js"," \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n \tvar canDefineProperty = false;\r\n \ttry {\r\n \t\tObject.defineProperty({}, \"x\", {\r\n \t\t\tget: function() {}\r\n \t\t});\r\n \t\tcanDefineProperty = true;\r\n \t} catch(x) {\r\n \t\t// IE will fail on defineProperty\r\n \t}\r\n \t\r\n \tvar hotApplyOnUpdate = true;\r\n \tvar hotCurrentHash = \"6a0c953562cd1df1a961\"; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentModuleData = {};\r\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n \t\r\n \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar me = installedModules[moduleId];\r\n \t\tif(!me) return __webpack_require__;\r\n \t\tvar fn = function(request) {\r\n \t\t\tif(me.hot.active) {\r\n \t\t\t\tif(installedModules[request]) {\r\n \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n \t\t\t\t\t\tme.children.push(request);\r\n \t\t\t\t} else hotCurrentParents = [moduleId];\r\n \t\t\t} else {\r\n \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n \t\t\t\thotCurrentParents = [];\r\n \t\t\t}\r\n \t\t\treturn __webpack_require__(request);\r\n \t\t};\r\n \t\tfor(var name in __webpack_require__) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n \t\t\t\tif(canDefineProperty) {\r\n \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n \t\t\t\t\t\treturn {\r\n \t\t\t\t\t\t\tconfigurable: true,\r\n \t\t\t\t\t\t\tenumerable: true,\r\n \t\t\t\t\t\t\tget: function() {\r\n \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n \t\t\t\t\t\t\t},\r\n \t\t\t\t\t\t\tset: function(value) {\r\n \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t};\r\n \t\t\t\t\t}(name)));\r\n \t\t\t\t} else {\r\n \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\tfunction ensure(chunkId, callback) {\r\n \t\t\tif(hotStatus === \"ready\")\r\n \t\t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotChunksLoading++;\r\n \t\t\t__webpack_require__.e(chunkId, function() {\r\n \t\t\t\ttry {\r\n \t\t\t\t\tcallback.call(null, fn);\r\n \t\t\t\t} finally {\r\n \t\t\t\t\tfinishChunkLoading();\r\n \t\t\t\t}\r\n \t\r\n \t\t\t\tfunction finishChunkLoading() {\r\n \t\t\t\t\thotChunksLoading--;\r\n \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\t\t\t\thotUpdateDownloaded();\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t});\r\n \t\t}\r\n \t\tif(canDefineProperty) {\r\n \t\t\tObject.defineProperty(fn, \"e\", {\r\n \t\t\t\tenumerable: true,\r\n \t\t\t\tvalue: ensure\r\n \t\t\t});\r\n \t\t} else {\r\n \t\t\tfn.e = ensure;\r\n \t\t}\r\n \t\treturn fn;\r\n \t}\r\n \t\r\n \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar hot = {\r\n \t\t\t// private stuff\r\n \t\t\t_acceptedDependencies: {},\r\n \t\t\t_declinedDependencies: {},\r\n \t\t\t_selfAccepted: false,\r\n \t\t\t_selfDeclined: false,\r\n \t\t\t_disposeHandlers: [],\r\n \t\r\n \t\t\t// Module API\r\n \t\t\tactive: true,\r\n \t\t\taccept: function(dep, callback) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfAccepted = true;\r\n \t\t\t\telse if(typeof dep === \"function\")\r\n \t\t\t\t\thot._selfAccepted = dep;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n \t\t\t\telse\r\n \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n \t\t\t},\r\n \t\t\tdecline: function(dep) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfDeclined = true;\r\n \t\t\t\telse if(typeof dep === \"number\")\r\n \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n \t\t\t\telse\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n \t\t\t},\r\n \t\t\tdispose: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\taddDisposeHandler: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\tremoveDisposeHandler: function(callback) {\r\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t// Management API\r\n \t\t\tcheck: hotCheck,\r\n \t\t\tapply: hotApply,\r\n \t\t\tstatus: function(l) {\r\n \t\t\t\tif(!l) return hotStatus;\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\taddStatusHandler: function(l) {\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\tremoveStatusHandler: function(l) {\r\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t//inherit from previous dispose call\r\n \t\t\tdata: hotCurrentModuleData[moduleId]\r\n \t\t};\r\n \t\treturn hot;\r\n \t}\r\n \t\r\n \tvar hotStatusHandlers = [];\r\n \tvar hotStatus = \"idle\";\r\n \t\r\n \tfunction hotSetStatus(newStatus) {\r\n \t\thotStatus = newStatus;\r\n \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n \t}\r\n \t\r\n \t// while downloading\r\n \tvar hotWaitingFiles = 0;\r\n \tvar hotChunksLoading = 0;\r\n \tvar hotWaitingFilesMap = {};\r\n \tvar hotRequestedFilesMap = {};\r\n \tvar hotAvailibleFilesMap = {};\r\n \tvar hotCallback;\r\n \t\r\n \t// The update info\r\n \tvar hotUpdate, hotUpdateNewHash;\r\n \t\r\n \tfunction toModuleId(id) {\r\n \t\tvar isNumber = (+id) + \"\" === id;\r\n \t\treturn isNumber ? +id : id;\r\n \t}\r\n \t\r\n \tfunction hotCheck(apply, callback) {\r\n \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n \t\tif(typeof apply === \"function\") {\r\n \t\t\thotApplyOnUpdate = false;\r\n \t\t\tcallback = apply;\r\n \t\t} else {\r\n \t\t\thotApplyOnUpdate = apply;\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\thotSetStatus(\"check\");\r\n \t\thotDownloadManifest(function(err, update) {\r\n \t\t\tif(err) return callback(err);\r\n \t\t\tif(!update) {\r\n \t\t\t\thotSetStatus(\"idle\");\r\n \t\t\t\tcallback(null, null);\r\n \t\t\t\treturn;\r\n \t\t\t}\r\n \t\r\n \t\t\thotRequestedFilesMap = {};\r\n \t\t\thotAvailibleFilesMap = {};\r\n \t\t\thotWaitingFilesMap = {};\r\n \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n \t\t\thotUpdateNewHash = update.h;\r\n \t\r\n \t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotCallback = callback;\r\n \t\t\thotUpdate = {};\r\n \t\t\tvar chunkId = 0;\r\n \t\t\t{ // eslint-disable-line no-lone-blocks\r\n \t\t\t\t/*globals chunkId */\r\n \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t}\r\n \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\thotUpdateDownloaded();\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n \t\t\treturn;\r\n \t\thotRequestedFilesMap[chunkId] = false;\r\n \t\tfor(var moduleId in moreModules) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n \t\t\thotUpdateDownloaded();\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotEnsureUpdateChunk(chunkId) {\r\n \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n \t\t\thotWaitingFilesMap[chunkId] = true;\r\n \t\t} else {\r\n \t\t\thotRequestedFilesMap[chunkId] = true;\r\n \t\t\thotWaitingFiles++;\r\n \t\t\thotDownloadUpdateChunk(chunkId);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotUpdateDownloaded() {\r\n \t\thotSetStatus(\"ready\");\r\n \t\tvar callback = hotCallback;\r\n \t\thotCallback = null;\r\n \t\tif(!callback) return;\r\n \t\tif(hotApplyOnUpdate) {\r\n \t\t\thotApply(hotApplyOnUpdate, callback);\r\n \t\t} else {\r\n \t\t\tvar outdatedModules = [];\r\n \t\t\tfor(var id in hotUpdate) {\r\n \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tcallback(null, outdatedModules);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotApply(options, callback) {\r\n \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n \t\tif(typeof options === \"function\") {\r\n \t\t\tcallback = options;\r\n \t\t\toptions = {};\r\n \t\t} else if(options && typeof options === \"object\") {\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t} else {\r\n \t\t\toptions = {};\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\r\n \t\tfunction getAffectedStuff(module) {\r\n \t\t\tvar outdatedModules = [module];\r\n \t\t\tvar outdatedDependencies = {};\r\n \t\r\n \t\t\tvar queue = outdatedModules.slice();\r\n \t\t\twhile(queue.length > 0) {\r\n \t\t\t\tvar moduleId = queue.pop();\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tif(!module || module.hot._selfAccepted)\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tif(module.hot._selfDeclined) {\r\n \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n \t\t\t\t}\r\n \t\t\t\tif(moduleId === 0) {\r\n \t\t\t\t\treturn;\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n \t\t\t\t\tvar parentId = module.parents[i];\r\n \t\t\t\t\tvar parent = installedModules[parentId];\r\n \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n \t\t\t\t\toutdatedModules.push(parentId);\r\n \t\t\t\t\tqueue.push(parentId);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\r\n \t\t\treturn [outdatedModules, outdatedDependencies];\r\n \t\t}\r\n \t\r\n \t\tfunction addAllToSet(a, b) {\r\n \t\t\tfor(var i = 0; i < b.length; i++) {\r\n \t\t\t\tvar item = b[i];\r\n \t\t\t\tif(a.indexOf(item) < 0)\r\n \t\t\t\t\ta.push(item);\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// at begin all updates modules are outdated\r\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n \t\tvar outdatedDependencies = {};\r\n \t\tvar outdatedModules = [];\r\n \t\tvar appliedUpdate = {};\r\n \t\tfor(var id in hotUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\tvar moduleId = toModuleId(id);\r\n \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n \t\t\t\tif(!result) {\r\n \t\t\t\t\tif(options.ignoreUnaccepted)\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n \t\t\t\t}\r\n \t\t\t\tif(result instanceof Error) {\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(result);\r\n \t\t\t\t}\r\n \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n \t\t\t\tfor(var moduleId in result[1]) {\r\n \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Store self accepted outdated modules to require them later by the module system\r\n \t\tvar outdatedSelfAcceptedModules = [];\r\n \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n \t\t\tvar moduleId = outdatedModules[i];\r\n \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n \t\t\t\toutdatedSelfAcceptedModules.push({\r\n \t\t\t\t\tmodule: moduleId,\r\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n \t\t\t\t});\r\n \t\t}\r\n \t\r\n \t\t// Now in \"dispose\" phase\r\n \t\thotSetStatus(\"dispose\");\r\n \t\tvar queue = outdatedModules.slice();\r\n \t\twhile(queue.length > 0) {\r\n \t\t\tvar moduleId = queue.pop();\r\n \t\t\tvar module = installedModules[moduleId];\r\n \t\t\tif(!module) continue;\r\n \t\r\n \t\t\tvar data = {};\r\n \t\r\n \t\t\t// Call dispose handlers\r\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n \t\t\t\tvar cb = disposeHandlers[j];\r\n \t\t\t\tcb(data);\r\n \t\t\t}\r\n \t\t\thotCurrentModuleData[moduleId] = data;\r\n \t\r\n \t\t\t// disable module (this disables requires from this module)\r\n \t\t\tmodule.hot.active = false;\r\n \t\r\n \t\t\t// remove module from cache\r\n \t\t\tdelete installedModules[moduleId];\r\n \t\r\n \t\t\t// remove \"parents\" references from all children\r\n \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n \t\t\t\tvar child = installedModules[module.children[j]];\r\n \t\t\t\tif(!child) continue;\r\n \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n \t\t\t\tif(idx >= 0) {\r\n \t\t\t\t\tchild.parents.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// remove outdated dependency from module children\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Not in \"apply\" phase\r\n \t\thotSetStatus(\"apply\");\r\n \t\r\n \t\thotCurrentHash = hotUpdateNewHash;\r\n \t\r\n \t\t// insert new code\r\n \t\tfor(var moduleId in appliedUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// call accept handlers\r\n \t\tvar error = null;\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tvar callbacks = [];\r\n \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n \t\t\t\t\tcallbacks.push(cb);\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n \t\t\t\t\tvar cb = callbacks[i];\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tcb(outdatedDependencies);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Load self accepted modules\r\n \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n \t\t\tvar moduleId = item.module;\r\n \t\t\thotCurrentParents = [moduleId];\r\n \t\t\ttry {\r\n \t\t\t\t__webpack_require__(moduleId);\r\n \t\t\t} catch(err) {\r\n \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\titem.errorHandler(err);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t} else if(!error)\r\n \t\t\t\t\terror = err;\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// handle errors in accept handlers and self accepted module load\r\n \t\tif(error) {\r\n \t\t\thotSetStatus(\"fail\");\r\n \t\t\treturn callback(error);\r\n \t\t}\r\n \t\r\n \t\thotSetStatus(\"idle\");\r\n \t\tcallback(null, outdatedModules);\r\n \t}\r\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false,\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: hotCurrentParents,\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6a0c953562cd1df1a961","import { rawPathsToClipperPaths, union, xor } from '../mesh';\n\n\nself.onmessage = (event) => {\n\n    const jobs = [];\n\n    let { settings, opIndex, op, geometry, openGeometry, tabGeometry, documents } = event.data;\n\n    const docsWithImages = []\n\n    function matchColor(filterColor, color) {\n        if (!filterColor)\n            return true;\n        if (!color)\n            return false;\n        return filterColor[0] == color[0] && filterColor[1] == color[1] && filterColor[2] == color[2] && filterColor[3] == color[3];\n    }\n\n    function examineDocTree(isTab, id) {\n        let doc = documents.find(d => d.id === id);\n        if (doc.rawPaths) {\n            jobs.push((cb) => {\n                if (isTab) {\n                    tabGeometry = union(tabGeometry, rawPathsToClipperPaths(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]));\n                } else if (matchColor(op.filterFillColor, doc.fillColor) && matchColor(op.filterStrokeColor, doc.strokeColor)) {\n                    let isClosed = false;\n                    for (let rawPath of doc.rawPaths)\n                        if (rawPath.length >= 4 && rawPath[0] == rawPath[rawPath.length - 2] && rawPath[1] == rawPath[rawPath.length - 1])\n                            isClosed = true;\n                    let clipperPaths = rawPathsToClipperPaths(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]);\n                    if (isClosed)\n                        geometry = xor(geometry, clipperPaths);\n                    else if (!op.filterFillColor)\n                        openGeometry = openGeometry.concat(clipperPaths);\n                }\n                cb()\n            })\n        }\n        if (doc.type === 'image' && !isTab) {\n            docsWithImages.push(doc)\n        }\n        for (let child of doc.children)\n            examineDocTree(isTab, child);\n    }\n    for (let id of op.documents)\n        examineDocTree(false, id);\n    for (let id of op.tabDocuments)\n        examineDocTree(true, id);\n\n    let chunk = 100 / jobs.length;\n    var percent = 0;\n\n    while (jobs.length) {\n        try {\n            let job = jobs.shift()\n            if (job) job(() => {\n                percent = percent + chunk\n                postMessage({ event: \"onProgress\", percent: parseInt(percent) })\n            });\n        } catch (error) {\n            console.error(error)\n            postMessage({ event: \"onError\", message: \"Something wrong has happened, sorry.\", level: \"error\", error: error.toString() })\n        }\n    }\n\n    postMessage({ event: \"onDone\", settings, opIndex, op, geometry, openGeometry, tabGeometry, docsWithImages })\n    self.close();\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/workers/cam-preflight.js","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * The following functions operate on \"Point\" or any \"Point like\" object with {x,y},\n * as defined by the {@link XY} type\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n * @module\n * @private\n */\n\n/**\n * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n * Any \"Point like\" object with <code>{x, y}</code> attributes is supported\n * to initialize the SweepContext polylines and points\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n *\n * poly2tri.js might add extra fields to the point objects when computing the\n * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions\n * with fields in the custom class.\n *\n * @example\n *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *\n * @typedef {Object} XY\n * @property {number} x - x coordinate\n * @property {number} y - y coordinate\n */\n\n\n/**\n * Point pretty printing : prints x and y coordinates.\n * @example\n *      xy.toStringBase({x:5, y:42})\n *      // → \"(5;42)\"\n * @protected\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toStringBase(p) {\n    return (\"(\" + p.x + \";\" + p.y + \")\");\n}\n\n/**\n * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n * else simply prints x and y coordinates.\n * @example\n *      xy.toString({x:5, y:42})\n *      // → \"(5;42)\"\n * @example\n *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n *      // → \"5:42\"\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toString(p) {\n    // Try a custom toString first, and fallback to own implementation if none\n    var s = p.toString();\n    return (s === '[object Object]' ? toStringBase(p) : s);\n}\n\n\n/**\n * Compare two points component-wise. Ordered by y axis first, then x axis.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,\n *         <code>&gt; 0</code> if <code>a &gt; b</code>, \n *         <code>0</code> otherwise.\n */\nfunction compare(a, b) {\n    if (a.y === b.y) {\n        return a.x - b.x;\n    } else {\n        return a.y - b.y;\n    }\n}\n\n/**\n * Test two Point objects for equality.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.\n */\nfunction equals(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\n\n\nmodule.exports = {\n    toString: toString,\n    toStringBase: toStringBase,\n    compare: compare,\n    equals: equals\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/xy.js\n// module id = 1\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:11 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\n\n// -------------------------------------------------------------------------Node\n\n/**\n * Advancing front node\n * @constructor\n * @private\n * @struct\n * @param {!XY} p - Point\n * @param {Triangle=} t triangle (optional)\n */\nvar Node = function(p, t) {\n    /** @type {XY} */\n    this.point = p;\n\n    /** @type {Triangle|null} */\n    this.triangle = t || null;\n\n    /** @type {Node|null} */\n    this.next = null;\n    /** @type {Node|null} */\n    this.prev = null;\n\n    /** @type {number} */\n    this.value = p.x;\n};\n\n// ---------------------------------------------------------------AdvancingFront\n/**\n * @constructor\n * @private\n * @struct\n * @param {Node} head\n * @param {Node} tail\n */\nvar AdvancingFront = function(head, tail) {\n    /** @type {Node} */\n    this.head_ = head;\n    /** @type {Node} */\n    this.tail_ = tail;\n    /** @type {Node} */\n    this.search_node_ = head;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.head = function() {\n    return this.head_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setHead = function(node) {\n    this.head_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setTail = function(node) {\n    this.tail_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.search = function() {\n    return this.search_node_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setSearch = function(node) {\n    this.search_node_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.findSearchNode = function(/*x*/) {\n    // TODO: implement BST index\n    return this.search_node_;\n};\n\n/**\n * @param {number} x value\n * @return {Node}\n */\nAdvancingFront.prototype.locateNode = function(x) {\n    var node = this.search_node_;\n\n    /* jshint boss:true */\n    if (x < node.value) {\n        while (node = node.prev) {\n            if (x >= node.value) {\n                this.search_node_ = node;\n                return node;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (x < node.value) {\n                this.search_node_ = node.prev;\n                return node.prev;\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @param {!XY} point - Point\n * @return {Node}\n */\nAdvancingFront.prototype.locatePoint = function(point) {\n    var px = point.x;\n    var node = this.findSearchNode(px);\n    var nx = node.point.x;\n\n    if (px === nx) {\n        // Here we are comparing point references, not values\n        if (point !== node.point) {\n            // We might have two nodes with same x value for a short time\n            if (point === node.prev.point) {\n                node = node.prev;\n            } else if (point === node.next.point) {\n                node = node.next;\n            } else {\n                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');\n            }\n        }\n    } else if (px < nx) {\n        /* jshint boss:true */\n        while (node = node.prev) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    }\n\n    if (node) {\n        this.search_node_ = node;\n    }\n    return node;\n};\n\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = AdvancingFront;\nmodule.exports.Node = Node;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/advancingfront.js\n// module id = 2\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Class added in the JavaScript version (was not present in the c++ version)\n */\n\nvar xy = require('./xy');\n\n/**\n * Custom exception class to indicate invalid Point values\n * @constructor\n * @public\n * @extends Error\n * @struct\n * @param {string=} message - error message\n * @param {Array.<XY>=} points - invalid points\n */\nvar PointError = function(message, points) {\n    this.name = \"PointError\";\n    /**\n     * Invalid points\n     * @public\n     * @type {Array.<XY>}\n     */\n    this.points = points = points || [];\n    /**\n     * Error message\n     * @public\n     * @type {string}\n     */\n    this.message = message || \"Invalid Points!\";\n    for (var i = 0; i < points.length; i++) {\n        this.message += \" \" + xy.toString(points[i]);\n    }\n};\nPointError.prototype = new Error();\nPointError.prototype.constructor = PointError;\n\n\nmodule.exports = PointError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/pointerror.js\n// module id = 3\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:10 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require(\"./xy\");\n\n\n// ---------------------------------------------------------------------Triangle\n/**\n * Triangle class.<br>\n * Triangle-based data structures are known to have better performance than\n * quad-edge structures.\n * See: J. Shewchuk, \"Triangle: Engineering a 2D Quality Mesh Generator and\n * Delaunay Triangulator\", \"Triangulations in CGAL\"\n *\n * @constructor\n * @struct\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n */\nvar Triangle = function(a, b, c) {\n    /**\n     * Triangle points\n     * @private\n     * @type {Array.<XY>}\n     */\n    this.points_ = [a, b, c];\n\n    /**\n     * Neighbor list\n     * @private\n     * @type {Array.<Triangle>}\n     */\n    this.neighbors_ = [null, null, null];\n\n    /**\n     * Has this triangle been marked as an interior triangle?\n     * @private\n     * @type {boolean}\n     */\n    this.interior_ = false;\n\n    /**\n     * Flags to determine if an edge is a Constrained edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.constrained_edge = [false, false, false];\n\n    /**\n     * Flags to determine if an edge is a Delauney edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.delaunay_edge = [false, false, false];\n};\n\nvar p2s = xy.toString;\n/**\n * For pretty printing ex. <code>\"[(5;42)(10;20)(21;30)]\"</code>.\n * @public\n * @return {string}\n */\nTriangle.prototype.toString = function() {\n    return (\"[\" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + \"]\");\n};\n\n/**\n * Get one vertice of the triangle.\n * The output triangles of a triangulation have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      // → \"number\"\n * @param {number} index - vertice index: 0, 1 or 2\n * @public\n * @returns {XY}\n */\nTriangle.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode Triangle#getPoint} instead\n */\nTriangle.prototype.GetPoint = Triangle.prototype.getPoint;\n\n/**\n * Get all 3 vertices of the triangle as an array\n * @public\n * @return {Array.<XY>}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nTriangle.prototype.getPoints = function() {\n    return this.points_;\n};\n\n/**\n * @private\n * @param {number} index\n * @returns {?Triangle}\n */\nTriangle.prototype.getNeighbor = function(index) {\n    return this.neighbors_[index];\n};\n\n/**\n * Test if this Triangle contains the Point object given as parameter as one of its vertices.\n * Only point references are compared, not values.\n * @public\n * @param {XY} point - point object with {x,y}\n * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,\n *         <code>false</code> otherwise.\n */\nTriangle.prototype.containsPoint = function(point) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    return (point === points[0] || point === points[1] || point === points[2]);\n};\n\n/**\n * Test if this Triangle contains the Edge object given as parameter as its\n * bounding edges. Only point references are compared, not values.\n * @private\n * @param {Edge} edge\n * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding\n *         edges, <code>false</code> otherwise.\n */\nTriangle.prototype.containsEdge = function(edge) {\n    return this.containsPoint(edge.p) && this.containsPoint(edge.q);\n};\n\n/**\n * Test if this Triangle contains the two Point objects given as parameters among its vertices.\n * Only point references are compared, not values.\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {boolean}\n */\nTriangle.prototype.containsPoints = function(p1, p2) {\n    return this.containsPoint(p1) && this.containsPoint(p2);\n};\n\n/**\n * Has this triangle been marked as an interior triangle?\n * @returns {boolean}\n */\nTriangle.prototype.isInterior = function() {\n    return this.interior_;\n};\n\n/**\n * Mark this triangle as an interior triangle\n * @private\n * @param {boolean} interior\n * @returns {Triangle} this\n */\nTriangle.prototype.setInterior = function(interior) {\n    this.interior_ = interior;\n    return this;\n};\n\n/**\n * Update neighbor pointers.\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @param {Triangle} t Triangle object.\n * @throws {Error} if can't find objects\n */\nTriangle.prototype.markNeighborPointers = function(p1, p2, t) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {\n        this.neighbors_[0] = t;\n    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {\n        this.neighbors_[1] = t;\n    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {\n        this.neighbors_[2] = t;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');\n    }\n};\n\n/**\n * Exhaustive search to update neighbor pointers\n * @private\n * @param {!Triangle} t\n */\nTriangle.prototype.markNeighbor = function(t) {\n    var points = this.points_;\n    if (t.containsPoints(points[1], points[2])) {\n        this.neighbors_[0] = t;\n        t.markNeighborPointers(points[1], points[2], this);\n    } else if (t.containsPoints(points[0], points[2])) {\n        this.neighbors_[1] = t;\n        t.markNeighborPointers(points[0], points[2], this);\n    } else if (t.containsPoints(points[0], points[1])) {\n        this.neighbors_[2] = t;\n        t.markNeighborPointers(points[0], points[1], this);\n    }\n};\n\n\nTriangle.prototype.clearNeighbors = function() {\n    this.neighbors_[0] = null;\n    this.neighbors_[1] = null;\n    this.neighbors_[2] = null;\n};\n\nTriangle.prototype.clearDelaunayEdges = function() {\n    this.delaunay_edge[0] = false;\n    this.delaunay_edge[1] = false;\n    this.delaunay_edge[2] = false;\n};\n\n/**\n * Returns the point clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[2];\n    } else if (p === points[1]) {\n        return points[0];\n    } else if (p === points[2]) {\n        return points[1];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the point counter-clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[1];\n    } else if (p === points[1]) {\n        return points[2];\n    } else if (p === points[2]) {\n        return points[0];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the neighbor clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[1];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[2];\n    } else {\n        return this.neighbors_[0];\n    }\n};\n\n/**\n * Returns the neighbor counter-clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[2];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[0];\n    } else {\n        return this.neighbors_[1];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[2];\n    } else {\n        return this.constrained_edge[0];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[0];\n    } else {\n        return this.constrained_edge[1];\n    }\n};\n\n// Additional check from Java version (see issue #88)\nTriangle.prototype.getConstrainedEdgeAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[0];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[1];\n    } else {\n        return this.constrained_edge[2];\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[1] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[2] = ce;\n    } else {\n        this.constrained_edge[0] = ce;\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[2] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[0] = ce;\n    } else {\n        this.constrained_edge[1] = ce;\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[2];\n    } else {\n        return this.delaunay_edge[0];\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[0];\n    } else {\n        return this.delaunay_edge[1];\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[1] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[2] = e;\n    } else {\n        this.delaunay_edge[0] = e;\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[2] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[0] = e;\n    } else {\n        this.delaunay_edge[1] = e;\n    }\n};\n\n/**\n * The neighbor across to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {Triangle}\n */\nTriangle.prototype.neighborAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[0];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[1];\n    } else {\n        return this.neighbors_[2];\n    }\n};\n\n/**\n * @private\n * @param {!Triangle} t Triangle object.\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.oppositePoint = function(t, p) {\n    var cw = t.pointCW(p);\n    return this.pointCW(cw);\n};\n\n/**\n * Legalize triangle by rotating clockwise around oPoint\n * @private\n * @param {XY} opoint - point object with {x,y}\n * @param {XY} npoint - point object with {x,y}\n * @throws {Error} if oPoint can not be found\n */\nTriangle.prototype.legalize = function(opoint, npoint) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (opoint === points[0]) {\n        points[1] = points[0];\n        points[0] = points[2];\n        points[2] = npoint;\n    } else if (opoint === points[1]) {\n        points[2] = points[1];\n        points[1] = points[0];\n        points[0] = npoint;\n    } else if (opoint === points[2]) {\n        points[0] = points[2];\n        points[2] = points[1];\n        points[1] = npoint;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.legalize() call');\n    }\n};\n\n/**\n * Returns the index of a point in the triangle. \n * The point *must* be a reference to one of the triangle's vertices.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {number} index 0, 1 or 2\n * @throws {Error} if p can not be found\n */\nTriangle.prototype.index = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return 0;\n    } else if (p === points[1]) {\n        return 1;\n    } else if (p === points[2]) {\n        return 2;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.index() call');\n    }\n};\n\n/**\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {number} index 0, 1 or 2, or -1 if errror\n */\nTriangle.prototype.edgeIndex = function(p1, p2) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p1 === points[0]) {\n        if (p2 === points[1]) {\n            return 2;\n        } else if (p2 === points[2]) {\n            return 1;\n        }\n    } else if (p1 === points[1]) {\n        if (p2 === points[2]) {\n            return 0;\n        } else if (p2 === points[0]) {\n            return 2;\n        }\n    } else if (p1 === points[2]) {\n        if (p2 === points[0]) {\n            return 1;\n        } else if (p2 === points[1]) {\n            return 0;\n        }\n    }\n    return -1;\n};\n\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {number} index - edge index\n */\nTriangle.prototype.markConstrainedEdgeByIndex = function(index) {\n    this.constrained_edge[index] = true;\n};\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {Edge} edge instance\n */\nTriangle.prototype.markConstrainedEdgeByEdge = function(edge) {\n    this.markConstrainedEdgeByPoints(edge.p, edge.q);\n};\n/**\n * Mark an edge of this triangle as constrained.\n * This method takes two Point instances defining the edge of the triangle.\n * @private\n * @param {XY} p - point object with {x,y}\n * @param {XY} q - point object with {x,y}\n */\nTriangle.prototype.markConstrainedEdgeByPoints = function(p, q) {\n    var points = this.points_;\n    // Here we are comparing point references, not values        \n    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {\n        this.constrained_edge[2] = true;\n    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {\n        this.constrained_edge[1] = true;\n    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {\n        this.constrained_edge[0] = true;\n    }\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Triangle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/triangle.js\n// module id = 4\n// module chunks = 0","// Copyright 2014-2016 Todd Fleming\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n// \n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// TODO: pass React elements to alertFn\n\n\"use strict\";\n\nimport ClipperLib from 'clipper-lib';\nimport SweepContext from 'poly2tri/src/sweepcontext';\n\nexport const inchToClipperScale = 1270000000;\nexport const mmToClipperScale = inchToClipperScale / 25.4; // 50000000;\nexport const clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm\nexport const cleanPolyDist = 100;\nexport const arcTolerance = 10000;\n\n// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't\n// include (p1x, p1y); it's part of the previous segment.\nfunction linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {\n    function bez(p0, p1, p2, p3, t) {\n        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\n    }\n\n    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y)\n        return ['L', p2x, p2y];\n\n    let numSegments = minNumSegments;\n    while (true) {\n        let x = p1x;\n        let y = p1y;\n        let result = ['L'];\n        for (let i = 1; i <= numSegments; ++i) {\n            let t = 1.0 * i / numSegments;\n            let nextX = bez(p1x, c1x, c2x, p2x, t);\n            let nextY = bez(p1y, c1y, c2y, p2y, t);\n            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {\n                numSegments *= 2;\n                result = null;\n                break;\n            }\n            result.push(nextX, nextY);\n            x = nextX;\n            y = nextY;\n        }\n        if (result)\n            return result;\n    }\n}\n\n// Linearize a path. Both the input path and the returned path are in snap.svg's format.\n// Calls alertFn with an error message and returns null if there's a problem.\nfunction linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {\n    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {\n        alertFn('Path does not begin with M')\n        return null;\n    }\n    let x = path[0][1];\n    let y = path[0][2];\n    let result = [path[0]];\n    for (let i = 1; i < path.length; ++i) {\n        let subpath = path[i];\n        if (subpath[0] == 'C' && subpath.length == 7) {\n            result.push(linearizeCubicBezier(\n                x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));\n            x = subpath[5];\n            y = subpath[6];\n        } else if (subpath[0] == 'M' && subpath.length == 3) {\n            result.push(subpath);\n            x = subpath[1];\n            y = subpath[2];\n        } else {\n            alertFn('Subpath has an unknown prefix: ' + subpath[0]);\n            return null;\n        }\n    }\n    return result;\n};\n\n// Get linear paths (snap format) from an SVG element. Calls alertFn with an \n// error message and returns null if there's a problem.\nfunction elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {\n    let path = null;\n    let Snap = require('snapsvg-cjs');\n    let snapElement = Snap(element);\n\n    if (snapElement.type == 'path')\n        path = snapElement.attr('d');\n    else if (snapElement.type == 'rect') {\n        let x = Number(snapElement.attr('x'));\n        let y = Number(snapElement.attr('y'));\n        let w = Number(snapElement.attr('width'));\n        let h = Number(snapElement.attr('height'));\n        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + (-w) + ',' + 0 + ' ' + 0 + ',' + (-h) + ' ';\n    }\n    else {\n        alertFn('<b>' + snapElement.type + \"</b> is not supported; try Inkscape's <strong>Object to Path</strong> command\");\n        return null;\n    }\n\n    if (snapElement.attr('clip-path') != '') {\n        alertFn('clip-path is not supported');\n        return null;\n    }\n\n    if (snapElement.attr('mask') != '') {\n        alertFn('mask is not supported');\n        return null;\n    }\n\n    if (path == null) {\n        alertFn('path is missing');\n        return;\n    }\n\n    path = Snap.path.map(path, snapElement.transform().globalMatrix);\n    path = Snap.parsePathString(path);\n    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);\n    return path;\n};\n\n// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Only supports linear paths.\n// Calls alertFn with an error message and returns null if there's a problem.\nfunction snapPathToRawPaths(snapPath, pxPerInch, alertFn) {\n    let factor = 25.4 / pxPerInch;\n    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {\n        alertFn('Path does not begin with M');\n        return null;\n    }\n    let currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];\n    let result = [currentPath];\n    for (let i = 1; i < snapPath.length; ++i) {\n        let subpath = snapPath[i];\n        if (subpath[0] == 'M' && subpath.length == 3) {\n            currentPath = [subpath[1] * factor, subpath[2] * factor];\n            result.push(currentPath);\n        } else if (subpath[0] == 'L') {\n            for (let j = 0; j < (subpath.length - 1) / 2; ++j)\n                currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);\n        } else {\n            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);\n            return null;\n        }\n    }\n    return result;\n};\n\n// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Converts curves.\n// Calls alertFn with an error message and returns null if there's a problem.\nexport function elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {\n    let path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);\n    if (path !== null)\n        return snapPathToRawPaths(path, pxPerInch, alertFn);\n    return null;\n}\n\n// [[[x0, y0, x1, y1, ...], ...], ...]\nexport function flipY(allRawPaths, deltaY) {\n    for (let rawPaths of allRawPaths)\n        for (let rawPath of rawPaths)\n            for (let i = 0; i < rawPath.length; i += 2)\n                rawPath[i + 1] = deltaY - rawPath[i + 1];\n}\n\nexport function hasClosedRawPaths(rawPaths) {\n    for (let path of rawPaths)\n        if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1])\n            return true;\n    return false;\n}\n\nexport function filterClosedRawPaths(rawPaths) {\n    let result = [];\n    for (let path of rawPaths)\n        if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1])\n            result.push(path);\n    return result;\n}\n\nexport function rawPathsToClipperPaths(rawPaths, scaleX, scaleY, translateX, translateY) {\n    let result = rawPaths.map(p => {\n        let result = [];\n        for (let i = 0; i < p.length; i += 2)\n            result.push({ X: (p[i] * scaleX + translateX) * mmToClipperScale, Y: (p[i + 1] * scaleY + translateY) * mmToClipperScale });\n        return result;\n    });\n    if (hasClosedRawPaths(rawPaths)) {\n        result = ClipperLib.Clipper.CleanPolygons(result, cleanPolyDist);\n        result = ClipperLib.Clipper.SimplifyPolygons(result, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    return result;\n}\n\nfunction clipperPathsToPolyTree(paths) {\n    let c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    let polyTree = new ClipperLib.PolyTree();\n    c.Execute(ClipperLib.ClipType.ctUnion, polyTree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    return polyTree;\n}\n\nfunction triangulatePolyTree(polyTree) {\n    let result = [];\n    let pointToVertex = point => ({ x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale });\n    let contourToVertexes = path => path.map(pointToVertex);\n    let nodesToVertexes = nodes => nodes.map(node => contourToVertexes(node.Contour()));\n    let processNode = node => {\n        let vertexes = contourToVertexes(node.Contour());\n        let holes = nodesToVertexes(node.Childs());\n        let context = new SweepContext(vertexes);\n        context.addHoles(holes);\n        context.triangulate();\n        let triangles = context.getTriangles();\n        for (let t of triangles) {\n            let p = t.getPoints();\n            result.push(\n                p[0].x, p[0].y,\n                p[1].x, p[1].y,\n                p[2].x, p[2].y);\n        }\n        for (let hole of node.Childs()) {\n            for (let next of hole.Childs()) {\n                processNode(next);\n            }\n        }\n    };\n    for (let node of polyTree.Childs()) {\n        processNode(node);\n    }\n    return result;\n}\n\nexport function triangulateRawPaths(rawPaths) {\n    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, 1, 1, 0, 0)));\n}\n\n// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].\nexport function clipperPathsToCPaths(memoryBlocks, clipperPaths) {\n    let doubleSize = 8;\n\n    let cPaths = Module._malloc(clipperPaths.length * 4);\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cPathSizes = Module._malloc(clipperPaths.length * 4);\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    for (let i = 0; i < clipperPaths.length; ++i) {\n        let clipperPath = clipperPaths[i];\n\n        let cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        //console.log(\"-> \" + cPath.toString(16));\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        for (let j = 0; j < clipperPath.length; ++j) {\n            let point = clipperPath[j];\n            pathArray[j * 2] = point.X * clipperToCppScale;\n            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;\n        }\n\n        Module.HEAPU32[cPathsBase + i] = cPath;\n        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;\n    }\n\n    return [cPaths, clipperPaths.length, cPathSizes];\n}\n\n// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n// Each point has X, Y (stride = 2).\nexport function cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n    let cPaths = Module.HEAPU32[cPathsRef >> 2];\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\n    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    let clipperPaths = [];\n    for (let i = 0; i < cNumPaths; ++i) {\n        let pathSize = Module.HEAPU32[cPathSizesBase + i];\n        let cPath = Module.HEAPU32[cPathsBase + i];\n        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        let clipperPath = [];\n        clipperPaths.push(clipperPath);\n        for (let j = 0; j < pathSize; ++j)\n            clipperPath.push({\n                X: pathArray[j * 2] / clipperToCppScale,\n                Y: pathArray[j * 2 + 1] / clipperToCppScale,\n            });\n    }\n\n    return clipperPaths;\n}\n\n// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n// Each point has X, Y, Z (stride = 3).\nexport function cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n    let cPaths = Module.HEAPU32[cPathsRef >> 2];\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\n    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    let convertedPaths = [];\n    for (let i = 0; i < cNumPaths; ++i) {\n        let pathSize = Module.HEAPU32[cPathSizesBase + i];\n        let cPath = Module.HEAPU32[cPathsBase + i];\n        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        let convertedPath = [];\n        convertedPaths.push({ path: convertedPath, safeToClose: false });\n        for (let j = 0; j < pathSize; ++j)\n            convertedPath.push({\n                X: pathArray[j * 3] / clipperToCppScale,\n                Y: pathArray[j * 3 + 1] / clipperToCppScale,\n                Z: pathArray[j * 3 + 2] / clipperToCppScale,\n            });\n\n        //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);\n    }\n\n    return convertedPaths;\n}\n\nexport function clipperBounds(paths) {\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    for (let path of paths) {\n        for (let pt of path) {\n            minX = Math.min(minX, pt.X);\n            maxX = Math.max(maxX, pt.X);\n            minY = Math.min(minY, pt.Y);\n            maxY = Math.max(maxY, pt.Y);\n        }\n    }\n    return { minX, minY, maxX, maxY };\n}\n\n// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.\nexport function clip(paths1, paths2, clipType) {\n    var clipper = new ClipperLib.Clipper();\n    clipper.AddPaths(paths1, ClipperLib.PolyType.ptSubject, true);\n    clipper.AddPaths(paths2, ClipperLib.PolyType.ptClip, true);\n    var result = [];\n    clipper.Execute(clipType, result, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    return result;\n}\n\n// Return union of two Clipper geometries. Returns new geometry.\nexport function union(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctUnion);\n}\n\n// Return difference between two Clipper geometries. Returns new geometry.\nexport function diff(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctDifference);\n}\n\n// Return xor of two Clipper geometries. Returns new geometry.\nexport function xor(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctXor);\n}\n\n// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.\nexport function offset(paths, amount, joinType, endType) {\n    if (joinType === undefined)\n        joinType = ClipperLib.JoinType.jtRound;\n    if (endType === undefined)\n        endType = ClipperLib.EndType.etClosedPolygon;\n\n    // bug workaround: join types are swapped in ClipperLib 6.1.3.2\n    if (joinType === ClipperLib.JoinType.jtSquare)\n        joinType = ClipperLib.JoinType.jtMiter;\n    else if (joinType === ClipperLib.JoinType.jtMiter)\n        joinType = ClipperLib.JoinType.jtSquare;\n\n    var co = new ClipperLib.ClipperOffset(2, arcTolerance);\n    co.AddPaths(paths, joinType, endType);\n    var offsetted = [];\n    co.Execute(offsetted, amount);\n    return offsetted;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/mesh.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x¹,y¹) & (x²,y²) is ...\n    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 6\n// module chunks = 0","// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.4.2 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n    var version = \"0.4.2\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            name = String(name);\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n        // Undocumented. Debug only.\n        eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    \n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/\n    eve.on = function (name, f) {\n        name = String(name);\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = name.split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = name.split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n        }\n        return current_event;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = name.split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = name.split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.unbind(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : (typeof define === \"function\" && define.amd ? (define(\"eve\", [], function() { return eve; })) : (glob.eve = eve));\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/eve/eve.js\n// module id = 7\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n *\n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n *\n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Function added in the JavaScript version (was not present in the c++ version)\n */\n\n/**\n * assert and throw an exception.\n *\n * @private\n * @param {boolean} condition   the condition which is asserted\n * @param {string} message      the message which is display is condition is falsy\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assert Failed\");\n    }\n}\nmodule.exports = assert;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/assert.js\n// module id = 8\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require('./xy');\n\n// ------------------------------------------------------------------------Point\n/**\n * Construct a point\n * @example\n *      var point = new poly2tri.Point(150, 150);\n * @public\n * @constructor\n * @struct\n * @param {number=} x    coordinate (0 if undefined)\n * @param {number=} y    coordinate (0 if undefined)\n */\nvar Point = function(x, y) {\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.x = +x || 0;\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.y = +y || 0;\n\n    // All extra fields added to Point are prefixed with _p2t_\n    // to avoid collisions if custom Point class is used.\n\n    /**\n     * The edges this point constitutes an upper ending point\n     * @private\n     * @type {Array.<Edge>}\n     */\n    this._p2t_edge_list = null;\n};\n\n/**\n * For pretty printing\n * @example\n *      \"p=\" + new poly2tri.Point(5,42)\n *      // → \"p=(5;42)\"\n * @returns {string} <code>\"(x;y)\"</code>\n */\nPoint.prototype.toString = function() {\n    return xy.toStringBase(this);\n};\n\n/**\n * JSON output, only coordinates\n * @example\n *      JSON.stringify(new poly2tri.Point(1,2))\n *      // → '{\"x\":1,\"y\":2}'\n */\nPoint.prototype.toJSON = function() {\n    return { x: this.x, y: this.y };\n};\n\n/**\n * Creates a copy of this Point object.\n * @return {Point} new cloned point\n */\nPoint.prototype.clone = function() {\n    return new Point(this.x, this.y);\n};\n\n/**\n * Set this Point instance to the origo. <code>(0; 0)</code>\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set_zero = function() {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this; // for chaining\n};\n\n/**\n * Set the coordinates of this instance.\n * @param {number} x   coordinate\n * @param {number} y   coordinate\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set = function(x, y) {\n    this.x = +x || 0;\n    this.y = +y || 0;\n    return this; // for chaining\n};\n\n/**\n * Negate this Point instance. (component-wise)\n * @return {Point} this (for chaining)\n */\nPoint.prototype.negate = function() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this; // for chaining\n};\n\n/**\n * Add another Point object to this instance. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.add = function(n) {\n    this.x += n.x;\n    this.y += n.y;\n    return this; // for chaining\n};\n\n/**\n * Subtract this Point instance with another point given. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.sub = function(n) {\n    this.x -= n.x;\n    this.y -= n.y;\n    return this; // for chaining\n};\n\n/**\n * Multiply this Point instance by a scalar. (component-wise)\n * @param {number} s   scalar.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.mul = function(s) {\n    this.x *= s;\n    this.y *= s;\n    return this; // for chaining\n};\n\n/**\n * Return the distance of this Point instance from the origo.\n * @return {number} distance\n */\nPoint.prototype.length = function() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\n/**\n * Normalize this Point instance (as a vector).\n * @return {number} The original distance of this instance from the origo.\n */\nPoint.prototype.normalize = function() {\n    var len = this.length();\n    this.x /= len;\n    this.y /= len;\n    return len;\n};\n\n/**\n * Test this Point object with another for equality.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.\n */\nPoint.prototype.equals = function(p) {\n    return this.x === p.x && this.y === p.y;\n};\n\n\n// -----------------------------------------------------Point (\"static\" methods)\n\n/**\n * Negate a point component-wise and return the result as a new Point object.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.negate = function(p) {\n    return new Point(-p.x, -p.y);\n};\n\n/**\n * Add two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.add = function(a, b) {\n    return new Point(a.x + b.x, a.y + b.y);\n};\n\n/**\n * Subtract two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.sub = function(a, b) {\n    return new Point(a.x - b.x, a.y - b.y);\n};\n\n/**\n * Multiply a point by a scalar and return the result as a new Point object.\n * @param {number} s - the scalar\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.mul = function(s, p) {\n    return new Point(s * p.x, s * p.y);\n};\n\n/**\n * Perform the cross product on either two points (this produces a scalar)\n * or a point and a scalar (this produces a point).\n * This function requires two parameters, either may be a Point object or a\n * number.\n * @param  {XY|number} a - Point object or scalar.\n * @param  {XY|number} b - Point object or scalar.\n * @return {Point|number} a Point object or a number, depending on the parameters.\n */\nPoint.cross = function(a, b) {\n    if (typeof(a) === 'number') {\n        if (typeof(b) === 'number') {\n            return a * b;\n        } else {\n            return new Point(-a * b.y, a * b.x);\n        }\n    } else {\n        if (typeof(b) === 'number') {\n            return new Point(b * a.y, -b * a.x);\n        } else {\n            return a.x * b.y - a.y * b.x;\n        }\n    }\n};\n\n\n// -----------------------------------------------------------------\"Point-Like\"\n/*\n * The following functions operate on \"Point\" or any \"Point like\" object \n * with {x,y} (duck typing).\n */\n\nPoint.toString = xy.toString;\nPoint.compare = xy.compare;\nPoint.cmp = xy.compare; // backward compatibility\nPoint.equals = xy.equals;\n\n/**\n * Peform the dot product on two vectors.\n * @public\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {number} The dot product\n */\nPoint.dot = function(a, b) {\n    return a.x * b.x + a.y * b.y;\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/point.js\n// module id = 9\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint latedef:nofunc, maxcomplexity:9 */\n\n\"use strict\";\n\n/**\n * This 'Sweep' module is present in order to keep this JavaScript version\n * as close as possible to the reference C++ version, even though almost all\n * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.\n * @module\n * @private\n */\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar assert = require('./assert');\nvar PointError = require('./pointerror');\nvar Triangle = require('./triangle');\nvar Node = require('./advancingfront').Node;\n\n\n// ------------------------------------------------------------------------utils\n\nvar utils = require('./utils');\n\n/** @const */\nvar EPSILON = utils.EPSILON;\n\n/** @const */\nvar Orientation = utils.Orientation;\n/** @const */\nvar orient2d = utils.orient2d;\n/** @const */\nvar inScanArea = utils.inScanArea;\n/** @const */\nvar isAngleObtuse = utils.isAngleObtuse;\n\n\n// ------------------------------------------------------------------------Sweep\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @private\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction triangulate(tcx) {\n    tcx.initTriangulation();\n    tcx.createAdvancingFront();\n    // Sweep points; build mesh\n    sweepPoints(tcx);\n    // Clean up\n    finalizationPolygon(tcx);\n}\n\n/**\n * Start sweeping the Y-sorted point set from bottom to top\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction sweepPoints(tcx) {\n    var i, len = tcx.pointCount();\n    for (i = 1; i < len; ++i) {\n        var point = tcx.getPoint(i);\n        var node = pointEvent(tcx, point);\n        var edges = point._p2t_edge_list;\n        for (var j = 0; edges && j < edges.length; ++j) {\n            edgeEventByEdge(tcx, edges[j], node);\n        }\n    }\n}\n\n/**\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction finalizationPolygon(tcx) {\n    // Get an Internal triangle to start with\n    var t = tcx.front().head().next.triangle;\n    var p = tcx.front().head().next.point;\n    while (!t.getConstrainedEdgeCW(p)) {\n        t = t.neighborCCW(p);\n    }\n\n    // Collect interior triangles constrained by edges\n    tcx.meshClean(t);\n}\n\n/**\n * Find closes node to the left of the new point and\n * create a new triangle. If needed new holes and basins\n * will be filled to.\n * @param {!SweepContext} tcx - SweepContext object\n * @param {!XY} point   Point\n */\nfunction pointEvent(tcx, point) {\n    var node = tcx.locateNode(point);\n    var new_node = newFrontTriangle(tcx, point, node);\n\n    // Only need to check +epsilon since point never have smaller\n    // x value than node due to how we fetch nodes from the front\n    if (point.x <= node.point.x + (EPSILON)) {\n        fill(tcx, node);\n    }\n\n    //tcx.AddNode(new_node);\n\n    fillAdvancingFront(tcx, new_node);\n    return new_node;\n}\n\nfunction edgeEventByEdge(tcx, edge, node) {\n    tcx.edge_event.constrained_edge = edge;\n    tcx.edge_event.right = (edge.p.x > edge.q.x);\n\n    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {\n        return;\n    }\n\n    // For now we will do all needed filling\n    // TODO: integrate with flip process might give some better performance\n    //       but for now this avoid the issue with cases that needs both flips and fills\n    fillEdgeEvent(tcx, edge, node);\n    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);\n}\n\nfunction edgeEventByPoints(tcx, ep, eq, triangle, point) {\n    if (isEdgeSideOfTriangle(triangle, ep, eq)) {\n        return;\n    }\n\n    var p1 = triangle.pointCCW(point);\n    var o1 = orient2d(eq, p1, ep);\n    if (o1 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);\n    }\n\n    var p2 = triangle.pointCW(point);\n    var o2 = orient2d(eq, p2, ep);\n    if (o2 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);\n    }\n\n    if (o1 === o2) {\n        // Need to decide if we are rotating CW or CCW to get to a triangle\n        // that will cross edge\n        if (o1 === Orientation.CW) {\n            triangle = triangle.neighborCCW(point);\n        } else {\n            triangle = triangle.neighborCW(point);\n        }\n        edgeEventByPoints(tcx, ep, eq, triangle, point);\n    } else {\n        // This triangle crosses constraint so lets flippin start!\n        flipEdgeEvent(tcx, ep, eq, triangle, point);\n    }\n}\n\nfunction isEdgeSideOfTriangle(triangle, ep, eq) {\n    var index = triangle.edgeIndex(ep, eq);\n    if (index !== -1) {\n        triangle.markConstrainedEdgeByIndex(index);\n        var t = triangle.getNeighbor(index);\n        if (t) {\n            t.markConstrainedEdgeByPoints(ep, eq);\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Creates a new front triangle and legalize it\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction newFrontTriangle(tcx, point, node) {\n    var triangle = new Triangle(point, node.point, node.next.point);\n\n    triangle.markNeighbor(node.triangle);\n    tcx.addToMap(triangle);\n\n    var new_node = new Node(point);\n    new_node.next = node.next;\n    new_node.prev = node;\n    node.next.prev = new_node;\n    node.next = new_node;\n\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    return new_node;\n}\n\n/**\n * Adds a triangle to the advancing front to fill a hole.\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - middle node, that is the bottom of the hole\n */\nfunction fill(tcx, node) {\n    var triangle = new Triangle(node.prev.point, node.point, node.next.point);\n\n    // TODO: should copy the constrained_edge value from neighbor triangles\n    //       for now constrained_edge values are copied during the legalize\n    triangle.markNeighbor(node.prev.triangle);\n    triangle.markNeighbor(node.triangle);\n\n    tcx.addToMap(triangle);\n\n    // Update the advancing front\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n\n\n    // If it was legalized the triangle has already been mapped\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    //tcx.removeNode(node);\n}\n\n/**\n * Fills holes in the Advancing Front\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction fillAdvancingFront(tcx, n) {\n    // Fill right holes\n    var node = n.next;\n    while (node.next) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.next;\n    }\n\n    // Fill left holes\n    node = n.prev;\n    while (node.prev) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.prev;\n    }\n\n    // Fill right basins\n    if (n.next && n.next.next) {\n        if (isBasinAngleRight(n)) {\n            fillBasin(tcx, n);\n        }\n    }\n}\n\n/**\n * The basin angle is decided against the horizontal line [1,0].\n * @param {Node} node\n * @return {boolean} true if angle < 3*π/4\n */\nfunction isBasinAngleRight(node) {\n    var ax = node.point.x - node.next.next.point.x;\n    var ay = node.point.y - node.next.next.point.y;\n    assert(ay >= 0, \"unordered y\");\n    return (ax >= 0 || Math.abs(ax) < ay);\n}\n\n/**\n * Returns true if triangle was legalized\n * @param {!SweepContext} tcx - SweepContext object\n * @return {boolean}\n */\nfunction legalize(tcx, t) {\n    // To legalize a triangle we start by finding if any of the three edges\n    // violate the Delaunay condition\n    for (var i = 0; i < 3; ++i) {\n        if (t.delaunay_edge[i]) {\n            continue;\n        }\n        var ot = t.getNeighbor(i);\n        if (ot) {\n            var p = t.getPoint(i);\n            var op = ot.oppositePoint(t, p);\n            var oi = ot.index(op);\n\n            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)\n            // then we should not try to legalize\n            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {\n                t.constrained_edge[i] = ot.constrained_edge[oi];\n                continue;\n            }\n\n            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);\n            if (inside) {\n                // Lets mark this shared edge as Delaunay\n                t.delaunay_edge[i] = true;\n                ot.delaunay_edge[oi] = true;\n\n                // Lets rotate shared edge one vertex CW to legalize it\n                rotateTrianglePair(t, p, ot, op);\n\n                // We now got one valid Delaunay Edge shared by two triangles\n                // This gives us 4 new edges to check for Delaunay\n\n                // Make sure that triangle to node mapping is done only one time for a specific triangle\n                var not_legalized = !legalize(tcx, t);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(t);\n                }\n\n                not_legalized = !legalize(tcx, ot);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(ot);\n                }\n                // Reset the Delaunay edges, since they only are valid Delaunay edges\n                // until we add a new triangle or point.\n                // XXX: need to think about this. Can these edges be tried after we\n                //      return to previous recursive level?\n                t.delaunay_edge[i] = false;\n                ot.delaunay_edge[oi] = false;\n\n                // If triangle have been legalized no need to check the other edges since\n                // the recursive legalization will handles those so we can end here.\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * <b>Requirement</b>:<br>\n * 1. a,b and c form a triangle.<br>\n * 2. a and d is know to be on opposite side of bc<br>\n * <pre>\n *                a\n *                +\n *               / \\\n *              /   \\\n *            b/     \\c\n *            +-------+\n *           /    d    \\\n *          /           \\\n * </pre>\n * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by\n *  a,b and c<br>\n *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>\n *  This preknowledge gives us a way to optimize the incircle test\n * @param pa - triangle point, opposite d\n * @param pb - triangle point\n * @param pc - triangle point\n * @param pd - point opposite a\n * @return {boolean} true if d is inside circle, false if on circle edge\n */\nfunction inCircle(pa, pb, pc, pd) {\n    var adx = pa.x - pd.x;\n    var ady = pa.y - pd.y;\n    var bdx = pb.x - pd.x;\n    var bdy = pb.y - pd.y;\n\n    var adxbdy = adx * bdy;\n    var bdxady = bdx * ady;\n    var oabd = adxbdy - bdxady;\n    if (oabd <= 0) {\n        return false;\n    }\n\n    var cdx = pc.x - pd.x;\n    var cdy = pc.y - pd.y;\n\n    var cdxady = cdx * ady;\n    var adxcdy = adx * cdy;\n    var ocad = cdxady - adxcdy;\n    if (ocad <= 0) {\n        return false;\n    }\n\n    var bdxcdy = bdx * cdy;\n    var cdxbdy = cdx * bdy;\n\n    var alift = adx * adx + ady * ady;\n    var blift = bdx * bdx + bdy * bdy;\n    var clift = cdx * cdx + cdy * cdy;\n\n    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;\n    return det > 0;\n}\n\n/**\n * Rotates a triangle pair one vertex CW\n *<pre>\n *       n2                    n2\n *  P +-----+             P +-----+\n *    | t  /|               |\\  t |\n *    |   / |               | \\   |\n *  n1|  /  |n3           n1|  \\  |n3\n *    | /   |    after CW   |   \\ |\n *    |/ oT |               | oT \\|\n *    +-----+ oP            +-----+\n *       n4                    n4\n * </pre>\n */\nfunction rotateTrianglePair(t, p, ot, op) {\n    var n1, n2, n3, n4;\n    n1 = t.neighborCCW(p);\n    n2 = t.neighborCW(p);\n    n3 = ot.neighborCCW(op);\n    n4 = ot.neighborCW(op);\n\n    var ce1, ce2, ce3, ce4;\n    ce1 = t.getConstrainedEdgeCCW(p);\n    ce2 = t.getConstrainedEdgeCW(p);\n    ce3 = ot.getConstrainedEdgeCCW(op);\n    ce4 = ot.getConstrainedEdgeCW(op);\n\n    var de1, de2, de3, de4;\n    de1 = t.getDelaunayEdgeCCW(p);\n    de2 = t.getDelaunayEdgeCW(p);\n    de3 = ot.getDelaunayEdgeCCW(op);\n    de4 = ot.getDelaunayEdgeCW(op);\n\n    t.legalize(p, op);\n    ot.legalize(op, p);\n\n    // Remap delaunay_edge\n    ot.setDelaunayEdgeCCW(p, de1);\n    t.setDelaunayEdgeCW(p, de2);\n    t.setDelaunayEdgeCCW(op, de3);\n    ot.setDelaunayEdgeCW(op, de4);\n\n    // Remap constrained_edge\n    ot.setConstrainedEdgeCCW(p, ce1);\n    t.setConstrainedEdgeCW(p, ce2);\n    t.setConstrainedEdgeCCW(op, ce3);\n    ot.setConstrainedEdgeCW(op, ce4);\n\n    // Remap neighbors\n    // XXX: might optimize the markNeighbor by keeping track of\n    //      what side should be assigned to what neighbor after the\n    //      rotation. Now mark neighbor does lots of testing to find\n    //      the right side.\n    t.clearNeighbors();\n    ot.clearNeighbors();\n    if (n1) {\n        ot.markNeighbor(n1);\n    }\n    if (n2) {\n        t.markNeighbor(n2);\n    }\n    if (n3) {\n        t.markNeighbor(n3);\n    }\n    if (n4) {\n        ot.markNeighbor(n4);\n    }\n    t.markNeighbor(ot);\n}\n\n/**\n * Fills a basin that has formed on the Advancing Front to the right\n * of given node.<br>\n * First we decide a left,bottom and right node that forms the\n * boundaries of the basin. Then we do a reqursive fill.\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - starting node, this or next node will be left node\n */\nfunction fillBasin(tcx, node) {\n    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n        tcx.basin.left_node = node.next.next;\n    } else {\n        tcx.basin.left_node = node.next;\n    }\n\n    // Find the bottom and right node\n    tcx.basin.bottom_node = tcx.basin.left_node;\n    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {\n        tcx.basin.bottom_node = tcx.basin.bottom_node.next;\n    }\n    if (tcx.basin.bottom_node === tcx.basin.left_node) {\n        // No valid basin\n        return;\n    }\n\n    tcx.basin.right_node = tcx.basin.bottom_node;\n    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {\n        tcx.basin.right_node = tcx.basin.right_node.next;\n    }\n    if (tcx.basin.right_node === tcx.basin.bottom_node) {\n        // No valid basins\n        return;\n    }\n\n    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;\n    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;\n\n    fillBasinReq(tcx, tcx.basin.bottom_node);\n}\n\n/**\n * Recursive algorithm to fill a Basin with triangles\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - bottom_node\n */\nfunction fillBasinReq(tcx, node) {\n    // if shallow stop filling\n    if (isShallow(tcx, node)) {\n        return;\n    }\n\n    fill(tcx, node);\n\n    var o;\n    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {\n        return;\n    } else if (node.prev === tcx.basin.left_node) {\n        o = orient2d(node.point, node.next.point, node.next.next.point);\n        if (o === Orientation.CW) {\n            return;\n        }\n        node = node.next;\n    } else if (node.next === tcx.basin.right_node) {\n        o = orient2d(node.point, node.prev.point, node.prev.prev.point);\n        if (o === Orientation.CCW) {\n            return;\n        }\n        node = node.prev;\n    } else {\n        // Continue with the neighbor node with lowest Y value\n        if (node.prev.point.y < node.next.point.y) {\n            node = node.prev;\n        } else {\n            node = node.next;\n        }\n    }\n\n    fillBasinReq(tcx, node);\n}\n\nfunction isShallow(tcx, node) {\n    var height;\n    if (tcx.basin.left_highest) {\n        height = tcx.basin.left_node.point.y - node.point.y;\n    } else {\n        height = tcx.basin.right_node.point.y - node.point.y;\n    }\n\n    // if shallow stop filling\n    if (tcx.basin.width > height) {\n        return true;\n    }\n    return false;\n}\n\nfunction fillEdgeEvent(tcx, edge, node) {\n    if (tcx.edge_event.right) {\n        fillRightAboveEdgeEvent(tcx, edge, node);\n    } else {\n        fillLeftAboveEdgeEvent(tcx, edge, node);\n    }\n}\n\nfunction fillRightAboveEdgeEvent(tcx, edge, node) {\n    while (node.next.point.x < edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.next;\n        }\n    }\n}\n\nfunction fillRightBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x < edge.p.x) {\n        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n            // Concave\n            fillRightConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillRightConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillRightConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.next);\n    if (node.next.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n                // Next is concave\n                fillRightConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction fillRightConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {\n        // Concave\n        fillRightConcaveEdgeEvent(tcx, edge, node.next);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            fillRightConvexEdgeEvent(tcx, edge, node.next);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftAboveEdgeEvent(tcx, edge, node) {\n    while (node.prev.point.x > edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.prev;\n        }\n    }\n}\n\nfunction fillLeftBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x > edge.p.x) {\n        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n            // Concave\n            fillLeftConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillLeftConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillLeftConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {\n        // Concave\n        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            fillLeftConvexEdgeEvent(tcx, edge, node.prev);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.prev);\n    if (node.prev.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n                // Next is concave\n                fillLeftConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction flipEdgeEvent(tcx, ep, eq, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle!\");\n\n    var op = ot.oppositePoint(t, p);\n\n    // Additional check from Java version (see issue #88)\n    if (t.getConstrainedEdgeAcross(p)) {\n        var index = t.index(p);\n        throw new PointError(\"poly2tri Intersecting Constraints\",\n                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);\n    }\n\n    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {\n        // Lets rotate shared edge one vertex CW\n        rotateTrianglePair(t, p, ot, op);\n        tcx.mapTriangleToNodes(t);\n        tcx.mapTriangleToNodes(ot);\n\n        // XXX: in the original C++ code for the next 2 lines, we are\n        // comparing point values (and not pointers). In this JavaScript\n        // code, we are comparing point references (pointers). This works\n        // because we can't have 2 different points with the same values.\n        // But to be really equivalent, we should use \"Point.equals\" here.\n        if (p === eq && op === ep) {\n            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {\n                t.markConstrainedEdgeByPoints(ep, eq);\n                ot.markConstrainedEdgeByPoints(ep, eq);\n                legalize(tcx, t);\n                legalize(tcx, ot);\n            } else {\n                // XXX: I think one of the triangles should be legalized here?\n                /* jshint noempty:false */\n            }\n        } else {\n            var o = orient2d(eq, op, ep);\n            t = nextFlipTriangle(tcx, o, t, ot, p, op);\n            flipEdgeEvent(tcx, ep, eq, t, p);\n        }\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);\n        edgeEventByPoints(tcx, ep, eq, t, p);\n    }\n}\n\n/**\n * After a flip we have two triangles and know that only one will still be\n * intersecting the edge. So decide which to contiune with and legalize the other\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param o - should be the result of an orient2d( eq, op, ep )\n * @param t - triangle 1\n * @param ot - triangle 2\n * @param p - a point shared by both triangles\n * @param op - another point shared by both triangles\n * @return returns the triangle still intersecting the edge\n */\nfunction nextFlipTriangle(tcx, o, t, ot, p, op) {\n    var edge_index;\n    if (o === Orientation.CCW) {\n        // ot is not crossing edge after flip\n        edge_index = ot.edgeIndex(p, op);\n        ot.delaunay_edge[edge_index] = true;\n        legalize(tcx, ot);\n        ot.clearDelaunayEdges();\n        return t;\n    }\n\n    // t is not crossing edge after flip\n    edge_index = t.edgeIndex(p, op);\n\n    t.delaunay_edge[edge_index] = true;\n    legalize(tcx, t);\n    t.clearDelaunayEdges();\n    return ot;\n}\n\n/**\n * When we need to traverse from one triangle to the next we need\n * the point in current triangle that is the opposite point to the next\n * triangle.\n */\nfunction nextFlipPoint(ep, eq, ot, op) {\n    var o2d = orient2d(eq, op, ep);\n    if (o2d === Orientation.CW) {\n        // Right\n        return ot.pointCCW(op);\n    } else if (o2d === Orientation.CCW) {\n        // Left\n        return ot.pointCW(op);\n    } else {\n        throw new PointError(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [eq, op, ep]);\n    }\n}\n\n/**\n * Scan part of the FlipScan algorithm<br>\n * When a triangle pair isn't flippable we will scan for the next\n * point that is inside the flip triangle scan area. When found\n * we generate a new flipEdgeEvent\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param ep - last point on the edge we are traversing\n * @param eq - first point on the edge we are traversing\n * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge\n * @param t\n * @param p\n */\nfunction flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle\");\n\n    var op = ot.oppositePoint(t, p);\n\n    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {\n        // flip with new edge op.eq\n        flipEdgeEvent(tcx, eq, op, ot, op);\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);\n    }\n}\n\n\n// ----------------------------------------------------------------------Exports\n\nexports.triangulate = triangulate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/sweep.js\n// module id = 10\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:6 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar PointError = require('./pointerror');\nvar Point = require('./point');\nvar Triangle = require('./triangle');\nvar sweep = require('./sweep');\nvar AdvancingFront = require('./advancingfront');\nvar Node = AdvancingFront.Node;\n\n\n// ------------------------------------------------------------------------utils\n\n/**\n * Initial triangle factor, seed triangle will extend 30% of\n * PointSet width to both left and right.\n * @private\n * @const\n */\nvar kAlpha = 0.3;\n\n\n// -------------------------------------------------------------------------Edge\n/**\n * Represents a simple polygon's edge\n * @constructor\n * @struct\n * @private\n * @param {Point} p1\n * @param {Point} p2\n * @throw {PointError} if p1 is same as p2\n */\nvar Edge = function(p1, p2) {\n    this.p = p1;\n    this.q = p2;\n\n    if (p1.y > p2.y) {\n        this.q = p1;\n        this.p = p2;\n    } else if (p1.y === p2.y) {\n        if (p1.x > p2.x) {\n            this.q = p1;\n            this.p = p2;\n        } else if (p1.x === p2.x) {\n            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n        }\n    }\n\n    if (!this.q._p2t_edge_list) {\n        this.q._p2t_edge_list = [];\n    }\n    this.q._p2t_edge_list.push(this);\n};\n\n\n// ------------------------------------------------------------------------Basin\n/**\n * @constructor\n * @struct\n * @private\n */\nvar Basin = function() {\n    /** @type {Node} */\n    this.left_node = null;\n    /** @type {Node} */\n    this.bottom_node = null;\n    /** @type {Node} */\n    this.right_node = null;\n    /** @type {number} */\n    this.width = 0.0;\n    /** @type {boolean} */\n    this.left_highest = false;\n};\n\nBasin.prototype.clear = function() {\n    this.left_node = null;\n    this.bottom_node = null;\n    this.right_node = null;\n    this.width = 0.0;\n    this.left_highest = false;\n};\n\n// --------------------------------------------------------------------EdgeEvent\n/**\n * @constructor\n * @struct\n * @private\n */\nvar EdgeEvent = function() {\n    /** @type {Edge} */\n    this.constrained_edge = null;\n    /** @type {boolean} */\n    this.right = false;\n};\n\n// ----------------------------------------------------SweepContext (public API)\n/**\n * SweepContext constructor option\n * @typedef {Object} SweepContextOptions\n * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters\n *                  (contour, holes). Points inside arrays are never copied.\n *                  Default is <code>false</code> : keep a reference to the array arguments,\n *                  who will be modified in place.\n */\n/**\n * Constructor for the triangulation context.\n * It accepts a simple polyline (with non repeating points), \n * which defines the constrained edges.\n *\n * @example\n *          var contour = [\n *              new poly2tri.Point(100, 100),\n *              new poly2tri.Point(100, 300),\n *              new poly2tri.Point(300, 300),\n *              new poly2tri.Point(300, 100)\n *          ];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @example\n *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @constructor\n * @public\n * @struct\n * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,\n *          or any \"Point like\" custom class with <code>{x, y}</code> attributes.\n * @param {SweepContextOptions=} options - constructor options\n */\nvar SweepContext = function(contour, options) {\n    options = options || {};\n    this.triangles_ = [];\n    this.map_ = [];\n    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);\n    this.edge_list = [];\n\n    // Bounding box of all points. Computed at the start of the triangulation, \n    // it is stored in case it is needed by the caller.\n    this.pmin_ = this.pmax_ = null;\n\n    /**\n     * Advancing front\n     * @private\n     * @type {AdvancingFront}\n     */\n    this.front_ = null;\n\n    /**\n     * head point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.head_ = null;\n\n    /**\n     * tail point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.tail_ = null;\n\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_head_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_middle_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_tail_ = null;\n\n    this.basin = new Basin();\n    this.edge_event = new EdgeEvent();\n\n    this.initEdges(this.points_);\n};\n\n\n/**\n * Add a hole to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var hole = [\n *          new poly2tri.Point(200, 200),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addHole(hole);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} polyline - array of \"Point like\" objects with {x,y}\n */\nSweepContext.prototype.addHole = function(polyline) {\n    this.initEdges(polyline);\n    var i, len = polyline.length;\n    for (i = 0; i < len; i++) {\n        this.points_.push(polyline[i]);\n    }\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addHole} instead\n */\nSweepContext.prototype.AddHole = SweepContext.prototype.addHole;\n\n\n/**\n * Add several holes to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n *      ];\n *      swctx.addHoles(holes);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n *      ];\n *      swctx.addHoles(holes);\n * @public\n * @param {Array.<Array.<XY>>} holes - array of array of \"Point like\" objects with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addHoles = function(holes) {\n    var i, len = holes.length;\n    for (i = 0; i < len; i++) {\n        this.initEdges(holes[i]);\n    }\n    this.points_ = this.points_.concat.apply(this.points_, holes);\n    return this; // for chaining\n};\n\n\n/**\n * Add a Steiner point to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var point = new poly2tri.Point(150, 150);\n *      swctx.addPoint(point);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoint({x:150, y:150});\n * @public\n * @param {XY} point - any \"Point like\" object with {x,y}\n */\nSweepContext.prototype.addPoint = function(point) {\n    this.points_.push(point);\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addPoint} instead\n */\nSweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;\n\n\n/**\n * Add several Steiner points to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var points = [\n *          new poly2tri.Point(150, 150),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addPoints(points);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} points - array of \"Point like\" object with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addPoints = function(points) {\n    this.points_ = this.points_.concat(points);\n    return this; // for chaining\n};\n\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @public\n */\n// Shortcut method for sweep.triangulate(SweepContext).\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.triangulate = function() {\n    sweep.triangulate(this);\n    return this; // for chaining\n};\n\n\n/**\n * Get the bounding box of the provided constraints (contour, holes and \n * Steinter points). Warning : these values are not available if the triangulation \n * has not been done yet.\n * @public\n * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.getBoundingBox = function() {\n    return {min: this.pmin_, max: this.pmax_};\n};\n\n/**\n * Get result of triangulation.\n * The output triangles have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      // → \"number\"\n * @public\n * @returns {array<Triangle>}   array of triangles\n */\nSweepContext.prototype.getTriangles = function() {\n    return this.triangles_;\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#getTriangles} instead\n */\nSweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;\n\n\n// ---------------------------------------------------SweepContext (private API)\n\n/** @private */\nSweepContext.prototype.front = function() {\n    return this.front_;\n};\n\n/** @private */\nSweepContext.prototype.pointCount = function() {\n    return this.points_.length;\n};\n\n/** @private */\nSweepContext.prototype.head = function() {\n    return this.head_;\n};\n\n/** @private */\nSweepContext.prototype.setHead = function(p1) {\n    this.head_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @private */\nSweepContext.prototype.setTail = function(p1) {\n    this.tail_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.getMap = function() {\n    return this.map_;\n};\n\n/** @private */\nSweepContext.prototype.initTriangulation = function() {\n    var xmax = this.points_[0].x;\n    var xmin = this.points_[0].x;\n    var ymax = this.points_[0].y;\n    var ymin = this.points_[0].y;\n\n    // Calculate bounds\n    var i, len = this.points_.length;\n    for (i = 1; i < len; i++) {\n        var p = this.points_[i];\n        /* jshint expr:true */\n        (p.x > xmax) && (xmax = p.x);\n        (p.x < xmin) && (xmin = p.x);\n        (p.y > ymax) && (ymax = p.y);\n        (p.y < ymin) && (ymin = p.y);\n    }\n    this.pmin_ = new Point(xmin, ymin);\n    this.pmax_ = new Point(xmax, ymax);\n\n    var dx = kAlpha * (xmax - xmin);\n    var dy = kAlpha * (ymax - ymin);\n    this.head_ = new Point(xmax + dx, ymin - dy);\n    this.tail_ = new Point(xmin - dx, ymin - dy);\n\n    // Sort points along y-axis\n    this.points_.sort(Point.compare);\n};\n\n/** @private */\nSweepContext.prototype.initEdges = function(polyline) {\n    var i, len = polyline.length;\n    for (i = 0; i < len; ++i) {\n        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n    }\n};\n\n/** @private */\nSweepContext.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/** @private */\nSweepContext.prototype.addToMap = function(triangle) {\n    this.map_.push(triangle);\n};\n\n/** @private */\nSweepContext.prototype.locateNode = function(point) {\n    return this.front_.locateNode(point.x);\n};\n\n/** @private */\nSweepContext.prototype.createAdvancingFront = function() {\n    var head;\n    var middle;\n    var tail;\n    // Initial triangle\n    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);\n\n    this.map_.push(triangle);\n\n    head = new Node(triangle.getPoint(1), triangle);\n    middle = new Node(triangle.getPoint(0), triangle);\n    tail = new Node(triangle.getPoint(2));\n\n    this.front_ = new AdvancingFront(head, tail);\n\n    head.next = middle;\n    middle.next = tail;\n    middle.prev = head;\n    tail.prev = middle;\n};\n\n/** @private */\nSweepContext.prototype.removeNode = function(node) {\n    // do nothing\n    /* jshint unused:false */\n};\n\n/** @private */\nSweepContext.prototype.mapTriangleToNodes = function(t) {\n    for (var i = 0; i < 3; ++i) {\n        if (!t.getNeighbor(i)) {\n            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));\n            if (n) {\n                n.triangle = t;\n            }\n        }\n    }\n};\n\n/** @private */\nSweepContext.prototype.removeFromMap = function(triangle) {\n    var i, map = this.map_, len = map.length;\n    for (i = 0; i < len; i++) {\n        if (map[i] === triangle) {\n            map.splice(i, 1);\n            break;\n        }\n    }\n};\n\n/**\n * Do a depth first traversal to collect triangles\n * @private\n * @param {Triangle} triangle start\n */\nSweepContext.prototype.meshClean = function(triangle) {\n    // New implementation avoids recursive calls and use a loop instead.\n    // Cf. issues # 57, 65 and 69.\n    var triangles = [triangle], t, i;\n    /* jshint boss:true */\n    while (t = triangles.pop()) {\n        if (!t.isInterior()) {\n            t.setInterior(true);\n            this.triangles_.push(t);\n            for (i = 0; i < 3; i++) {\n                if (!t.constrained_edge[i]) {\n                    triangles.push(t.getNeighbor(i));\n                }\n            }\n        }\n    }\n};\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = SweepContext;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/sweepcontext.js\n// module id = 11\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * Precision to detect repeated or collinear points\n * @private\n * @const {number}\n * @default\n */\nvar EPSILON = 1e-12;\nexports.EPSILON = EPSILON;\n\n/**\n * @private\n * @enum {number}\n * @readonly\n */\nvar Orientation = {\n    \"CW\": 1,\n    \"CCW\": -1,\n    \"COLLINEAR\": 0\n};\nexports.Orientation = Orientation;\n\n\n/**\n * Formula to calculate signed area<br>\n * Positive if CCW<br>\n * Negative if CW<br>\n * 0 if collinear<br>\n * <pre>\n * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)\n *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)\n * </pre>\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {Orientation}\n */\nfunction orient2d(pa, pb, pc) {\n    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n    var val = detleft - detright;\n    if (val > -(EPSILON) && val < (EPSILON)) {\n        return Orientation.COLLINEAR;\n    } else if (val > 0) {\n        return Orientation.CCW;\n    } else {\n        return Orientation.CW;\n    }\n}\nexports.orient2d = orient2d;\n\n\n/**\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @param {!XY} pd  point object with {x,y}\n * @return {boolean}\n */\nfunction inScanArea(pa, pb, pc, pd) {\n    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);\n    if (oadb >= -EPSILON) {\n        return false;\n    }\n\n    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);\n    if (oadc <= EPSILON) {\n        return false;\n    }\n    return true;\n}\nexports.inScanArea = inScanArea;\n\n\n/**\n * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {boolean} true if angle is obtuse\n */\nfunction isAngleObtuse(pa, pb, pc) {\n    var ax = pb.x - pa.x;\n    var ay = pb.y - pa.y;\n    var bx = pc.x - pa.x;\n    var by = pc.y - pa.y;\n    return (ax * bx + ay * by) < 0;\n}\nexports.isAngleObtuse = isAngleObtuse;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/utils.js\n// module id = 12\n// module chunks = 0","window.eve = require('eve')\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar mina = (function (eve) {\n    var animations = {},\n    requestAnimFrame = window.requestAnimationFrame       ||\n                       window.webkitRequestAnimationFrame ||\n                       window.mozRequestAnimationFrame    ||\n                       window.oRequestAnimationFrame      ||\n                       window.msRequestAnimationFrame     ||\n                       function (callback) {\n                           setTimeout(callback, 16);\n                       },\n    isArray = Array.isArray || function (a) {\n        return a instanceof Array ||\n            Object.prototype.toString.call(a) == \"[object Array]\";\n    },\n    idgen = 0,\n    idprefix = \"M\" + (+new Date).toString(36),\n    ID = function () {\n        return idprefix + (idgen++).toString(36);\n    },\n    diff = function (a, b, A, B) {\n        if (isArray(a)) {\n            res = [];\n            for (var i = 0, ii = a.length; i < ii; i++) {\n                res[i] = diff(a[i], b, A[i], B);\n            }\n            return res;\n        }\n        var dif = (A - a) / (B - b);\n        return function (bb) {\n            return a + dif * (bb - b);\n        };\n    },\n    timer = Date.now || function () {\n        return +new Date;\n    },\n    sta = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.s;\n        }\n        var ds = a.s - val;\n        a.b += a.dur * ds;\n        a.B += a.dur * ds;\n        a.s = val;\n    },\n    speed = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.spd;\n        }\n        a.spd = val;\n    },\n    duration = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.dur;\n        }\n        a.s = a.s * val / a.dur;\n        a.dur = val;\n    },\n    stopit = function () {\n        var a = this;\n        delete animations[a.id];\n        a.update();\n        eve(\"mina.stop.\" + a.id, a);\n    },\n    pause = function () {\n        var a = this;\n        if (a.pdif) {\n            return;\n        }\n        delete animations[a.id];\n        a.update();\n        a.pdif = a.get() - a.b;\n    },\n    resume = function () {\n        var a = this;\n        if (!a.pdif) {\n            return;\n        }\n        a.b = a.get() - a.pdif;\n        delete a.pdif;\n        animations[a.id] = a;\n    },\n    update = function () {\n        var a = this,\n            res;\n        if (isArray(a.start)) {\n            res = [];\n            for (var j = 0, jj = a.start.length; j < jj; j++) {\n                res[j] = +a.start[j] +\n                    (a.end[j] - a.start[j]) * a.easing(a.s);\n            }\n        } else {\n            res = +a.start + (a.end - a.start) * a.easing(a.s);\n        }\n        a.set(res);\n    },\n    frame = function () {\n        var len = 0;\n        for (var i in animations) if (animations.hasOwnProperty(i)) {\n            var a = animations[i],\n                b = a.get(),\n                res;\n            len++;\n            a.s = (b - a.b) / (a.dur / a.spd);\n            if (a.s >= 1) {\n                delete animations[i];\n                a.s = 1;\n                len--;\n                (function (a) {\n                    setTimeout(function () {\n                        eve(\"mina.finish.\" + a.id, a);\n                    });\n                }(a));\n            }\n            a.update();\n        }\n        len && requestAnimFrame(frame);\n    },\n    /*\\\n     * mina\n     [ method ]\n     **\n     * Generic animation of numbers\n     **\n     - a (number) start _slave_ number\n     - A (number) end _slave_ number\n     - b (number) start _master_ number (start time in general case)\n     - B (number) end _master_ number (end time in gereal case)\n     - get (function) getter of _master_ number (see @mina.time)\n     - set (function) setter of _slave_ number\n     - easing (function) #optional easing function, default is @mina.linear\n     = (object) animation descriptor\n     o {\n     o         id (string) animation id,\n     o         start (number) start _slave_ number,\n     o         end (number) end _slave_ number,\n     o         b (number) start _master_ number,\n     o         s (number) animation status (0..1),\n     o         dur (number) animation duration,\n     o         spd (number) animation speed,\n     o         get (function) getter of _master_ number (see @mina.time),\n     o         set (function) setter of _slave_ number,\n     o         easing (function) easing function, default is @mina.linear,\n     o         status (function) status getter/setter,\n     o         speed (function) speed getter/setter,\n     o         duration (function) duration getter/setter,\n     o         stop (function) animation stopper\n     o         pause (function) pauses the animation\n     o         resume (function) resumes the animation\n     o         update (function) calles setter with the right value of the animation\n     o }\n    \\*/\n    mina = function (a, A, b, B, get, set, easing) {\n        var anim = {\n            id: ID(),\n            start: a,\n            end: A,\n            b: b,\n            s: 0,\n            dur: B - b,\n            spd: 1,\n            get: get,\n            set: set,\n            easing: easing || mina.linear,\n            status: sta,\n            speed: speed,\n            duration: duration,\n            stop: stopit,\n            pause: pause,\n            resume: resume,\n            update: update\n        };\n        animations[anim.id] = anim;\n        var len = 0, i;\n        for (i in animations) if (animations.hasOwnProperty(i)) {\n            len++;\n            if (len == 2) {\n                break;\n            }\n        }\n        len == 1 && requestAnimFrame(frame);\n        return anim;\n    };\n    /*\\\n     * mina.time\n     [ method ]\n     **\n     * Returns the current time. Equivalent to:\n     | function () {\n     |     return (new Date).getTime();\n     | }\n    \\*/\n    mina.time = timer;\n    /*\\\n     * mina.getById\n     [ method ]\n     **\n     * Returns an animation by its id\n     - id (string) animation's id\n     = (object) See @mina\n    \\*/\n    mina.getById = function (id) {\n        return animations[id] || null;\n    };\n\n    /*\\\n     * mina.linear\n     [ method ]\n     **\n     * Default linear easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.linear = function (n) {\n        return n;\n    };\n    /*\\\n     * mina.easeout\n     [ method ]\n     **\n     * Easeout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeout = function (n) {\n        return Math.pow(n, 1.7);\n    };\n    /*\\\n     * mina.easein\n     [ method ]\n     **\n     * Easein easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easein = function (n) {\n        return Math.pow(n, .48);\n    };\n    /*\\\n     * mina.easeinout\n     [ method ]\n     **\n     * Easeinout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeinout = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        var q = .48 - n / 1.04,\n            Q = Math.sqrt(.1734 + q * q),\n            x = Q - q,\n            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n            y = -Q - q,\n            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n            t = X + Y + .5;\n        return (1 - t) * 3 * t * t + t * t * t;\n    };\n    /*\\\n     * mina.backin\n     [ method ]\n     **\n     * Backin easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backin = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        var s = 1.70158;\n        return n * n * ((s + 1) * n - s);\n    };\n    /*\\\n     * mina.backout\n     [ method ]\n     **\n     * Backout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backout = function (n) {\n        if (n == 0) {\n            return 0;\n        }\n        n = n - 1;\n        var s = 1.70158;\n        return n * n * ((s + 1) * n + s) + 1;\n    };\n    /*\\\n     * mina.elastic\n     [ method ]\n     **\n     * Elastic easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.elastic = function (n) {\n        if (n == !!n) {\n            return n;\n        }\n        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n            (2 * Math.PI) / .3) + 1;\n    };\n    /*\\\n     * mina.bounce\n     [ method ]\n     **\n     * Bounce easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.bounce = function (n) {\n        var s = 7.5625,\n            p = 2.75,\n            l;\n        if (n < (1 / p)) {\n            l = s * n * n;\n        } else {\n            if (n < (2 / p)) {\n                n -= (1.5 / p);\n                l = s * n * n + .75;\n            } else {\n                if (n < (2.5 / p)) {\n                    n -= (2.25 / p);\n                    l = s * n * n + .9375;\n                } else {\n                    n -= (2.625 / p);\n                    l = s * n * n + .984375;\n                }\n            }\n        }\n        return l;\n    };\n    window.mina = mina;\n    return mina;\n})(typeof eve == \"undefined\" ? function () {} : eve);\n// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar Snap = (function(root) {\nSnap.version = \"0.4.0\";\n/*\\\n * Snap\n [ method ]\n **\n * Creates a drawing surface or wraps existing SVG element.\n **\n - width (number|string) width of surface\n - height (number|string) height of surface\n * or\n - DOM (SVGElement) element to be wrapped into Snap structure\n * or\n - array (array) array of elements (will return set of elements)\n * or\n - query (string) CSS query selector\n = (object) @Element\n\\*/\nfunction Snap(w, h) {\n    if (w) {\n        if (w.nodeType) {\n            return wrap(w);\n        }\n        if (is(w, \"array\") && Snap.set) {\n            return Snap.set.apply(Snap, w);\n        }\n        if (w instanceof Element) {\n            return w;\n        }\n        if (h == null) {\n            w = glob.doc.querySelector(String(w));\n            return wrap(w);\n        }\n    }\n    w = w == null ? \"100%\" : w;\n    h = h == null ? \"100%\" : h;\n    return new Paper(w, h);\n}\nSnap.toString = function () {\n    return \"Snap v\" + this.version;\n};\nSnap._ = {};\nvar glob = {\n    win: root.window,\n    doc: root.window.document\n};\nSnap._.glob = glob;\nvar has = \"hasOwnProperty\",\n    Str = String,\n    toFloat = parseFloat,\n    toInt = parseInt,\n    math = Math,\n    mmax = math.max,\n    mmin = math.min,\n    abs = math.abs,\n    pow = math.pow,\n    PI = math.PI,\n    round = math.round,\n    E = \"\",\n    S = \" \",\n    objectToString = Object.prototype.toString,\n    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n    reURLValue = /^url\\(#?([^)]+)\\)$/,\n    separator = Snap._.separator = /[,\\s]+/,\n    whitespace = /[\\s]/g,\n    commaSpaces = /[\\s]*,[\\s]*/,\n    hsrg = {hs: 1, rg: 1},\n    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\\\d+)?)[\\s]*,?[\\s]*/ig,\n    idgen = 0,\n    idprefix = \"S\" + (+new Date).toString(36),\n    ID = function (el) {\n        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n    },\n    xlink = \"http://www.w3.org/1999/xlink\",\n    xmlns = \"http://www.w3.org/2000/svg\",\n    hub = {},\n    URL = Snap.url = function (url) {\n        return \"url('#\" + url + \"')\";\n    };\n\nfunction $(el, attr) {\n    if (attr) {\n        if (el == \"#text\") {\n            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (el == \"#comment\") {\n            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (typeof el == \"string\") {\n            el = $(el);\n        }\n        if (typeof attr == \"string\") {\n            if (el.nodeType == 1) {\n                if (attr.substring(0, 6) == \"xlink:\") {\n                    return el.getAttributeNS(xlink, attr.substring(6));\n                }\n                if (attr.substring(0, 4) == \"xml:\") {\n                    return el.getAttributeNS(xmlns, attr.substring(4));\n                }\n                return el.getAttribute(attr);\n            } else if (attr == \"text\") {\n                return el.nodeValue;\n            } else {\n                return null;\n            }\n        }\n        if (el.nodeType == 1) {\n            for (var key in attr) if (attr[has](key)) {\n                var val = Str(attr[key]);\n                if (val) {\n                    if (key.substring(0, 6) == \"xlink:\") {\n                        el.setAttributeNS(xlink, key.substring(6), val);\n                    } else if (key.substring(0, 4) == \"xml:\") {\n                        el.setAttributeNS(xmlns, key.substring(4), val);\n                    } else {\n                        el.setAttribute(key, val);\n                    }\n                } else {\n                    el.removeAttribute(key);\n                }\n            }\n        } else if (\"text\" in attr) {\n            el.nodeValue = attr.text;\n        }\n    } else {\n        el = glob.doc.createElementNS(xmlns, el);\n    }\n    return el;\n}\nSnap._.$ = $;\nSnap._.id = ID;\nfunction getAttrs(el) {\n    var attrs = el.attributes,\n        name,\n        out = {};\n    for (var i = 0; i < attrs.length; i++) {\n        if (attrs[i].namespaceURI == xlink) {\n            name = \"xlink:\";\n        } else {\n            name = \"\";\n        }\n        name += attrs[i].name;\n        out[name] = attrs[i].textContent;\n    }\n    return out;\n}\nfunction is(o, type) {\n    type = Str.prototype.toLowerCase.call(type);\n    if (type == \"finite\") {\n        return isFinite(o);\n    }\n    if (type == \"array\" &&\n        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n        return true;\n    }\n    return  (type == \"null\" && o === null) ||\n            (type == typeof o && o !== null) ||\n            (type == \"object\" && o === Object(o)) ||\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n}\n/*\\\n * Snap.format\n [ method ]\n **\n * Replaces construction of type `{<name>}` to the corresponding argument\n **\n - token (string) string to format\n - json (object) object which properties are used as a replacement\n = (string) formatted string\n > Usage\n | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n |     x: 10,\n |     y: 20,\n |     dim: {\n |         width: 40,\n |         height: 50,\n |         \"negative width\": -40\n |     }\n | }));\n\\*/\nSnap.format = (function () {\n    var tokenRegex = /\\{([^\\}]+)\\}/g,\n        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n        replacer = function (all, key, obj) {\n            var res = obj;\n            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n                if (res) {\n                    if (name in res) {\n                        res = res[name];\n                    }\n                    typeof res == \"function\" && isFunc && (res = res());\n                }\n            });\n            res = (res == null || res == obj ? all : res) + \"\";\n            return res;\n        };\n    return function (str, obj) {\n        return Str(str).replace(tokenRegex, function (all, key) {\n            return replacer(all, key, obj);\n        });\n    };\n})();\nfunction clone(obj) {\n    if (typeof obj == \"function\" || Object(obj) !== obj) {\n        return obj;\n    }\n    var res = new obj.constructor;\n    for (var key in obj) if (obj[has](key)) {\n        res[key] = clone(obj[key]);\n    }\n    return res;\n}\nSnap._.clone = clone;\nfunction repush(array, item) {\n    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n        return array.push(array.splice(i, 1)[0]);\n    }\n}\nfunction cacher(f, scope, postprocessor) {\n    function newf() {\n        var arg = Array.prototype.slice.call(arguments, 0),\n            args = arg.join(\"\\u2400\"),\n            cache = newf.cache = newf.cache || {},\n            count = newf.count = newf.count || [];\n        if (cache[has](args)) {\n            repush(count, args);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        count.length >= 1e3 && delete cache[count.shift()];\n        count.push(args);\n        cache[args] = f.apply(scope, arg);\n        return postprocessor ? postprocessor(cache[args]) : cache[args];\n    }\n    return newf;\n}\nSnap._.cacher = cacher;\nfunction angle(x1, y1, x2, y2, x3, y3) {\n    if (x3 == null) {\n        var x = x1 - x2,\n            y = y1 - y2;\n        if (!x && !y) {\n            return 0;\n        }\n        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n    } else {\n        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n    }\n}\nfunction rad(deg) {\n    return deg % 360 * PI / 180;\n}\nfunction deg(rad) {\n    return rad * 180 / PI % 360;\n}\nfunction x_y() {\n    return this.x + S + this.y;\n}\nfunction x_y_w_h() {\n    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n}\n\n/*\\\n * Snap.rad\n [ method ]\n **\n * Transform angle to radians\n - deg (number) angle in degrees\n = (number) angle in radians\n\\*/\nSnap.rad = rad;\n/*\\\n * Snap.deg\n [ method ]\n **\n * Transform angle to degrees\n - rad (number) angle in radians\n = (number) angle in degrees\n\\*/\nSnap.deg = deg;\n/*\\\n * Snap.sin\n [ method ]\n **\n * Equivalent to `Math.sin()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) sin\n\\*/\nSnap.sin = function (angle) {\n    return math.sin(Snap.rad(angle));\n};\n/*\\\n * Snap.tan\n [ method ]\n **\n * Equivalent to `Math.tan()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) tan\n\\*/\nSnap.tan = function (angle) {\n    return math.tan(Snap.rad(angle));\n};\n/*\\\n * Snap.cos\n [ method ]\n **\n * Equivalent to `Math.cos()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) cos\n\\*/\nSnap.cos = function (angle) {\n    return math.cos(Snap.rad(angle));\n};\n/*\\\n * Snap.asin\n [ method ]\n **\n * Equivalent to `Math.asin()` only works with degrees, not radians.\n - num (number) value\n = (number) asin in degrees\n\\*/\nSnap.asin = function (num) {\n    return Snap.deg(math.asin(num));\n};\n/*\\\n * Snap.acos\n [ method ]\n **\n * Equivalent to `Math.acos()` only works with degrees, not radians.\n - num (number) value\n = (number) acos in degrees\n\\*/\nSnap.acos = function (num) {\n    return Snap.deg(math.acos(num));\n};\n/*\\\n * Snap.atan\n [ method ]\n **\n * Equivalent to `Math.atan()` only works with degrees, not radians.\n - num (number) value\n = (number) atan in degrees\n\\*/\nSnap.atan = function (num) {\n    return Snap.deg(math.atan(num));\n};\n/*\\\n * Snap.atan2\n [ method ]\n **\n * Equivalent to `Math.atan2()` only works with degrees, not radians.\n - num (number) value\n = (number) atan2 in degrees\n\\*/\nSnap.atan2 = function (num) {\n    return Snap.deg(math.atan2(num));\n};\n/*\\\n * Snap.angle\n [ method ]\n **\n * Returns an angle between two or three points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n - x3 (number) #optional x coord of third point\n - y3 (number) #optional y coord of third point\n = (number) angle in degrees\n\\*/\nSnap.angle = angle;\n/*\\\n * Snap.len\n [ method ]\n **\n * Returns distance between two points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len = function (x1, y1, x2, y2) {\n    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n};\n/*\\\n * Snap.len2\n [ method ]\n **\n * Returns squared distance between two points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len2 = function (x1, y1, x2, y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n};\n/*\\\n * Snap.closestPoint\n [ method ]\n **\n * Returns closest point to a given one on a given path.\n > Parameters\n - path (Element) path element\n - x (number) x coord of a point\n - y (number) y coord of a point\n = (object) in format\n {\n    x (number) x coord of the point on the path\n    y (number) y coord of the point on the path\n    length (number) length of the path to the point\n    distance (number) distance from the given point to the path\n }\n\\*/\n// Copied from http://bl.ocks.org/mbostock/8027637\nSnap.closestPoint = function (path, x, y) {\n    function distance2(p) {\n        var dx = p.x - x,\n            dy = p.y - y;\n        return dx * dx + dy * dy;\n    }\n    var pathNode = path.node,\n        pathLength = pathNode.getTotalLength(),\n        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n        best,\n        bestLength,\n        bestDistance = Infinity;\n\n    // linear scan for coarse approximation\n    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n            best = scan, bestLength = scanLength, bestDistance = scanDistance;\n        }\n    }\n\n    // binary search for precise estimate\n    precision *= .5;\n    while (precision > .5) {\n        var before,\n            after,\n            beforeLength,\n            afterLength,\n            beforeDistance,\n            afterDistance;\n        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n            best = before, bestLength = beforeLength, bestDistance = beforeDistance;\n        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n            best = after, bestLength = afterLength, bestDistance = afterDistance;\n        } else {\n            precision *= .5;\n        }\n    }\n\n    best = {\n        x: best.x,\n        y: best.y,\n        length: bestLength,\n        distance: Math.sqrt(bestDistance)\n    };\n    return best;\n}\n/*\\\n * Snap.is\n [ method ]\n **\n * Handy replacement for the `typeof` operator\n - o (…) any object or primitive\n - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n = (boolean) `true` if given value is of given type\n\\*/\nSnap.is = is;\n/*\\\n * Snap.snapTo\n [ method ]\n **\n * Snaps given value to given grid\n - values (array|number) given array of values or step of the grid\n - value (number) value to adjust\n - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n = (number) adjusted value\n\\*/\nSnap.snapTo = function (values, value, tolerance) {\n    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n    if (is(values, \"array\")) {\n        var i = values.length;\n        while (i--) if (abs(values[i] - value) <= tolerance) {\n            return values[i];\n        }\n    } else {\n        values = +values;\n        var rem = value % values;\n        if (rem < tolerance) {\n            return value - rem;\n        }\n        if (rem > values - tolerance) {\n            return value - rem + values;\n        }\n    }\n    return value;\n};\n// Colour\n/*\\\n * Snap.getRGB\n [ method ]\n **\n * Parses color string as RGB object\n - color (string) color string in one of the following formats:\n # <ul>\n #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>\n # </ul>\n * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) true if string can't be parsed\n o }\n\\*/\nSnap.getRGB = cacher(function (colour) {\n    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    if (colour == \"none\") {\n        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n    }\n    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n    if (!colour) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    var res,\n        red,\n        green,\n        blue,\n        opacity,\n        t,\n        values,\n        rgb = colour.match(colourRegExp);\n    if (rgb) {\n        if (rgb[2]) {\n            blue = toInt(rgb[2].substring(5), 16);\n            green = toInt(rgb[2].substring(3, 5), 16);\n            red = toInt(rgb[2].substring(1, 3), 16);\n        }\n        if (rgb[3]) {\n            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n        }\n        if (rgb[4]) {\n            values = rgb[4].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red *= 2.55);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green *= 2.55);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n        }\n        if (rgb[5]) {\n            values = rgb[5].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsb2rgb(red, green, blue, opacity);\n        }\n        if (rgb[6]) {\n            values = rgb[6].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsl2rgb(red, green, blue, opacity);\n        }\n        red = mmin(math.round(red), 255);\n        green = mmin(math.round(green), 255);\n        blue = mmin(math.round(blue), 255);\n        opacity = mmin(mmax(opacity, 0), 1);\n        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n        return rgb;\n    }\n    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n}, Snap);\n/*\\\n * Snap.hsb\n [ method ]\n **\n * Converts HSB values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - b (number) value or brightness\n = (string) hex representation of the color\n\\*/\nSnap.hsb = cacher(function (h, s, b) {\n    return Snap.hsb2rgb(h, s, b).hex;\n});\n/*\\\n * Snap.hsl\n [ method ]\n **\n * Converts HSL values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (string) hex representation of the color\n\\*/\nSnap.hsl = cacher(function (h, s, l) {\n    return Snap.hsl2rgb(h, s, l).hex;\n});\n/*\\\n * Snap.rgb\n [ method ]\n **\n * Converts RGB values to a hex representation of the color\n - r (number) red\n - g (number) green\n - b (number) blue\n = (string) hex representation of the color\n\\*/\nSnap.rgb = cacher(function (r, g, b, o) {\n    if (is(o, \"finite\")) {\n        var round = math.round;\n        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n    }\n    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n});\nvar toHex = function (color) {\n    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n        red = \"rgb(255, 0, 0)\";\n    toHex = cacher(function (color) {\n        if (color.toLowerCase() == \"red\") {\n            return red;\n        }\n        i.style.color = red;\n        i.style.color = color;\n        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n        return out == red ? null : out;\n    });\n    return toHex(color);\n},\nhsbtoString = function () {\n    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n},\nhsltoString = function () {\n    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n},\nrgbtoString = function () {\n    return this.opacity == 1 || this.opacity == null ?\n            this.hex :\n            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n},\nprepareRGB = function (r, g, b) {\n    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n        b = r.b;\n        g = r.g;\n        r = r.r;\n    }\n    if (g == null && is(r, string)) {\n        var clr = Snap.getRGB(r);\n        r = clr.r;\n        g = clr.g;\n        b = clr.b;\n    }\n    if (r > 1 || g > 1 || b > 1) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n    }\n\n    return [r, g, b];\n},\npackageRGB = function (r, g, b, o) {\n    r = math.round(r * 255);\n    g = math.round(g * 255);\n    b = math.round(b * 255);\n    var rgb = {\n        r: r,\n        g: g,\n        b: b,\n        opacity: is(o, \"finite\") ? o : 1,\n        hex: Snap.rgb(r, g, b),\n        toString: rgbtoString\n    };\n    is(o, \"finite\") && (rgb.opacity = o);\n    return rgb;\n};\n/*\\\n * Snap.color\n [ method ]\n **\n * Parses the color string and returns an object featuring the color's component values\n - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n = (object) Combined RGB/HSB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) `true` if string can't be parsed,\n o     h (number) hue,\n o     s (number) saturation,\n o     v (number) value (brightness),\n o     l (number) lightness\n o }\n\\*/\nSnap.color = function (clr) {\n    var rgb;\n    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n        rgb = Snap.hsb2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n        rgb = Snap.hsl2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else {\n        if (is(clr, \"string\")) {\n            clr = Snap.getRGB(clr);\n        }\n        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n            rgb = Snap.rgb2hsl(clr);\n            clr.h = rgb.h;\n            clr.s = rgb.s;\n            clr.l = rgb.l;\n            rgb = Snap.rgb2hsb(clr);\n            clr.v = rgb.b;\n        } else {\n            clr = {hex: \"none\"};\n            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n            clr.error = 1;\n        }\n    }\n    clr.toString = rgbtoString;\n    return clr;\n};\n/*\\\n * Snap.hsb2rgb\n [ method ]\n **\n * Converts HSB values to an RGB object\n - h (number) hue\n - s (number) saturation\n - v (number) value or brightness\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n\\*/\nSnap.hsb2rgb = function (h, s, v, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n        v = h.b;\n        s = h.s;\n        o = h.o;\n        h = h.h;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = v * s;\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = v - C;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.hsl2rgb\n [ method ]\n **\n * Converts HSL values to an RGB object\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n\\*/\nSnap.hsl2rgb = function (h, s, l, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n    }\n    if (h > 1 || s > 1 || l > 1) {\n        h /= 360;\n        s /= 100;\n        l /= 100;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = 2 * s * (l < .5 ? l : 1 - l);\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = l - C / 2;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.rgb2hsb\n [ method ]\n **\n * Converts RGB values to an HSB object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSB object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     b (number) brightness\n o }\n\\*/\nSnap.rgb2hsb = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, V, C;\n    V = mmax(r, g, b);\n    C = V - mmin(r, g, b);\n    H = (C == 0 ? null :\n         V == r ? (g - b) / C :\n         V == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4\n        );\n    H = ((H + 360) % 6) * 60 / 360;\n    S = C == 0 ? 0 : C / V;\n    return {h: H, s: S, b: V, toString: hsbtoString};\n};\n/*\\\n * Snap.rgb2hsl\n [ method ]\n **\n * Converts RGB values to an HSL object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSL object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     l (number) luminosity\n o }\n\\*/\nSnap.rgb2hsl = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, L, M, m, C;\n    M = mmax(r, g, b);\n    m = mmin(r, g, b);\n    C = M - m;\n    H = (C == 0 ? null :\n         M == r ? (g - b) / C :\n         M == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4);\n    H = ((H + 360) % 6) * 60 / 360;\n    L = (M + m) / 2;\n    S = (C == 0 ? 0 :\n         L < .5 ? C / (2 * L) :\n                  C / (2 - 2 * L));\n    return {h: H, s: S, l: L, toString: hsltoString};\n};\n\n// Transformations\n/*\\\n * Snap.parsePathString\n [ method ]\n **\n * Utility method\n **\n * Parses given path string into an array of arrays of path segments\n - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n = (array) array of segments\n\\*/\nSnap.parsePathString = function (pathString) {\n    if (!pathString) {\n        return null;\n    }\n    var pth = Snap.path(pathString);\n    if (pth.arr) {\n        return Snap.path.clone(pth.arr);\n    }\n\n    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n        data = [];\n    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(pathString);\n    }\n    if (!data.length) {\n        Str(pathString).replace(pathCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            if (name == \"m\" && params.length > 2) {\n                data.push([b].concat(params.splice(0, 2)));\n                name = \"l\";\n                b = b == \"m\" ? \"l\" : \"L\";\n            }\n            if (name == \"o\" && params.length == 1) {\n                data.push([b, params[0]]);\n            }\n            if (name == \"r\") {\n                data.push([b].concat(params));\n            } else while (params.length >= paramCounts[name]) {\n                data.push([b].concat(params.splice(0, paramCounts[name])));\n                if (!paramCounts[name]) {\n                    break;\n                }\n            }\n        });\n    }\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n};\n/*\\\n * Snap.parseTransformString\n [ method ]\n **\n * Utility method\n **\n * Parses given transform string into an array of transformations\n - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n = (array) array of transformations\n\\*/\nvar parseTransformString = Snap.parseTransformString = function (TString) {\n    if (!TString) {\n        return null;\n    }\n    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n        data = [];\n    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(TString);\n    }\n    if (!data.length) {\n        Str(TString).replace(tCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            data.push([b].concat(params));\n        });\n    }\n    data.toString = Snap.path.toString;\n    return data;\n};\nfunction svgTransform2string(tstr) {\n    var res = [];\n    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n        params = params.split(/\\s*,\\s*|\\s+/);\n        if (name == \"rotate\" && params.length == 1) {\n            params.push(0, 0);\n        }\n        if (name == \"scale\") {\n            if (params.length > 2) {\n                params = params.slice(0, 2);\n            } else if (params.length == 2) {\n                params.push(0, 0);\n            }\n            if (params.length == 1) {\n                params.push(params[0], 0, 0);\n            }\n        }\n        if (name == \"skewX\") {\n            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n        } else if (name == \"skewY\") {\n            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n        } else {\n            res.push([name.charAt(0)].concat(params));\n        }\n        return all;\n    });\n    return res;\n}\nSnap._.svgTransform2string = svgTransform2string;\nSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\nfunction transform2matrix(tstr, bbox) {\n    var tdata = parseTransformString(tstr),\n        m = new Snap.Matrix;\n    if (tdata) {\n        for (var i = 0, ii = tdata.length; i < ii; i++) {\n            var t = tdata[i],\n                tlen = t.length,\n                command = Str(t[0]).toLowerCase(),\n                absolute = t[0] != command,\n                inver = absolute ? m.invert() : 0,\n                x1,\n                y1,\n                x2,\n                y2,\n                bb;\n            if (command == \"t\" && tlen == 2){\n                m.translate(t[1], 0);\n            } else if (command == \"t\" && tlen == 3) {\n                if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                } else {\n                    m.translate(t[1], t[2]);\n                }\n            } else if (command == \"r\") {\n                if (tlen == 2) {\n                    bb = bb || bbox;\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.rotate(t[1], x2, y2);\n                    } else {\n                        m.rotate(t[1], t[2], t[3]);\n                    }\n                }\n            } else if (command == \"s\") {\n                if (tlen == 2 || tlen == 3) {\n                    bb = bb || bbox;\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.scale(t[1], t[1], x2, y2);\n                    } else {\n                        m.scale(t[1], t[1], t[2], t[3]);\n                    }\n                } else if (tlen == 5) {\n                    if (absolute) {\n                        x2 = inver.x(t[3], t[4]);\n                        y2 = inver.y(t[3], t[4]);\n                        m.scale(t[1], t[2], x2, y2);\n                    } else {\n                        m.scale(t[1], t[2], t[3], t[4]);\n                    }\n                }\n            } else if (command == \"m\" && tlen == 7) {\n                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n            }\n        }\n    }\n    return m;\n}\nSnap._.transform2matrix = transform2matrix;\nSnap._unit2px = unit2px;\nvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n    function (a, b) {\n        var adown = a.nodeType == 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a == bup || !!(bup && bup.nodeType == 1 && (\n                adown.contains ?\n                    adown.contains(bup) :\n                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n            ));\n    } :\n    function (a, b) {\n        if (b) {\n            while (b) {\n                b = b.parentNode;\n                if (b == a) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\nfunction getSomeDefs(el) {\n    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n            (el.node.parentNode && wrap(el.node.parentNode)) ||\n            Snap.select(\"svg\") ||\n            Snap(0, 0),\n        pdefs = p.select(\"defs\"),\n        defs  = pdefs == null ? false : pdefs.node;\n    if (!defs) {\n        defs = make(\"defs\", p.node).node;\n    }\n    return defs;\n}\nfunction getSomeSVG(el) {\n    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n}\nSnap._.getSomeDefs = getSomeDefs;\nSnap._.getSomeSVG = getSomeSVG;\nfunction unit2px(el, name, value) {\n    var svg = getSomeSVG(el).node,\n        out = {},\n        mgr = svg.querySelector(\".svg---mgr\");\n    if (!mgr) {\n        mgr = $(\"rect\");\n        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n        svg.appendChild(mgr);\n    }\n    function getW(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {width: val});\n        try {\n            return mgr.getBBox().width;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function getH(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {height: val});\n        try {\n            return mgr.getBBox().height;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function set(nam, f) {\n        if (name == null) {\n            out[nam] = f(el.attr(nam) || 0);\n        } else if (nam == name) {\n            out = f(value == null ? el.attr(nam) || 0 : value);\n        }\n    }\n    switch (el.type) {\n        case \"rect\":\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        case \"image\":\n            set(\"width\", getW);\n            set(\"height\", getH);\n        case \"text\":\n            set(\"x\", getW);\n            set(\"y\", getH);\n        break;\n        case \"circle\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"r\", getW);\n        break;\n        case \"ellipse\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        break;\n        case \"line\":\n            set(\"x1\", getW);\n            set(\"x2\", getW);\n            set(\"y1\", getH);\n            set(\"y2\", getH);\n        break;\n        case \"marker\":\n            set(\"refX\", getW);\n            set(\"markerWidth\", getW);\n            set(\"refY\", getH);\n            set(\"markerHeight\", getH);\n        break;\n        case \"radialGradient\":\n            set(\"fx\", getW);\n            set(\"fy\", getH);\n        break;\n        case \"tspan\":\n            set(\"dx\", getW);\n            set(\"dy\", getH);\n        break;\n        default:\n            set(name, getW);\n    }\n    svg.removeChild(mgr);\n    return out;\n}\n/*\\\n * Snap.select\n [ method ]\n **\n * Wraps a DOM element specified by CSS selector as @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.select = function (query) {\n    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n    return wrap(glob.doc.querySelector(query));\n};\n/*\\\n * Snap.selectAll\n [ method ]\n **\n * Wraps DOM elements specified by CSS selector as set or array of @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.selectAll = function (query) {\n    var nodelist = glob.doc.querySelectorAll(query),\n        set = (Snap.set || Array)();\n    for (var i = 0; i < nodelist.length; i++) {\n        set.push(wrap(nodelist[i]));\n    }\n    return set;\n};\n\nfunction add2group(list) {\n    if (!is(list, \"array\")) {\n        list = Array.prototype.slice.call(arguments, 0);\n    }\n    var i = 0,\n        j = 0,\n        node = this.node;\n    while (this[i]) delete this[i++];\n    for (i = 0; i < list.length; i++) {\n        if (list[i].type == \"set\") {\n            list[i].forEach(function (el) {\n                node.appendChild(el.node);\n            });\n        } else {\n            node.appendChild(list[i].node);\n        }\n    }\n    var children = node.childNodes;\n    for (i = 0; i < children.length; i++) {\n        this[j++] = wrap(children[i]);\n    }\n    return this;\n}\n// Hub garbage collector every 10s\nsetInterval(function () {\n    for (var key in hub) if (hub[has](key)) {\n        var el = hub[key],\n            node = el.node;\n        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n            delete hub[key];\n        }\n    }\n}, 1e4);\nfunction Element(el) {\n    if (el.snap in hub) {\n        return hub[el.snap];\n    }\n    var svg;\n    try {\n        svg = el.ownerSVGElement;\n    } catch(e) {}\n    /*\\\n     * Element.node\n     [ property (object) ]\n     **\n     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n     > Usage\n     | // draw a circle at coordinate 10,10 with radius of 10\n     | var c = paper.circle(10, 10, 10);\n     | c.node.onclick = function () {\n     |     c.attr(\"fill\", \"red\");\n     | };\n    \\*/\n    this.node = el;\n    if (svg) {\n        this.paper = new Paper(svg);\n    }\n    /*\\\n     * Element.type\n     [ property (string) ]\n     **\n     * SVG tag name of the given element.\n    \\*/\n    this.type = el.tagName || el.nodeName;\n    var id = this.id = ID(this);\n    this.anims = {};\n    this._ = {\n        transform: []\n    };\n    el.snap = id;\n    hub[id] = this;\n    if (this.type == \"g\") {\n        this.add = add2group;\n    }\n    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n            this[method] = Paper.prototype[method];\n        }\n    }\n}\n   /*\\\n     * Element.attr\n     [ method ]\n     **\n     * Gets or sets given attributes of the element.\n     **\n     - params (object) contains key-value pairs of attributes you want to set\n     * or\n     - param (string) name of the attribute\n     = (Element) the current element\n     * or\n     = (string) value of attribute\n     > Usage\n     | el.attr({\n     |     fill: \"#fc0\",\n     |     stroke: \"#000\",\n     |     strokeWidth: 2, // CamelCase...\n     |     \"fill-opacity\": 0.5, // or dash-separated names\n     |     width: \"*=2\" // prefixed values\n     | });\n     | console.log(el.attr(\"fill\")); // #fc0\n     * Prefixed values in format `\"+=10\"` supported. All four operations\n     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n     * and `-`: `\"+=2em\"`.\n    \\*/\n    Element.prototype.attr = function (params, value) {\n        var el = this,\n            node = el.node;\n        if (!params) {\n            if (node.nodeType != 1) {\n                return {\n                    text: node.nodeValue\n                };\n            }\n            var attr = node.attributes,\n                out = {};\n            for (var i = 0, ii = attr.length; i < ii; i++) {\n                out[attr[i].nodeName] = attr[i].nodeValue;\n            }\n            return out;\n        }\n        if (is(params, \"string\")) {\n            if (arguments.length > 1) {\n                var json = {};\n                json[params] = value;\n                params = json;\n            } else {\n                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n            }\n        }\n        for (var att in params) {\n            if (params[has](att)) {\n                eve(\"snap.util.attr.\" + att, el, params[att]);\n            }\n        }\n        return el;\n    };\n/*\\\n * Snap.parse\n [ method ]\n **\n * Parses SVG fragment and converts it into a @Fragment\n **\n - svg (string) SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.parse = function (svg) {\n    var f = glob.doc.createDocumentFragment(),\n        full = true,\n        div = glob.doc.createElement(\"div\");\n    svg = Str(svg);\n    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n        svg = \"<svg>\" + svg + \"</svg>\";\n        full = false;\n    }\n    div.innerHTML = svg;\n    svg = div.getElementsByTagName(\"svg\")[0];\n    if (svg) {\n        if (full) {\n            f = svg;\n        } else {\n            while (svg.firstChild) {\n                f.appendChild(svg.firstChild);\n            }\n        }\n    }\n    return new Fragment(f);\n};\nfunction Fragment(frag) {\n    this.node = frag;\n}\n/*\\\n * Snap.fragment\n [ method ]\n **\n * Creates a DOM fragment from a given list of elements or strings\n **\n - varargs (…) SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.fragment = function () {\n    var args = Array.prototype.slice.call(arguments, 0),\n        f = glob.doc.createDocumentFragment();\n    for (var i = 0, ii = args.length; i < ii; i++) {\n        var item = args[i];\n        if (item.node && item.node.nodeType) {\n            f.appendChild(item.node);\n        }\n        if (item.nodeType) {\n            f.appendChild(item);\n        }\n        if (typeof item == \"string\") {\n            f.appendChild(Snap.parse(item).node);\n        }\n    }\n    return new Fragment(f);\n};\n\nfunction make(name, parent) {\n    var res = $(name);\n    parent.appendChild(res);\n    var el = wrap(res);\n    return el;\n}\nfunction Paper(w, h) {\n    var res,\n        desc,\n        defs,\n        proto = Paper.prototype;\n    if (w && w.tagName == \"svg\") {\n        if (w.snap in hub) {\n            return hub[w.snap];\n        }\n        var doc = w.ownerDocument;\n        res = new Element(w);\n        desc = w.getElementsByTagName(\"desc\")[0];\n        defs = w.getElementsByTagName(\"defs\")[0];\n        if (!desc) {\n            desc = $(\"desc\");\n            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n            res.node.appendChild(desc);\n        }\n        if (!defs) {\n            defs = $(\"defs\");\n            res.node.appendChild(defs);\n        }\n        res.defs = defs;\n        for (var key in proto) if (proto[has](key)) {\n            res[key] = proto[key];\n        }\n        res.paper = res.root = res;\n    } else {\n        res = make(\"svg\", glob.doc.body);\n        $(res.node, {\n            height: h,\n            version: 1.1,\n            width: w,\n            xmlns: xmlns\n        });\n    }\n    return res;\n}\nfunction wrap(dom) {\n    if (!dom) {\n        return dom;\n    }\n    if (dom instanceof Element || dom instanceof Fragment) {\n        return dom;\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n        return new Paper(dom);\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n    }\n    return new Element(dom);\n}\n\nSnap._.make = make;\nSnap._.wrap = wrap;\n/*\\\n * Paper.el\n [ method ]\n **\n * Creates an element on paper with a given name and no attributes\n **\n - name (string) tag name\n - attr (object) attributes\n = (Element) the current element\n > Usage\n | var c = paper.circle(10, 10, 10); // is the same as...\n | var c = paper.el(\"circle\").attr({\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n | // and the same as\n | var c = paper.el(\"circle\", {\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n\\*/\nPaper.prototype.el = function (name, attr) {\n    var el = make(name, this.node);\n    attr && el.attr(attr);\n    return el;\n};\n/*\\\n * Element.children\n [ method ]\n **\n * Returns array of all the children of the element.\n = (array) array of Elements\n\\*/\nElement.prototype.children = function () {\n    var out = [],\n        ch = this.node.childNodes;\n    for (var i = 0, ii = ch.length; i < ii; i++) {\n        out[i] = Snap(ch[i]);\n    }\n    return out;\n};\nfunction jsonFiller(root, o) {\n    for (var i = 0, ii = root.length; i < ii; i++) {\n        var item = {\n                type: root[i].type,\n                attr: root[i].attr()\n            },\n            children = root[i].children();\n        o.push(item);\n        if (children.length) {\n            jsonFiller(children, item.childNodes = []);\n        }\n    }\n}\n/*\\\n * Element.toJSON\n [ method ]\n **\n * Returns object representation of the given element and all its children.\n = (object) in format\n o {\n o     type (string) this.type,\n o     attr (object) attributes map,\n o     childNodes (array) optional array of children in the same format\n o }\n\\*/\nElement.prototype.toJSON = function () {\n    var out = [];\n    jsonFiller([this], out);\n    return out[0];\n};\n// default\neve.on(\"snap.util.getattr\", function () {\n    var att = eve.nt();\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    var css = att.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n    });\n    if (cssAttr[has](css)) {\n        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n    } else {\n        return $(this.node, att);\n    }\n});\nvar cssAttr = {\n    \"alignment-baseline\": 0,\n    \"baseline-shift\": 0,\n    \"clip\": 0,\n    \"clip-path\": 0,\n    \"clip-rule\": 0,\n    \"color\": 0,\n    \"color-interpolation\": 0,\n    \"color-interpolation-filters\": 0,\n    \"color-profile\": 0,\n    \"color-rendering\": 0,\n    \"cursor\": 0,\n    \"direction\": 0,\n    \"display\": 0,\n    \"dominant-baseline\": 0,\n    \"enable-background\": 0,\n    \"fill\": 0,\n    \"fill-opacity\": 0,\n    \"fill-rule\": 0,\n    \"filter\": 0,\n    \"flood-color\": 0,\n    \"flood-opacity\": 0,\n    \"font\": 0,\n    \"font-family\": 0,\n    \"font-size\": 0,\n    \"font-size-adjust\": 0,\n    \"font-stretch\": 0,\n    \"font-style\": 0,\n    \"font-variant\": 0,\n    \"font-weight\": 0,\n    \"glyph-orientation-horizontal\": 0,\n    \"glyph-orientation-vertical\": 0,\n    \"image-rendering\": 0,\n    \"kerning\": 0,\n    \"letter-spacing\": 0,\n    \"lighting-color\": 0,\n    \"marker\": 0,\n    \"marker-end\": 0,\n    \"marker-mid\": 0,\n    \"marker-start\": 0,\n    \"mask\": 0,\n    \"opacity\": 0,\n    \"overflow\": 0,\n    \"pointer-events\": 0,\n    \"shape-rendering\": 0,\n    \"stop-color\": 0,\n    \"stop-opacity\": 0,\n    \"stroke\": 0,\n    \"stroke-dasharray\": 0,\n    \"stroke-dashoffset\": 0,\n    \"stroke-linecap\": 0,\n    \"stroke-linejoin\": 0,\n    \"stroke-miterlimit\": 0,\n    \"stroke-opacity\": 0,\n    \"stroke-width\": 0,\n    \"text-anchor\": 0,\n    \"text-decoration\": 0,\n    \"text-rendering\": 0,\n    \"unicode-bidi\": 0,\n    \"visibility\": 0,\n    \"word-spacing\": 0,\n    \"writing-mode\": 0\n};\n\neve.on(\"snap.util.attr\", function (value) {\n    var att = eve.nt(),\n        attr = {};\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    attr[att] = value;\n    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n            return letter.toUpperCase();\n        }),\n        css = att.replace(/[A-Z]/g, function (letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n    if (cssAttr[has](css)) {\n        this.node.style[style] = value == null ? E : value;\n    } else {\n        $(this.node, attr);\n    }\n});\n(function (proto) {}(Paper.prototype));\n\n// simple ajax\n/*\\\n * Snap.ajax\n [ method ]\n **\n * Simple implementation of Ajax\n **\n - url (string) URL\n - postData (object|string) data for post request\n - callback (function) callback\n - scope (object) #optional scope of callback\n * or\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\\*/\nSnap.ajax = function (url, postData, callback, scope){\n    var req = new XMLHttpRequest,\n        id = ID();\n    if (req) {\n        if (is(postData, \"function\")) {\n            scope = callback;\n            callback = postData;\n            postData = null;\n        } else if (is(postData, \"object\")) {\n            var pd = [];\n            for (var key in postData) if (postData.hasOwnProperty(key)) {\n                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n            }\n            postData = pd.join(\"&\");\n        }\n        req.open((postData ? \"POST\" : \"GET\"), url, true);\n        if (postData) {\n            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        }\n        if (callback) {\n            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n        }\n        req.onreadystatechange = function() {\n            if (req.readyState != 4) return;\n            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n        };\n        if (req.readyState == 4) {\n            return req;\n        }\n        req.send(postData);\n        return req;\n    }\n};\n/*\\\n * Snap.load\n [ method ]\n **\n * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n **\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n\\*/\nSnap.load = function (url, callback, scope) {\n    Snap.ajax(url, function (req) {\n        var f = Snap.parse(req.responseText);\n        scope ? callback.call(scope, f) : callback(f);\n    });\n};\nvar getOffset = function (elem) {\n    var box = elem.getBoundingClientRect(),\n        doc = elem.ownerDocument,\n        body = doc.body,\n        docElem = doc.documentElement,\n        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n    return {\n        y: top,\n        x: left\n    };\n};\n/*\\\n * Snap.getElementByPoint\n [ method ]\n **\n * Returns you topmost element under given point.\n **\n = (object) Snap element object\n - x (number) x coordinate from the top left corner of the window\n - y (number) y coordinate from the top left corner of the window\n > Usage\n | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\\*/\nSnap.getElementByPoint = function (x, y) {\n    var paper = this,\n        svg = paper.canvas,\n        target = glob.doc.elementFromPoint(x, y);\n    if (glob.win.opera && target.tagName == \"svg\") {\n        var so = getOffset(target),\n            sr = target.createSVGRect();\n        sr.x = x - so.x;\n        sr.y = y - so.y;\n        sr.width = sr.height = 1;\n        var hits = target.getIntersectionList(sr, null);\n        if (hits.length) {\n            target = hits[hits.length - 1];\n        }\n    }\n    if (!target) {\n        return null;\n    }\n    return wrap(target);\n};\n/*\\\n * Snap.plugin\n [ method ]\n **\n * Let you write plugins. You pass in a function with five arguments, like this:\n | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n |     Snap.newmethod = function () {};\n |     Element.prototype.newmethod = function () {};\n |     Paper.prototype.newmethod = function () {};\n | });\n * Inside the function you have access to all main objects (and their\n * prototypes). This allow you to extend anything you want.\n **\n - f (function) your plugin body\n\\*/\nSnap.plugin = function (f) {\n    f(Snap, Element, Paper, glob, Fragment);\n};\nglob.win.Snap = Snap;\nreturn Snap;\n}(window || this));\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        Str = String,\n        unit2px = Snap._unit2px,\n        $ = Snap._.$,\n        make = Snap._.make,\n        getSomeDefs = Snap._.getSomeDefs,\n        has = \"hasOwnProperty\",\n        wrap = Snap._.wrap;\n    /*\\\n     * Element.getBBox\n     [ method ]\n     **\n     * Returns the bounding box descriptor for the given element\n     **\n     = (object) bounding box descriptor:\n     o {\n     o     cx: (number) x of the center,\n     o     cy: (number) x of the center,\n     o     h: (number) height,\n     o     height: (number) height,\n     o     path: (string) path command for the box,\n     o     r0: (number) radius of a circle that fully encloses the box,\n     o     r1: (number) radius of the smallest circle that can be enclosed,\n     o     r2: (number) radius of the largest circle that can be enclosed,\n     o     vb: (string) box as a viewbox command,\n     o     w: (number) width,\n     o     width: (number) width,\n     o     x2: (number) x of the right side,\n     o     x: (number) x of the left side,\n     o     y2: (number) y of the bottom edge,\n     o     y: (number) y of the top edge\n     o }\n    \\*/\n    elproto.getBBox = function (isWithoutTransform) {\n        if (!Snap.Matrix || !Snap.path) {\n            return this.node.getBBox();\n        }\n        var el = this,\n            m = new Snap.Matrix;\n        if (el.removed) {\n            return Snap._.box();\n        }\n        while (el.type == \"use\") {\n            if (!isWithoutTransform) {\n                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n            }\n            if (el.original) {\n                el = el.original;\n            } else {\n                var href = el.attr(\"xlink:href\");\n                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n            }\n        }\n        var _ = el._,\n            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n        try {\n            if (isWithoutTransform) {\n                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n                return Snap._.box(_.bboxwt);\n            } else {\n                el.realPath = pathfinder(el);\n                el.matrix = el.transform().localMatrix;\n                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n                return Snap._.box(_.bbox);\n            }\n        } catch (e) {\n            // Firefox doesn’t give you bbox of hidden element\n            return Snap._.box();\n        }\n    };\n    var propString = function () {\n        return this.string;\n    };\n    function extractTransform(el, tstr) {\n        if (tstr == null) {\n            var doReturn = true;\n            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n                tstr = el.node.getAttribute(\"gradientTransform\");\n            } else if (el.type == \"pattern\") {\n                tstr = el.node.getAttribute(\"patternTransform\");\n            } else {\n                tstr = el.node.getAttribute(\"transform\");\n            }\n            if (!tstr) {\n                return new Snap.Matrix;\n            }\n            tstr = Snap._.svgTransform2string(tstr);\n        } else {\n            if (!Snap._.rgTransform.test(tstr)) {\n                tstr = Snap._.svgTransform2string(tstr);\n            } else {\n                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n            }\n            if (is(tstr, \"array\")) {\n                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n            }\n            el._.transform = tstr;\n        }\n        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n        if (doReturn) {\n            return m;\n        } else {\n            el.matrix = m;\n        }\n    }\n    /*\\\n     * Element.transform\n     [ method ]\n     **\n     * Gets or sets transformation of the element\n     **\n     - tstr (string) transform string in Snap or SVG format\n     = (Element) the current element\n     * or\n     = (object) transformation descriptor:\n     o {\n     o     string (string) transform string,\n     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n     o     global (string) global transformation as string,\n     o     local (string) local transformation as string,\n     o     toString (function) returns `string` property\n     o }\n    \\*/\n    elproto.transform = function (tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            var papa = this,\n                global = new Snap.Matrix(this.node.getCTM()),\n                local = extractTransform(this),\n                ms = [local],\n                m = new Snap.Matrix,\n                i,\n                localString = local.toTransformString(),\n                string = Str(local) == Str(this.matrix) ?\n                            Str(_.transform) : localString;\n            while (papa.type != \"svg\" && (papa = papa.parent())) {\n                ms.push(extractTransform(papa));\n            }\n            i = ms.length;\n            while (i--) {\n                m.add(ms[i]);\n            }\n            return {\n                string: string,\n                globalMatrix: global,\n                totalMatrix: m,\n                localMatrix: local,\n                diffMatrix: global.clone().add(local.invert()),\n                global: global.toTransformString(),\n                total: m.toTransformString(),\n                local: localString,\n                toString: propString\n            };\n        }\n        if (tstr instanceof Snap.Matrix) {\n            this.matrix = tstr;\n            this._.transform = tstr.toTransformString();\n        } else {\n            extractTransform(this, tstr);\n        }\n\n        if (this.node) {\n            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n                $(this.node, {gradientTransform: this.matrix});\n            } else if (this.type == \"pattern\") {\n                $(this.node, {patternTransform: this.matrix});\n            } else {\n                $(this.node, {transform: this.matrix});\n            }\n        }\n\n        return this;\n    };\n    /*\\\n     * Element.parent\n     [ method ]\n     **\n     * Returns the element's parent\n     **\n     = (Element) the parent element\n    \\*/\n    elproto.parent = function () {\n        return wrap(this.node.parentNode);\n    };\n    /*\\\n     * Element.append\n     [ method ]\n     **\n     * Appends the given element to current one\n     **\n     - el (Element|Set) element to append\n     = (Element) the parent element\n    \\*/\n    /*\\\n     * Element.add\n     [ method ]\n     **\n     * See @Element.append\n    \\*/\n    elproto.append = elproto.add = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this;\n                el.forEach(function (el) {\n                    it.add(el);\n                });\n                return this;\n            }\n            el = wrap(el);\n            this.node.appendChild(el.node);\n            el.paper = this.paper;\n        }\n        return this;\n    };\n    /*\\\n     * Element.appendTo\n     [ method ]\n     **\n     * Appends the current element to the given one\n     **\n     - el (Element) parent element to append to\n     = (Element) the child element\n    \\*/\n    elproto.appendTo = function (el) {\n        if (el) {\n            el = wrap(el);\n            el.append(this);\n        }\n        return this;\n    };\n    /*\\\n     * Element.prepend\n     [ method ]\n     **\n     * Prepends the given element to the current one\n     **\n     - el (Element) element to prepend\n     = (Element) the parent element\n    \\*/\n    elproto.prepend = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this,\n                    first;\n                el.forEach(function (el) {\n                    if (first) {\n                        first.after(el);\n                    } else {\n                        it.prepend(el);\n                    }\n                    first = el;\n                });\n                return this;\n            }\n            el = wrap(el);\n            var parent = el.parent();\n            this.node.insertBefore(el.node, this.node.firstChild);\n            this.add && this.add();\n            el.paper = this.paper;\n            this.parent() && this.parent().add();\n            parent && parent.add();\n        }\n        return this;\n    };\n    /*\\\n     * Element.prependTo\n     [ method ]\n     **\n     * Prepends the current element to the given one\n     **\n     - el (Element) parent element to prepend to\n     = (Element) the child element\n    \\*/\n    elproto.prependTo = function (el) {\n        el = wrap(el);\n        el.prepend(this);\n        return this;\n    };\n    /*\\\n     * Element.before\n     [ method ]\n     **\n     * Inserts given element before the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.before = function (el) {\n        if (el.type == \"set\") {\n            var it = this;\n            el.forEach(function (el) {\n                var parent = el.parent();\n                it.node.parentNode.insertBefore(el.node, it.node);\n                parent && parent.add();\n            });\n            this.parent().add();\n            return this;\n        }\n        el = wrap(el);\n        var parent = el.parent();\n        this.node.parentNode.insertBefore(el.node, this.node);\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.after\n     [ method ]\n     **\n     * Inserts given element after the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.after = function (el) {\n        el = wrap(el);\n        var parent = el.parent();\n        if (this.node.nextSibling) {\n            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n        } else {\n            this.node.parentNode.appendChild(el.node);\n        }\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertBefore = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertAfter = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the DOM\n     = (Element) the detached element\n    \\*/\n    elproto.remove = function () {\n        var parent = this.parent();\n        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n        delete this.paper;\n        this.removed = true;\n        parent && parent.add();\n        return this;\n    };\n    /*\\\n     * Element.select\n     [ method ]\n     **\n     * Gathers the nested @Element matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Element) result of query selection\n    \\*/\n    elproto.select = function (query) {\n        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n        return wrap(this.node.querySelector(query));\n    };\n    /*\\\n     * Element.selectAll\n     [ method ]\n     **\n     * Gathers nested @Element objects matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Set|array) result of query selection\n    \\*/\n    elproto.selectAll = function (query) {\n        var nodelist = this.node.querySelectorAll(query),\n            set = (Snap.set || Array)();\n        for (var i = 0; i < nodelist.length; i++) {\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    /*\\\n     * Element.asPX\n     [ method ]\n     **\n     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n     **\n     - attr (string) attribute name\n     - value (string) #optional attribute value\n     = (Element) result of query selection\n    \\*/\n    elproto.asPX = function (attr, value) {\n        if (value == null) {\n            value = this.attr(attr);\n        }\n        return +unit2px(this, attr, value);\n    };\n    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n    /*\\\n     * Element.use\n     [ method ]\n     **\n     * Creates a `<use>` element linked to the current element\n     **\n     = (Element) the `<use>` element\n    \\*/\n    elproto.use = function () {\n        var use,\n            id = this.node.id;\n        if (!id) {\n            id = this.id;\n            $(this.node, {\n                id: id\n            });\n        }\n        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n            this.type == \"pattern\") {\n            use = make(this.type, this.node.parentNode);\n        } else {\n            use = make(\"use\", this.node.parentNode);\n        }\n        $(use.node, {\n            \"xlink:href\": \"#\" + id\n        });\n        use.original = this;\n        return use;\n    };\n    function fixids(el) {\n        var els = el.selectAll(\"*\"),\n            it,\n            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n            ids = [],\n            uses = {};\n        function urltest(it, name) {\n            var val = $(it.node, name);\n            val = val && val.match(url);\n            val = val && val[2];\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    var attr = {};\n                    attr[name] = URL(id);\n                    $(it.node, attr);\n                });\n            }\n        }\n        function linktest(it) {\n            var val = $(it.node, \"xlink:href\");\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    it.attr(\"xlink:href\", \"#\" + id);\n                });\n            }\n        }\n        for (var i = 0, ii = els.length; i < ii; i++) {\n            it = els[i];\n            urltest(it, \"fill\");\n            urltest(it, \"stroke\");\n            urltest(it, \"filter\");\n            urltest(it, \"mask\");\n            urltest(it, \"clip-path\");\n            linktest(it);\n            var oldid = $(it.node, \"id\");\n            if (oldid) {\n                $(it.node, {id: it.id});\n                ids.push({\n                    old: oldid,\n                    id: it.id\n                });\n            }\n        }\n        for (i = 0, ii = ids.length; i < ii; i++) {\n            var fs = uses[ids[i].old];\n            if (fs) {\n                for (var j = 0, jj = fs.length; j < jj; j++) {\n                    fs[j](ids[i].id);\n                }\n            }\n        }\n    }\n    /*\\\n     * Element.clone\n     [ method ]\n     **\n     * Creates a clone of the element and inserts it after the element\n     **\n     = (Element) the clone\n    \\*/\n    elproto.clone = function () {\n        var clone = wrap(this.node.cloneNode(true));\n        if ($(clone.node, \"id\")) {\n            $(clone.node, {id: clone.id});\n        }\n        fixids(clone);\n        clone.insertAfter(this);\n        return clone;\n    };\n    /*\\\n     * Element.toDefs\n     [ method ]\n     **\n     * Moves element to the shared `<defs>` area\n     **\n     = (Element) the element\n    \\*/\n    elproto.toDefs = function () {\n        var defs = getSomeDefs(this);\n        defs.appendChild(this.node);\n        return this;\n    };\n    /*\\\n     * Element.toPattern\n     [ method ]\n     **\n     * Creates a `<pattern>` element from the current element\n     **\n     * To create a pattern you have to specify the pattern rect:\n     - x (string|number)\n     - y (string|number)\n     - width (string|number)\n     - height (string|number)\n     = (Element) the `<pattern>` element\n     * You can use pattern later on as an argument for `fill` attribute:\n     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n     |         fill: \"none\",\n     |         stroke: \"#bada55\",\n     |         strokeWidth: 5\n     |     }).pattern(0, 0, 10, 10),\n     |     c = paper.circle(200, 200, 100);\n     | c.attr({\n     |     fill: p\n     | });\n    \\*/\n    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n        var p = make(\"pattern\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        $(p.node, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            id: p.id,\n            viewBox: [x, y, width, height].join(\" \")\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n    /*\\\n     * Element.marker\n     [ method ]\n     **\n     * Creates a `<marker>` element from the current element\n     **\n     * To create a marker you have to specify the bounding rect and reference point:\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - refX (number)\n     - refY (number)\n     = (Element) the `<marker>` element\n     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n    \\*/\n    // TODO add usage for markers\n    elproto.marker = function (x, y, width, height, refX, refY) {\n        var p = make(\"marker\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            refX = x.refX || x.cx;\n            refY = x.refY || x.cy;\n            x = x.x;\n        }\n        $(p.node, {\n            viewBox: [x, y, width, height].join(\" \"),\n            markerWidth: width,\n            markerHeight: height,\n            orient: \"auto\",\n            refX: refX || 0,\n            refY: refY || 0,\n            id: p.id\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    // animation\n    function slice(from, to, f) {\n        return function (arr) {\n            var res = arr.slice(from, to);\n            if (res.length == 1) {\n                res = res[0];\n            }\n            return f ? f(res) : res;\n        };\n    }\n    var Animation = function (attr, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        this.attr = attr;\n        this.dur = ms;\n        easing && (this.easing = easing);\n        callback && (this.callback = callback);\n    };\n    Snap._.Animation = Animation;\n    /*\\\n     * Snap.animation\n     [ method ]\n     **\n     * Creates an animation object\n     **\n     - attr (object) attributes of final destination\n     - duration (number) duration of the animation, in milliseconds\n     - easing (function) #optional one of easing functions of @mina or custom one\n     - callback (function) #optional callback function that fires when animation ends\n     = (object) animation object\n    \\*/\n    Snap.animation = function (attr, ms, easing, callback) {\n        return new Animation(attr, ms, easing, callback);\n    };\n    /*\\\n     * Element.inAnim\n     [ method ]\n     **\n     * Returns a set of animations that may be able to manipulate the current element\n     **\n     = (object) in format:\n     o {\n     o     anim (object) animation object,\n     o     mina (object) @mina object,\n     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n    \\*/\n    elproto.inAnim = function () {\n        var el = this,\n            res = [];\n        for (var id in el.anims) if (el.anims[has](id)) {\n            (function (a) {\n                res.push({\n                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n                    mina: a,\n                    curStatus: a.status(),\n                    status: function (val) {\n                        return a.status(val);\n                    },\n                    stop: function () {\n                        a.stop();\n                    }\n                });\n            }(el.anims[id]));\n        }\n        return res;\n    };\n    /*\\\n     * Snap.animate\n     [ method ]\n     **\n     * Runs generic animation of one number into another with a caring function\n     **\n     - from (number|array) number or array of numbers\n     - to (number|array) number or array of numbers\n     - setter (function) caring function that accepts one number argument\n     - duration (number) duration, in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function to execute when animation ends\n     = (object) animation object in @mina format\n     o {\n     o     id (string) animation id, consider it read-only,\n     o     duration (function) gets or sets the duration of the animation,\n     o     easing (function) easing,\n     o     speed (function) gets or sets the speed of the animation,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n     | var rect = Snap().rect(0, 0, 10, 10);\n     | Snap.animate(0, 10, function (val) {\n     |     rect.attr({\n     |         x: val\n     |     });\n     | }, 1000);\n     | // in given context is equivalent to\n     | rect.animate({x: 10}, 1000);\n    \\*/\n    Snap.animate = function (from, to, setter, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        var now = mina.time(),\n            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n        return anim;\n    };\n    /*\\\n     * Element.stop\n     [ method ]\n     **\n     * Stops all the animations for the current element\n     **\n     = (Element) the current element\n    \\*/\n    elproto.stop = function () {\n        var anims = this.inAnim();\n        for (var i = 0, ii = anims.length; i < ii; i++) {\n            anims[i].stop();\n        }\n        return this;\n    };\n    /*\\\n     * Element.animate\n     [ method ]\n     **\n     * Animates the given attributes of the element\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     = (Element) the current element\n    \\*/\n    elproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n            el = this;\n        for (var key in attrs) if (attrs[has](key)) {\n            if (el.equal) {\n                eq = el.equal(key, Str(attrs[key]));\n                from = eq.from;\n                to = eq.to;\n                f = eq.f;\n            } else {\n                from = +el.attr(key);\n                to = +attrs[key];\n            }\n            var len = is(from, \"array\") ? from.length : 1;\n            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n            fkeys = fkeys.concat(from);\n            tkeys = tkeys.concat(to);\n        }\n        var now = mina.time(),\n            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n                var attr = {};\n                for (var key in keys) if (keys[has](key)) {\n                    attr[key] = keys[key](val);\n                }\n                el.attr(attr);\n            }, easing);\n        el.anims[anim.id] = anim;\n        anim._attrs = attrs;\n        anim._callback = callback;\n        eve(\"snap.animcreated.\" + el.id, anim);\n        eve.once(\"mina.finish.\" + anim.id, function () {\n            delete el.anims[anim.id];\n            callback && callback.call(el);\n        });\n        eve.once(\"mina.stop.\" + anim.id, function () {\n            delete el.anims[anim.id];\n        });\n        return el;\n    };\n    var eldata = {};\n    /*\\\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value associated with given key. (Don’t confuse\n     * with `data-` attributes)\n     *\n     * See also @Element.removeData\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n    \\*/\n    elproto.data = function (key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0){\n            eve(\"snap.data.get.\" + this.id, this, data, null);\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (Snap.is(key, \"object\")) {\n                for (var i in key) if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"snap.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*\\\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     - key (string) #optional key\n     = (object) @Element\n    \\*/\n    elproto.removeData = function (key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*\\\n     * Element.outerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n     *\n     * See also @Element.innerSVG\n     = (string) SVG code for the element\n    \\*/\n    /*\\\n     * Element.toString\n     [ method ]\n     **\n     * See @Element.outerSVG\n    \\*/\n    elproto.outerSVG = elproto.toString = toString(1);\n    /*\\\n     * Element.innerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n     = (string) SVG code for the element\n    \\*/\n    elproto.innerSVG = toString();\n    function toString(type) {\n        return function () {\n            var res = type ? \"<\" + this.type : \"\",\n                attr = this.node.attributes,\n                chld = this.node.childNodes;\n            if (type) {\n                for (var i = 0, ii = attr.length; i < ii; i++) {\n                    res += \" \" + attr[i].name + '=\"' +\n                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n                }\n            }\n            if (chld.length) {\n                type && (res += \">\");\n                for (i = 0, ii = chld.length; i < ii; i++) {\n                    if (chld[i].nodeType == 3) {\n                        res += chld[i].nodeValue;\n                    } else if (chld[i].nodeType == 1) {\n                        res += wrap(chld[i]).toString();\n                    }\n                }\n                type && (res += \"</\" + this.type + \">\");\n            } else {\n                type && (res += \"/>\");\n            }\n            return res;\n        };\n    }\n    elproto.toDataURL = function () {\n        if (window && window.btoa) {\n            var bb = this.getBBox(),\n                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n                x: +bb.x.toFixed(3),\n                y: +bb.y.toFixed(3),\n                width: +bb.width.toFixed(3),\n                height: +bb.height.toFixed(3),\n                contents: this.outerSVG()\n            });\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        }\n    };\n    /*\\\n     * Fragment.select\n     [ method ]\n     **\n     * See @Element.select\n    \\*/\n    Fragment.prototype.select = elproto.select;\n    /*\\\n     * Fragment.selectAll\n     [ method ]\n     **\n     * See @Element.selectAll\n    \\*/\n    Fragment.prototype.selectAll = elproto.selectAll;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var objectToString = Object.prototype.toString,\n        Str = String,\n        math = Math,\n        E = \"\";\n    function Matrix(a, b, c, d, e, f) {\n        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n            return;\n        }\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function (matrixproto) {\n        /*\\\n         * Matrix.add\n         [ method ]\n         **\n         * Adds the given matrix to existing one\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/\n        matrixproto.add = function (a, b, c, d, e, f) {\n            var out = [[], [], []],\n                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                x, y, z, res;\n\n            if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n            }\n\n            for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                    res = 0;\n                    for (z = 0; z < 3; z++) {\n                        res += m[x][z] * matrix[z][y];\n                    }\n                    out[x][y] = res;\n                }\n            }\n            this.a = out[0][0];\n            this.b = out[1][0];\n            this.c = out[0][1];\n            this.d = out[1][1];\n            this.e = out[0][2];\n            this.f = out[1][2];\n            return this;\n        };\n        /*\\\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns an inverted version of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.invert = function () {\n            var me = this,\n                x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*\\\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns a copy of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.clone = function () {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*\\\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         - x (number) horizontal offset distance\n         - y (number) vertical offset distance\n        \\*/\n        matrixproto.translate = function (x, y) {\n            return this.add(1, 0, 0, 1, x, y);\n        };\n        /*\\\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         - x (number) amount to be scaled, with `1` resulting in no change\n         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n         - cx (number) #optional horizontal origin point from which to scale\n         - cy (number) #optional vertical origin point from which to scale\n         * Default cx, cy is the middle point of the element.\n        \\*/\n        matrixproto.scale = function (x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n            this.add(x, 0, 0, y, 0, 0);\n            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n            return this;\n        };\n        /*\\\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         - a (number) angle of rotation, in degrees\n         - x (number) horizontal origin point from which to rotate\n         - y (number) vertical origin point from which to rotate\n        \\*/\n        matrixproto.rotate = function (a, x, y) {\n            a = Snap.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math.cos(a).toFixed(9),\n                sin = +math.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            return this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*\\\n         * Matrix.x\n         [ method ]\n         **\n         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         - x (number)\n         - y (number)\n         = (number) x\n        \\*/\n        matrixproto.x = function (x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*\\\n         * Matrix.y\n         [ method ]\n         **\n         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         - x (number)\n         - y (number)\n         = (number) y\n        \\*/\n        matrixproto.y = function (x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function (i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function () {\n            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n        };\n        matrixproto.offset = function () {\n            return [this.e.toFixed(4), this.f.toFixed(4)];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*\\\n         * Matrix.determinant\n         [ method ]\n         **\n         * Finds determinant of the given matrix.\n         = (number) determinant\n        \\*/\n        matrixproto.determinant = function () {\n            return this.a * this.d - this.b * this.c;\n        };\n        /*\\\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n        \\*/\n        matrixproto.split = function () {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n\n            // scale and shear\n            var row = [[this.a, this.c], [this.b, this.d]];\n            out.scalex = math.sqrt(norm(row[0]));\n            normalize(row[0]);\n\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n            out.scaley = math.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n\n            if (this.determinant() < 0) {\n                out.scalex = -out.scalex;\n            }\n\n            // rotation\n            var sin = -row[0][1],\n                cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = Snap.deg(math.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = Snap.deg(math.asin(sin));\n            }\n\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*\\\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Returns transform string that represents given matrix\n         = (string) transform string\n        \\*/\n        matrixproto.toTransformString = function (shorter) {\n            var s = shorter || this.split();\n            if (!+s.shear.toFixed(9)) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +\n                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n            } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n            }\n        };\n    })(Matrix.prototype);\n    /*\\\n     * Snap.Matrix\n     [ method ]\n     **\n     * Matrix constructor, extend on your own risk.\n     * To create matrices use @Snap.matrix.\n    \\*/\n    Snap.Matrix = Matrix;\n    /*\\\n     * Snap.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns a matrix based on the given parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     * or\n     - svgMatrix (SVGMatrix)\n     = (object) @Matrix\n    \\*/\n    Snap.matrix = function (a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var has = \"hasOwnProperty\",\n        make = Snap._.make,\n        wrap = Snap._.wrap,\n        is = Snap.is,\n        getSomeDefs = Snap._.getSomeDefs,\n        reURLValue = /^url\\(#?([^)]+)\\)$/,\n        $ = Snap._.$,\n        URL = Snap.url,\n        Str = String,\n        separator = Snap._.separator,\n        E = \"\";\n    // Attributes event handlers\n    eve.on(\"snap.util.attr.mask\", function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value.type == \"mask\") {\n                var mask = value;\n            } else {\n                mask = make(\"mask\", getSomeDefs(this));\n                mask.node.appendChild(value.node);\n            }\n            !mask.node.id && $(mask.node, {\n                id: mask.id\n            });\n            $(this.node, {\n                mask: URL(mask.id)\n            });\n        }\n    });\n    (function (clipIt) {\n        eve.on(\"snap.util.attr.clip\", clipIt);\n        eve.on(\"snap.util.attr.clip-path\", clipIt);\n        eve.on(\"snap.util.attr.clipPath\", clipIt);\n    }(function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value.type == \"clipPath\") {\n                var clip = value;\n            } else {\n                clip = make(\"clipPath\", getSomeDefs(this));\n                clip.node.appendChild(value.node);\n                !clip.node.id && $(clip.node, {\n                    id: clip.id\n                });\n            }\n            $(this.node, {\n                \"clip-path\": URL(clip.node.id || clip.id)\n            });\n        }\n    }));\n    function fillStroke(name) {\n        return function (value) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n                (value.node.firstChild.tagName == \"radialGradient\" ||\n                value.node.firstChild.tagName == \"linearGradient\" ||\n                value.node.firstChild.tagName == \"pattern\")) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value instanceof Element) {\n                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n                   || value.type == \"pattern\") {\n                    if (!value.node.id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    var fill = URL(value.node.id);\n                } else {\n                    fill = value.attr(name);\n                }\n            } else {\n                fill = Snap.color(value);\n                if (fill.error) {\n                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n                    if (grad) {\n                        if (!grad.node.id) {\n                            $(grad.node, {\n                                id: grad.id\n                            });\n                        }\n                        fill = URL(grad.node.id);\n                    } else {\n                        fill = value;\n                    }\n                } else {\n                    fill = Str(fill);\n                }\n            }\n            var attrs = {};\n            attrs[name] = fill;\n            $(this.node, attrs);\n            this.node.style[name] = E;\n        };\n    }\n    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n        string = Str(string);\n        var tokens = string.match(gradrg);\n        if (!tokens) {\n            return null;\n        }\n        var type = tokens[1],\n            params = tokens[2],\n            stops = tokens[3];\n        params = params.split(/\\s*,\\s*/).map(function (el) {\n            return +el == el ? +el : el;\n        });\n        if (params.length == 1 && params[0] == 0) {\n            params = [];\n        }\n        stops = stops.split(\"-\");\n        stops = stops.map(function (el) {\n            el = el.split(\":\");\n            var out = {\n                color: el[0]\n            };\n            if (el[1]) {\n                out.offset = parseFloat(el[1]);\n            }\n            return out;\n        });\n        return {\n            type: type,\n            params: params,\n            stops: stops\n        };\n    });\n\n    eve.on(\"snap.util.attr.d\", function (value) {\n        eve.stop();\n        if (is(value, \"array\") && is(value[0], \"array\")) {\n            value = Snap.path.toString.call(value);\n        }\n        value = Str(value);\n        if (value.match(/[ruo]/i)) {\n            value = Snap.path.toAbsolute(value);\n        }\n        $(this.node, {d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.#text\", function (value) {\n        eve.stop();\n        value = Str(value);\n        var txt = glob.doc.createTextNode(value);\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n        this.node.appendChild(txt);\n    })(-1);\n    eve.on(\"snap.util.attr.path\", function (value) {\n        eve.stop();\n        this.attr({d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.class\", function (value) {\n        eve.stop();\n        this.node.className.baseVal = value;\n    })(-1);\n    eve.on(\"snap.util.attr.viewBox\", function (value) {\n        var vb;\n        if (is(value, \"object\") && \"x\" in value) {\n            vb = [value.x, value.y, value.width, value.height].join(\" \");\n        } else if (is(value, \"array\")) {\n            vb = value.join(\" \");\n        } else {\n            vb = value;\n        }\n        $(this.node, {\n            viewBox: vb\n        });\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.transform\", function (value) {\n        this.transform(value);\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.r\", function (value) {\n        if (this.type == \"rect\") {\n            eve.stop();\n            $(this.node, {\n                rx: value,\n                ry: value\n            });\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.textpath\", function (value) {\n        eve.stop();\n        if (this.type == \"text\") {\n            var id, tp, node;\n            if (!value && this.textPath) {\n                tp = this.textPath;\n                while (tp.node.firstChild) {\n                    this.node.appendChild(tp.node.firstChild);\n                }\n                tp.remove();\n                delete this.textPath;\n                return;\n            }\n            if (is(value, \"string\")) {\n                var defs = getSomeDefs(this),\n                    path = wrap(defs.parentNode).path(value);\n                defs.appendChild(path.node);\n                id = path.id;\n                path.attr({id: id});\n            } else {\n                value = wrap(value);\n                if (value instanceof Element) {\n                    id = value.attr(\"id\");\n                    if (!id) {\n                        id = value.id;\n                        value.attr({id: id});\n                    }\n                }\n            }\n            if (id) {\n                tp = this.textPath;\n                node = this.node;\n                if (tp) {\n                    tp.attr({\"xlink:href\": \"#\" + id});\n                } else {\n                    tp = $(\"textPath\", {\n                        \"xlink:href\": \"#\" + id\n                    });\n                    while (node.firstChild) {\n                        tp.appendChild(node.firstChild);\n                    }\n                    node.appendChild(tp);\n                    this.textPath = wrap(tp);\n                }\n            }\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.text\", function (value) {\n        if (this.type == \"text\") {\n            var i = 0,\n                node = this.node,\n                tuner = function (chunk) {\n                    var out = $(\"tspan\");\n                    if (is(chunk, \"array\")) {\n                        for (var i = 0; i < chunk.length; i++) {\n                            out.appendChild(tuner(chunk[i]));\n                        }\n                    } else {\n                        out.appendChild(glob.doc.createTextNode(chunk));\n                    }\n                    out.normalize && out.normalize();\n                    return out;\n                };\n            while (node.firstChild) {\n                node.removeChild(node.firstChild);\n            }\n            var tuned = tuner(value);\n            while (tuned.firstChild) {\n                node.appendChild(tuned.firstChild);\n            }\n        }\n        eve.stop();\n    })(-1);\n    function setFontSize(value) {\n        eve.stop();\n        if (value == +value) {\n            value += \"px\";\n        }\n        this.node.style.fontSize = value;\n    }\n    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\n\n    eve.on(\"snap.util.getattr.transform\", function () {\n        eve.stop();\n        return this.transform();\n    })(-1);\n    eve.on(\"snap.util.getattr.textpath\", function () {\n        eve.stop();\n        return this.textPath;\n    })(-1);\n    // Markers\n    (function () {\n        function getter(end) {\n            return function () {\n                eve.stop();\n                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n                if (style == \"none\") {\n                    return style;\n                } else {\n                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n                }\n            };\n        }\n        function setter(end) {\n            return function (value) {\n                eve.stop();\n                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n                if (value == \"\" || !value) {\n                    this.node.style[name] = \"none\";\n                    return;\n                }\n                if (value.type == \"marker\") {\n                    var id = value.node.id;\n                    if (!id) {\n                        $(value.node, {id: value.id});\n                    }\n                    this.node.style[name] = URL(id);\n                    return;\n                }\n            };\n        }\n        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n    }());\n    eve.on(\"snap.util.getattr.r\", function () {\n        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n            eve.stop();\n            return $(this.node, \"rx\");\n        }\n    })(-1);\n    function textExtract(node) {\n        var out = [];\n        var children = node.childNodes;\n        for (var i = 0, ii = children.length; i < ii; i++) {\n            var chi = children[i];\n            if (chi.nodeType == 3) {\n                out.push(chi.nodeValue);\n            }\n            if (chi.tagName == \"tspan\") {\n                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n                    out.push(chi.firstChild.nodeValue);\n                } else {\n                    out.push(textExtract(chi));\n                }\n            }\n        }\n        return out;\n    }\n    eve.on(\"snap.util.getattr.text\", function () {\n        if (this.type == \"text\" || this.type == \"tspan\") {\n            eve.stop();\n            var out = textExtract(this.node);\n            return out.length == 1 ? out[0] : out;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.#text\", function () {\n        return this.node.textContent;\n    })(-1);\n    eve.on(\"snap.util.getattr.viewBox\", function () {\n        eve.stop();\n        var vb = $(this.node, \"viewBox\");\n        if (vb) {\n            vb = vb.split(separator);\n            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.points\", function () {\n        var p = $(this.node, \"points\");\n        eve.stop();\n        if (p) {\n            return p.split(separator);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.path\", function () {\n        var p = $(this.node, \"d\");\n        eve.stop();\n        return p;\n    })(-1);\n    eve.on(\"snap.util.getattr.class\", function () {\n        return this.node.className.baseVal;\n    })(-1);\n    function getFontSize() {\n        eve.stop();\n        return this.node.style.fontSize;\n    }\n    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var rgNotSpace = /\\S+/g,\n        rgBadSpace = /[\\t\\r\\n\\f]/g,\n        rgTrim = /(^\\s+|\\s+$)/g,\n        Str = String,\n        elproto = Element.prototype;\n    /*\\\n     * Element.addClass\n     [ method ]\n     **\n     * Adds given class name or list of class names to the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.addClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n\n        if (classes.length) {\n            j = 0;\n            while ((clazz = classes[j++])) {\n                pos = curClasses.indexOf(clazz);\n                if (!~pos) {\n                    curClasses.push(clazz);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.removeClass\n     [ method ]\n     **\n     * Removes given class name or list of class names from the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.removeClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        if (curClasses.length) {\n            j = 0;\n            while ((clazz = classes[j++])) {\n                pos = curClasses.indexOf(clazz);\n                if (~pos) {\n                    curClasses.splice(pos, 1);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.hasClass\n     [ method ]\n     **\n     * Checks if the element has a given class name in the list of class names applied to it.\n     - value (string) class name\n     **\n     = (boolean) `true` if the element has given class\n    \\*/\n    elproto.hasClass = function (value) {\n        var elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [];\n        return !!~curClasses.indexOf(value);\n    };\n    /*\\\n     * Element.toggleClass\n     [ method ]\n     **\n     * Add or remove one or more classes from the element, depending on either\n     * the class’s presence or the value of the `flag` argument.\n     - value (string) class name or space separated list of class names\n     - flag (boolean) value to determine whether the class should be added or removed\n     **\n     = (Element) original element.\n    \\*/\n    elproto.toggleClass = function (value, flag) {\n        if (flag != null) {\n            if (flag) {\n                return this.addClass(value);\n            } else {\n                return this.removeClass(value);\n            }\n        }\n        var classes = (value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        j = 0;\n        while ((clazz = classes[j++])) {\n            pos = curClasses.indexOf(clazz);\n            if (~pos) {\n                curClasses.splice(pos, 1);\n            } else {\n                curClasses.push(clazz);\n            }\n        }\n\n        finalValue = curClasses.join(\" \");\n        if (className != finalValue) {\n            elem.className.baseVal = finalValue;\n        }\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var operators = {\n            \"+\": function (x, y) {\n                    return x + y;\n                },\n            \"-\": function (x, y) {\n                    return x - y;\n                },\n            \"/\": function (x, y) {\n                    return x / y;\n                },\n            \"*\": function (x, y) {\n                    return x * y;\n                }\n        },\n        Str = String,\n        reUnit = /[a-z]+$/i,\n        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    eve.on(\"snap.util.attr\", function (val) {\n        var plus = Str(val).match(reAddon);\n        if (plus) {\n            var evnt = eve.nt(),\n                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n                a = this.attr(name),\n                atr = {};\n            eve.stop();\n            var unit = plus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[plus[1]];\n            if (aUnit && aUnit == unit) {\n                val = op(parseFloat(a), +plus[2]);\n            } else {\n                a = this.asPX(name);\n                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n            }\n            if (isNaN(a) || isNaN(val)) {\n                return;\n            }\n            atr[name] = val;\n            this.attr(atr);\n        }\n    })(-10);\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this,\n            bplus = Str(b).match(reAddon);\n        if (bplus) {\n            eve.stop();\n            var unit = bplus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[bplus[1]];\n            if (aUnit && aUnit == unit) {\n                return {\n                    from: parseFloat(a),\n                    to: op(parseFloat(a), +bplus[2]),\n                    f: getUnit(aUnit)\n                };\n            } else {\n                a = this.asPX(name);\n                return {\n                    from: a,\n                    to: op(a, this.asPX(name, bplus[2] + unit)),\n                    f: getNumber\n                };\n            }\n        }\n    })(-10);\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var proto = Paper.prototype,\n        is = Snap.is;\n    /*\\\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - rx (number) #optional horizontal radius for rounded corners, default is 0\n     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n     = (object) the `rect` element\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n    \\*/\n    proto.rect = function (x, y, w, h, rx, ry) {\n        var attr;\n        if (ry == null) {\n            ry = rx;\n        }\n        if (is(x, \"object\") && x == \"[object Object]\") {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n            if (rx != null) {\n                attr.rx = rx;\n                attr.ry = ry;\n            }\n        }\n        return this.el(\"rect\", attr);\n    };\n    /*\\\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) the `circle` element\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n    \\*/\n    proto.circle = function (cx, cy, r) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                r: r\n            };\n        }\n        return this.el(\"circle\", attr);\n    };\n\n    var preload = (function () {\n        function onerror() {\n            this.parentNode.removeChild(this);\n        }\n        return function (src, f) {\n            var img = glob.doc.createElement(\"img\"),\n                body = glob.doc.body;\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n            img.onload = function () {\n                f.call(img);\n                img.onload = img.onerror = null;\n                body.removeChild(img);\n            };\n            img.onerror = onerror;\n            body.appendChild(img);\n            img.src = src;\n        };\n    }());\n\n    /*\\\n     * Paper.image\n     [ method ]\n     **\n     * Places an image on the surface\n     **\n     - src (string) URI of the source image\n     - x (number) x offset position\n     - y (number) y offset position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) the `image` element\n     * or\n     = (object) Snap element object with type `image`\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n    \\*/\n    proto.image = function (src, x, y, width, height) {\n        var el = this.el(\"image\");\n        if (is(src, \"object\") && \"src\" in src) {\n            el.attr(src);\n        } else if (src != null) {\n            var set = {\n                \"xlink:href\": src,\n                preserveAspectRatio: \"none\"\n            };\n            if (x != null && y != null) {\n                set.x = x;\n                set.y = y;\n            }\n            if (width != null && height != null) {\n                set.width = width;\n                set.height = height;\n            } else {\n                preload(src, function () {\n                    Snap._.$(el.node, {\n                        width: this.offsetWidth,\n                        height: this.offsetHeight\n                    });\n                });\n            }\n            Snap._.$(el.node, set);\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) the `ellipse` element\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n    \\*/\n    proto.ellipse = function (cx, cy, rx, ry) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr ={\n                cx: cx,\n                cy: cy,\n                rx: rx,\n                ry: ry\n            };\n        }\n        return this.el(\"ellipse\", attr);\n    };\n    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n    /*\\\n     * Paper.path\n     [ method ]\n     **\n     * Creates a `<path>` element using the given string as the path's definition\n     - pathString (string) #optional path string in SVG format\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n     | \"M10,20L30,40\"\n     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n    \\*/\n    proto.path = function (d) {\n        var attr;\n        if (is(d, \"object\") && !is(d, \"array\")) {\n            attr = d;\n        } else if (d) {\n            attr = {d: d};\n        }\n        return this.el(\"path\", attr);\n    };\n    /*\\\n     * Paper.g\n     [ method ]\n     **\n     * Creates a group element\n     **\n     - varargs (…) #optional elements to nest within the group\n     = (object) the `g` element\n     **\n     > Usage\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g(c2, c1); // note that the order of elements is different\n     * or\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g();\n     | g.add(c2, c1);\n    \\*/\n    /*\\\n     * Paper.group\n     [ method ]\n     **\n     * See @Paper.g\n    \\*/\n    proto.group = proto.g = function (first) {\n        var attr,\n            el = this.el(\"g\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.svg\n     [ method ]\n     **\n     * Creates a nested SVG element.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `svg` element\n     **\n    \\*/\n    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n        var attrs = {};\n        if (is(x, \"object\") && y == null) {\n            attrs = x;\n        } else {\n            if (x != null) {\n                attrs.x = x;\n            }\n            if (y != null) {\n                attrs.y = y;\n            }\n            if (width != null) {\n                attrs.width = width;\n            }\n            if (height != null) {\n                attrs.height = height;\n            }\n            if (vbx != null && vby != null && vbw != null && vbh != null) {\n                attrs.viewBox = [vbx, vby, vbw, vbh];\n            }\n        }\n        return this.el(\"svg\", attrs);\n    };\n    /*\\\n     * Paper.mask\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a mask.\n     **\n     = (object) the `mask` element\n     **\n    \\*/\n    proto.mask = function (first) {\n        var attr,\n            el = this.el(\"mask\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ptrn\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a pattern.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `pattern` element\n     **\n    \\*/\n    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n        if (is(x, \"object\")) {\n            var attr = x;\n        } else {\n            attr = {patternUnits: \"userSpaceOnUse\"};\n            if (x) {\n                attr.x = x;\n            }\n            if (y) {\n                attr.y = y;\n            }\n            if (width != null) {\n                attr.width = width;\n            }\n            if (height != null) {\n                attr.height = height;\n            }\n            if (vx != null && vy != null && vw != null && vh != null) {\n                attr.viewBox = [vx, vy, vw, vh];\n            } else {\n                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n            }\n        }\n        return this.el(\"pattern\", attr);\n    };\n    /*\\\n     * Paper.use\n     [ method ]\n     **\n     * Creates a <use> element.\n     - id (string) @optional id of element to link\n     * or\n     - id (Element) @optional element to link\n     **\n     = (object) the `use` element\n     **\n    \\*/\n    proto.use = function (id) {\n        if (id != null) {\n            if (id instanceof Element) {\n                if (!id.attr(\"id\")) {\n                    id.attr({id: Snap._.id(id)});\n                }\n                id = id.attr(\"id\");\n            }\n            if (String(id).charAt() == \"#\") {\n                id = id.substring(1);\n            }\n            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n        } else {\n            return Element.prototype.use.call(this);\n        }\n    };\n    /*\\\n     * Paper.symbol\n     [ method ]\n     **\n     * Creates a <symbol> element.\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     = (object) the `symbol` element\n     **\n    \\*/\n    proto.symbol = function (vx, vy, vw, vh) {\n        var attr = {};\n        if (vx != null && vy != null && vw != null && vh != null) {\n            attr.viewBox = [vx, vy, vw, vh];\n        }\n\n        return this.el(\"symbol\", attr);\n    };\n    /*\\\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n     = (object) the `text` element\n     **\n     > Usage\n     | var t1 = paper.text(50, 50, \"Snap\");\n     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n     | // Text path usage\n     | t1.attr({textpath: \"M10,10L100,100\"});\n     | // or\n     | var pth = paper.path(\"M10,10L100,100\");\n     | t1.attr({textpath: pth});\n    \\*/\n    proto.text = function (x, y, text) {\n        var attr = {};\n        if (is(x, \"object\")) {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                text: text || \"\"\n            };\n        }\n        return this.el(\"text\", attr);\n    };\n    /*\\\n     * Paper.line\n     [ method ]\n     **\n     * Draws a line\n     **\n     - x1 (number) x coordinate position of the start\n     - y1 (number) y coordinate position of the start\n     - x2 (number) x coordinate position of the end\n     - y2 (number) y coordinate position of the end\n     = (object) the `line` element\n     **\n     > Usage\n     | var t1 = paper.line(50, 50, 100, 100);\n    \\*/\n    proto.line = function (x1, y1, x2, y2) {\n        var attr = {};\n        if (is(x1, \"object\")) {\n            attr = x1;\n        } else if (x1 != null) {\n            attr = {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        }\n        return this.el(\"line\", attr);\n    };\n    /*\\\n     * Paper.polyline\n     [ method ]\n     **\n     * Draws a polyline\n     **\n     - points (array) array of points\n     * or\n     - varargs (…) points\n     = (object) the `polyline` element\n     **\n     > Usage\n     | var p1 = paper.polyline([10, 10, 100, 100]);\n     | var p2 = paper.polyline(10, 10, 100, 100);\n    \\*/\n    proto.polyline = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polyline\", attr);\n    };\n    /*\\\n     * Paper.polygon\n     [ method ]\n     **\n     * Draws a polygon. See @Paper.polyline\n    \\*/\n    proto.polygon = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polygon\", attr);\n    };\n    // gradients\n    (function () {\n        var $ = Snap._.$;\n        // gradients' helpers\n        function Gstops() {\n            return this.selectAll(\"stop\");\n        }\n        function GaddStop(color, offset) {\n            var stop = $(\"stop\"),\n                attr = {\n                    offset: +offset + \"%\"\n                };\n            color = Snap.color(color);\n            attr[\"stop-color\"] = color.hex;\n            if (color.opacity < 1) {\n                attr[\"stop-opacity\"] = color.opacity;\n            }\n            $(stop, attr);\n            this.node.appendChild(stop);\n            return this;\n        }\n        function GgetBBox() {\n            if (this.type == \"linearGradient\") {\n                var x1 = $(this.node, \"x1\") || 0,\n                    x2 = $(this.node, \"x2\") || 1,\n                    y1 = $(this.node, \"y1\") || 0,\n                    y2 = $(this.node, \"y2\") || 0;\n                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n            } else {\n                var cx = this.node.cx || .5,\n                    cy = this.node.cy || .5,\n                    r = this.node.r || 0;\n                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n            }\n        }\n        function gradient(defs, str) {\n            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n                el;\n            if (!grad) {\n                return null;\n            }\n            grad.params.unshift(defs);\n            if (grad.type.toLowerCase() == \"l\") {\n                el = gradientLinear.apply(0, grad.params);\n            } else {\n                el = gradientRadial.apply(0, grad.params);\n            }\n            if (grad.type != grad.type.toLowerCase()) {\n                $(el.node, {\n                    gradientUnits: \"userSpaceOnUse\"\n                });\n            }\n            var stops = grad.stops,\n                len = stops.length,\n                start = 0,\n                j = 0;\n            function seed(i, end) {\n                var step = (end - start) / (i - j);\n                for (var k = j; k < i; k++) {\n                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n                }\n                j = i;\n                start = end;\n            }\n            len--;\n            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n                seed(i, stops[i].offset);\n            }\n            stops[len].offset = stops[len].offset || 100;\n            seed(len, stops[len].offset);\n            for (i = 0; i <= len; i++) {\n                var stop = stops[i];\n                el.addStop(stop.color, stop.offset);\n            }\n            return el;\n        }\n        function gradientLinear(defs, x1, y1, x2, y2) {\n            var el = Snap._.make(\"linearGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (x1 != null) {\n                $(el.node, {\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2\n                });\n            }\n            return el;\n        }\n        function gradientRadial(defs, cx, cy, r, fx, fy) {\n            var el = Snap._.make(\"radialGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (cx != null) {\n                $(el.node, {\n                    cx: cx,\n                    cy: cy,\n                    r: r\n                });\n            }\n            if (fx != null && fy != null) {\n                $(el.node, {\n                    fx: fx,\n                    fy: fy\n                });\n            }\n            return el;\n        }\n        /*\\\n         * Paper.gradient\n         [ method ]\n         **\n         * Creates a gradient element\n         **\n         - gradient (string) gradient descriptor\n         > Gradient Descriptor\n         * The gradient descriptor is an expression formatted as\n         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n         * either linear or radial.  The uppercase `L` or `R` letters\n         * indicate absolute coordinates offset from the SVG surface.\n         * Lowercase `l` or `r` letters indicate coordinates\n         * calculated relative to the element to which the gradient is\n         * applied.  Coordinates specify a linear gradient vector as\n         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n         * `r` and optional `fx`, `fy` specifying a focal point away\n         * from the center of the circle. Specify `<colors>` as a list\n         * of dash-separated CSS color values.  Each color may be\n         * followed by a custom offset value, separated with a colon\n         * character.\n         > Examples\n         * Linear gradient, relative from top-left corner to bottom-right\n         * corner, from black through red to white:\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n         * through red at 25% to white:\n         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n         * Radial gradient, relative from the center of the element with radius\n         * half the width, from black to white:\n         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n         * To apply the gradient:\n         | paper.circle(50, 50, 40).attr({\n         |     fill: g\n         | });\n         = (object) the `gradient` element\n        \\*/\n        proto.gradient = function (str) {\n            return gradient(this.defs, str);\n        };\n        proto.gradientLinear = function (x1, y1, x2, y2) {\n            return gradientLinear(this.defs, x1, y1, x2, y2);\n        };\n        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n        };\n        /*\\\n         * Paper.toString\n         [ method ]\n         **\n         * Returns SVG code for the @Paper\n         = (string) SVG code for the @Paper\n        \\*/\n        proto.toString = function () {\n            var doc = this.node.ownerDocument,\n                f = doc.createDocumentFragment(),\n                d = doc.createElement(\"div\"),\n                svg = this.node.cloneNode(true),\n                res;\n            f.appendChild(d);\n            d.appendChild(svg);\n            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n            res = d.innerHTML;\n            f.removeChild(f.firstChild);\n            return res;\n        };\n        /*\\\n         * Paper.toDataURL\n         [ method ]\n         **\n         * Returns SVG code for the @Paper as Data URI string.\n         = (string) Data URI string\n        \\*/\n        proto.toDataURL = function () {\n            if (window && window.btoa) {\n                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n            }\n        };\n        /*\\\n         * Paper.clear\n         [ method ]\n         **\n         * Removes all child nodes of the paper, except <defs>.\n        \\*/\n        proto.clear = function () {\n            var node = this.node.firstChild,\n                next;\n            while (node) {\n                next = node.nextSibling;\n                if (node.tagName != \"defs\") {\n                    node.parentNode.removeChild(node);\n                } else {\n                    proto.clear.call({node: node});\n                }\n                node = next;\n            }\n        };\n    }());\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        clone = Snap._.clone,\n        has = \"hasOwnProperty\",\n        p2s = /,?([a-z]),?/gi,\n        toFloat = parseFloat,\n        math = Math,\n        PI = math.PI,\n        mmin = math.min,\n        mmax = math.max,\n        pow = math.pow,\n        abs = math.abs;\n    function paths(ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }\n    function box(x, y, width, height) {\n        if (x == null) {\n            x = y = width = height = 0;\n        }\n        if (y == null) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            w: width,\n            height: height,\n            h: height,\n            x2: x + width,\n            y2: y + height,\n            cx: x + width / 2,\n            cy: y + height / 2,\n            r1: math.min(width, height) / 2,\n            r2: math.max(width, height) / 2,\n            r0: math.sqrt(width * width + height * height) / 2,\n            path: rectPath(x, y, width, height),\n            vb: [x, y, width, height].join(\" \")\n        };\n    }\n    function toString() {\n        return this.join(\",\").replace(p2s, \"$1\");\n    }\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n        if (length == null) {\n            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n        } else {\n            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n        }\n    }\n    function getLengthFactory(istotal, subpath) {\n        function O(val) {\n            return +(+val).toFixed(3);\n        }\n        return Snap._.cacher(function (path, length, onlystart) {\n            if (path instanceof Element) {\n                path = path.attr(\"d\");\n            }\n            path = path2curve(path);\n            var x, y, p, l, sp = \"\", subpaths = {}, point,\n                len = 0;\n            for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = +p[1];\n                    y = +p[2];\n                } else {\n                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    if (len + l > length) {\n                        if (subpath && !subpaths.start) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            sp += [\n                                \"C\" + O(point.start.x),\n                                O(point.start.y),\n                                O(point.m.x),\n                                O(point.m.y),\n                                O(point.x),\n                                O(point.y)\n                            ];\n                            if (onlystart) {return sp;}\n                            subpaths.start = sp;\n                            sp = [\n                                \"M\" + O(point.x),\n                                O(point.y) + \"C\" + O(point.n.x),\n                                O(point.n.y),\n                                O(point.end.x),\n                                O(point.end.y),\n                                O(p[5]),\n                                O(p[6])\n                            ].join();\n                            len += l;\n                            x = +p[5];\n                            y = +p[6];\n                            continue;\n                        }\n                        if (!istotal && !subpath) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            return point;\n                        }\n                    }\n                    len += l;\n                    x = +p[5];\n                    y = +p[6];\n                }\n                sp += p.shift() + p;\n            }\n            subpaths.end = sp;\n            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n            return point;\n        }, null, Snap._.clone);\n    }\n    var getTotalLength = getLengthFactory(1),\n        getPointAtLength = getLengthFactory(),\n        getSubpathsAtLength = getLengthFactory(0, 1);\n    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t,\n            t13 = pow(t1, 3),\n            t12 = pow(t1, 2),\n            t2 = t * t,\n            t3 = t2 * t,\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n            ax = t1 * p1x + t * c1x,\n            ay = t1 * p1y + t * c1y,\n            cx = t1 * c2x + t * p2x,\n            cy = t1 * c2y + t * p2y,\n            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n        // (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {x: mx, y: my},\n            n: {x: nx, y: ny},\n            start: {x: ax, y: ay},\n            end: {x: cx, y: cy},\n            alpha: alpha\n        };\n    }\n    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!Snap.is(p1x, \"array\")) {\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return box(\n            bbox.min.x,\n            bbox.min.y,\n            bbox.max.x - bbox.min.x,\n            bbox.max.y - bbox.min.y\n        );\n    }\n    function isPointInsideBBox(bbox, x, y) {\n        return  x >= bbox.x &&\n                x <= bbox.x + bbox.width &&\n                y >= bbox.y &&\n                y <= bbox.y + bbox.height;\n    }\n    function isBBoxIntersect(bbox1, bbox2) {\n        bbox1 = box(bbox1);\n        bbox2 = box(bbox2);\n        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    }\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2,\n            n = 12,\n            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n            sum = 0;\n        for (var i = 0; i < n; i++) {\n            var ct = z2 * Tvalues[i] + z2,\n                xbase = base3(ct, x1, x2, x3, x4),\n                ybase = base3(ct, y1, y2, y3, y4),\n                comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1,\n            step = t / 2,\n            t2 = t - step,\n            l,\n            e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while (abs(l - ll) > e) {\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (\n            mmax(x1, x2) < mmin(x3, x4) ||\n            mmin(x1, x2) > mmax(x3, x4) ||\n            mmax(y1, y2) < mmin(y3, y4) ||\n            mmin(y1, y2) > mmax(y3, y4)\n        ) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator,\n            py = ny / denominator,\n            px2 = +px.toFixed(2),\n            py2 = +py.toFixed(2);\n        if (\n            px2 < +mmin(x1, x2).toFixed(2) ||\n            px2 > +mmax(x1, x2).toFixed(2) ||\n            px2 < +mmin(x3, x4).toFixed(2) ||\n            px2 > +mmax(x3, x4).toFixed(2) ||\n            py2 < +mmin(y1, y2).toFixed(2) ||\n            py2 > +mmax(y1, y2).toFixed(2) ||\n            py2 < +mmin(y3, y4).toFixed(2) ||\n            py2 > +mmax(y3, y4).toFixed(2)\n        ) {\n            return;\n        }\n        return {x: px, y: py};\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = bezierBBox(bez1),\n            bbox2 = bezierBBox(bez2);\n        if (!isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1),\n            l2 = bezlen.apply(0, bez2),\n            n1 = ~~(l1 / 8),\n            n2 = ~~(l2 / 8),\n            dots1 = [],\n            dots2 = [],\n            xy = {},\n            res = justCount ? 0 : [];\n        for (var i = 0; i < n1 + 1; i++) {\n            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n            dots1.push({x: p.x, y: p.y, t: i / n1});\n        }\n        for (i = 0; i < n2 + 1; i++) {\n            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n            dots2.push({x: p.x, y: p.y, t: i / n2});\n        }\n        for (i = 0; i < n1; i++) {\n            for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n                        if (justCount) {\n                            res++;\n                        } else {\n                            res.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: t1,\n                                t2: t2\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function pathIntersection(path1, path2) {\n        return interPathHelper(path1, path2);\n    }\n    function pathIntersectionNumber(path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    }\n    function interPathHelper(path1, path2, justCount) {\n        path1 = path2curve(path1);\n        path2 = path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n            res = justCount ? 0 : [];\n        for (var i = 0, ii = path1.length; i < ii; i++) {\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [x1, y1].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [x2, y2].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res += intr;\n                        } else {\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res = res.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function isPointInsidePath(path, x, y) {\n        var bbox = pathBBox(path);\n        return isPointInsideBBox(bbox, x, y) &&\n               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n    }\n    function pathBBox(path) {\n        var pth = paths(path);\n        if (pth.bbox) {\n            return clone(pth.bbox);\n        }\n        if (!path) {\n            return box();\n        }\n        path = path2curve(path);\n        var x = 0,\n            y = 0,\n            X = [],\n            Y = [],\n            p;\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            p = path[i];\n            if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n            } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X.concat(dim.min.x, dim.max.x);\n                Y = Y.concat(dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n            }\n        }\n        var xmin = mmin.apply(0, X),\n            ymin = mmin.apply(0, Y),\n            xmax = mmax.apply(0, X),\n            ymax = mmax.apply(0, Y),\n            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n        pth.bbox = clone(bb);\n        return bb;\n    }\n    function rectPath(x, y, w, h, r) {\n        if (r) {\n            return [\n                [\"M\", +x + (+r), y],\n                [\"l\", w - r * 2, 0],\n                [\"a\", r, r, 0, 0, 1, r, r],\n                [\"l\", 0, h - r * 2],\n                [\"a\", r, r, 0, 0, 1, -r, r],\n                [\"l\", r * 2 - w, 0],\n                [\"a\", r, r, 0, 0, 1, -r, -r],\n                [\"l\", 0, r * 2 - h],\n                [\"a\", r, r, 0, 0, 1, r, -r],\n                [\"z\"]\n            ];\n        }\n        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n        res.toString = toString;\n        return res;\n    }\n    function ellipsePath(x, y, rx, ry, a) {\n        if (a == null && ry == null) {\n            ry = rx;\n        }\n        x = +x;\n        y = +y;\n        rx = +rx;\n        ry = +ry;\n        if (a != null) {\n            var rad = Math.PI / 180,\n                x1 = x + rx * Math.cos(-ry * rad),\n                x2 = x + rx * Math.cos(-a * rad),\n                y1 = y + rx * Math.sin(-ry * rad),\n                y2 = y + rx * Math.sin(-a * rad),\n                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n        } else {\n            res = [\n                [\"M\", x, y],\n                [\"m\", 0, -ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n                [\"z\"]\n            ];\n        }\n        res.toString = toString;\n        return res;\n    }\n    var unit2px = Snap._unit2px,\n        getPath = {\n        path: function (el) {\n            return el.attr(\"path\");\n        },\n        circle: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx, attr.cy, attr.r);\n        },\n        ellipse: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n        },\n        rect: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n        },\n        image: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n        },\n        line: function (el) {\n            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n        },\n        polyline: function (el) {\n            return \"M\" + el.attr(\"points\");\n        },\n        polygon: function (el) {\n            return \"M\" + el.attr(\"points\") + \"z\";\n        },\n        deflt: function (el) {\n            var bbox = el.node.getBBox();\n            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n        }\n    };\n    function pathToRelative(pathArray) {\n        var pth = paths(pathArray),\n            lowerCase = String.prototype.toLowerCase;\n        if (pth.rel) {\n            return pathClone(pth.rel);\n        }\n        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0;\n        if (pathArray[0][0] == \"M\") {\n            x = pathArray[0][1];\n            y = pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res.push([\"M\", x, y]);\n        }\n        for (var i = start, ii = pathArray.length; i < ii; i++) {\n            var r = res[i] = [],\n                pa = pathArray[i];\n            if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n                switch (r[0]) {\n                    case \"a\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +(pa[6] - x).toFixed(3);\n                        r[7] = +(pa[7] - y).toFixed(3);\n                        break;\n                    case \"v\":\n                        r[1] = +(pa[1] - y).toFixed(3);\n                        break;\n                    case \"m\":\n                        mx = pa[1];\n                        my = pa[2];\n                    default:\n                        for (var j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n                        }\n                }\n            } else {\n                r = res[i] = [];\n                if (pa[0] == \"m\") {\n                    mx = pa[1] + x;\n                    my = pa[2] + y;\n                }\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    res[i][k] = pa[k];\n                }\n            }\n            var len = res[i].length;\n            switch (res[i][0]) {\n                case \"z\":\n                    x = mx;\n                    y = my;\n                    break;\n                case \"h\":\n                    x += +res[i][len - 1];\n                    break;\n                case \"v\":\n                    y += +res[i][len - 1];\n                    break;\n                default:\n                    x += +res[i][len - 2];\n                    y += +res[i][len - 1];\n            }\n        }\n        res.toString = toString;\n        pth.rel = pathClone(res);\n        return res;\n    }\n    function pathToAbsolute(pathArray) {\n        var pth = paths(pathArray);\n        if (pth.abs) {\n            return pathClone(pth.abs);\n        }\n        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        if (!pathArray || !pathArray.length) {\n            return [[\"M\", 0, 0]];\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0,\n            pa0;\n        if (pathArray[0][0] == \"M\") {\n            x = +pathArray[0][1];\n            y = +pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res[0] = [\"M\", x, y];\n        }\n        var crz = pathArray.length == 3 &&\n            pathArray[0][0] == \"M\" &&\n            pathArray[1][0].toUpperCase() == \"R\" &&\n            pathArray[2][0].toUpperCase() == \"Z\";\n        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n            res.push(r = []);\n            pa = pathArray[i];\n            pa0 = pa[0];\n            if (pa0 != pa0.toUpperCase()) {\n                r[0] = pa0.toUpperCase();\n                switch (r[0]) {\n                    case \"A\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +pa[6] + x;\n                        r[7] = +pa[7] + y;\n                        break;\n                    case \"V\":\n                        r[1] = +pa[1] + y;\n                        break;\n                    case \"H\":\n                        r[1] = +pa[1] + x;\n                        break;\n                    case \"R\":\n                        var dots = [x, y].concat(pa.slice(1));\n                        for (var j = 2, jj = dots.length; j < jj; j++) {\n                            dots[j] = +dots[j] + x;\n                            dots[++j] = +dots[j] + y;\n                        }\n                        res.pop();\n                        res = res.concat(catmullRom2bezier(dots, crz));\n                        break;\n                    case \"O\":\n                        res.pop();\n                        dots = ellipsePath(x, y, pa[1], pa[2]);\n                        dots.push(dots[0]);\n                        res = res.concat(dots);\n                        break;\n                    case \"U\":\n                        res.pop();\n                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n                        break;\n                    case \"M\":\n                        mx = +pa[1] + x;\n                        my = +pa[2] + y;\n                    default:\n                        for (j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +pa[j] + ((j % 2) ? x : y);\n                        }\n                }\n            } else if (pa0 == \"R\") {\n                dots = [x, y].concat(pa.slice(1));\n                res.pop();\n                res = res.concat(catmullRom2bezier(dots, crz));\n                r = [\"R\"].concat(pa.slice(-2));\n            } else if (pa0 == \"O\") {\n                res.pop();\n                dots = ellipsePath(x, y, pa[1], pa[2]);\n                dots.push(dots[0]);\n                res = res.concat(dots);\n            } else if (pa0 == \"U\") {\n                res.pop();\n                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n            } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    r[k] = pa[k];\n                }\n            }\n            pa0 = pa0.toUpperCase();\n            if (pa0 != \"O\") {\n                switch (r[0]) {\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n        }\n        res.toString = toString;\n        pth.abs = pathClone(res);\n        return res;\n    }\n    function l2c(x1, y1, x2, y2) {\n        return [x1, y1, x2, y2, x2, y2];\n    }\n    function q2c(x1, y1, ax, ay, x2, y2) {\n        var _13 = 1 / 3,\n            _23 = 2 / 3;\n        return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n        // for more information of where this math came from visit:\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        var _120 = PI * 120 / 180,\n            rad = PI / 180 * (+angle || 0),\n            res = [],\n            xy,\n            rotate = Snap._.cacher(function (x, y, rad) {\n                var X = x * math.cos(rad) - y * math.sin(rad),\n                    Y = x * math.sin(rad) + y * math.cos(rad);\n                return {x: X, y: Y};\n            });\n        if (!recursive) {\n            xy = rotate(x1, y1, -rad);\n            x1 = xy.x;\n            y1 = xy.y;\n            xy = rotate(x2, y2, -rad);\n            x2 = xy.x;\n            y2 = xy.y;\n            var cos = math.cos(PI / 180 * angle),\n                sin = math.sin(PI / 180 * angle),\n                x = (x1 - x2) / 2,\n                y = (y1 - y2) / 2;\n            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n            if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n            }\n            var rx2 = rx * rx,\n                ry2 = ry * ry,\n                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                cx = k * rx * y / ry + (x1 + x2) / 2,\n                cy = k * -ry * x / rx + (y1 + y2) / 2,\n                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n            f1 = x1 < cx ? PI - f1 : f1;\n            f2 = x2 < cx ? PI - f2 : f2;\n            f1 < 0 && (f1 = PI * 2 + f1);\n            f2 < 0 && (f2 = PI * 2 + f2);\n            if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n            }\n            if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n            }\n        } else {\n            f1 = recursive[0];\n            f2 = recursive[1];\n            cx = recursive[2];\n            cy = recursive[3];\n        }\n        var df = f2 - f1;\n        if (abs(df) > _120) {\n            var f2old = f2,\n                x2old = x2,\n                y2old = y2;\n            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n            x2 = cx + rx * math.cos(f2);\n            y2 = cy + ry * math.sin(f2);\n            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n        }\n        df = f2 - f1;\n        var c1 = math.cos(f1),\n            s1 = math.sin(f1),\n            c2 = math.cos(f2),\n            s2 = math.sin(f2),\n            t = math.tan(df / 4),\n            hx = 4 / 3 * rx * t,\n            hy = 4 / 3 * ry * t,\n            m1 = [x1, y1],\n            m2 = [x1 + hx * s1, y1 - hy * c1],\n            m3 = [x2 + hx * s2, y2 - hy * c2],\n            m4 = [x2, y2];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (recursive) {\n            return [m2, m3, m4].concat(res);\n        } else {\n            res = [m2, m3, m4].concat(res).join().split(\",\");\n            var newres = [];\n            for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n            }\n            return newres;\n        }\n    }\n    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t;\n        return {\n            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n        };\n    }\n\n    // Returns bounding box of cubic bezier curve.\n    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // Original version: NISHIO Hirokazu\n    // Modifications: https://github.com/timo22345\n    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var tvalues = [],\n            bounds = [[], []],\n            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        for (var i = 0; i < 2; ++i) {\n            if (i == 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = math.sqrt(b2ac);\n            if (b2ac < 0) {\n                continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n\n        var x, y, j = tvalues.length,\n            jlen = j,\n            mt;\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n        }\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        bounds[0].length = bounds[1].length = jlen + 2;\n\n\n        return {\n          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n        };\n    }\n\n    function path2curve(path, path2) {\n        var pth = !path2 && paths(path);\n        if (!path2 && pth.curve) {\n            return pathClone(pth.curve);\n        }\n        var p = pathToAbsolute(path),\n            p2 = path2 && pathToAbsolute(path2),\n            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            processPath = function (path, d, pcom) {\n                var nx, ny;\n                if (!path) {\n                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n                }\n                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n                switch (path[0]) {\n                    case \"M\":\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n                    case \"A\":\n                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        break;\n                    case \"S\":\n                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n                            nx = d.x * 2 - d.bx;          // And reflect the previous\n                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n                        }\n                        else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = [\"C\", nx, ny].concat(path.slice(1));\n                        break;\n                    case \"T\":\n                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n                        }\n                        else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n                    case \"Q\":\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n                    case \"L\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n                        break;\n                    case \"H\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n                        break;\n                    case \"V\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n                        break;\n                    case \"Z\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n                        break;\n                }\n                return path;\n            },\n            fixArc = function (pp, i) {\n                if (pp[i].length > 7) {\n                    pp[i].shift();\n                    var pi = pp[i];\n                    while (pi.length) {\n                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                        p2 && (pcoms2[i] = \"A\"); // the same as above\n                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n                    }\n                    pp.splice(i, 1);\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            fixM = function (path1, path2, a1, a2, i) {\n                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                    a1.bx = 0;\n                    a1.by = 0;\n                    a1.x = path1[i][1];\n                    a1.y = path1[i][2];\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            pcoms1 = [], // path commands of original path p\n            pcoms2 = [], // path commands of original path p2\n            pfirst = \"\", // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n            p[i] && (pfirst = p[i][0]); // save current path command\n\n            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n            {\n                pcoms1[i] = pfirst; // Save current path command\n                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n            }\n            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n            // which may produce multiple C:s\n            // so we have to make sure that C is also C in original path\n\n            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n            if (p2) { // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n                if (pfirst != \"C\") {\n                    pcoms2[i] = pfirst;\n                    i && (pcom = pcoms2[i - 1]);\n                }\n                p2[i] = processPath(p2[i], attrs2, pcom);\n\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                    pcoms2[i] = \"C\";\n                }\n\n                fixArc(p2, i);\n            }\n            fixM(p, p2, attrs, attrs2, i);\n            fixM(p2, p, attrs2, attrs, i);\n            var seg = p[i],\n                seg2 = p2 && p2[i],\n                seglen = seg.length,\n                seg2len = p2 && seg2.length;\n            attrs.x = seg[seglen - 2];\n            attrs.y = seg[seglen - 1];\n            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n            attrs2.x = p2 && seg2[seg2len - 2];\n            attrs2.y = p2 && seg2[seg2len - 1];\n        }\n        if (!p2) {\n            pth.curve = pathClone(p);\n        }\n        return p2 ? [p, p2] : p;\n    }\n    function mapPath(path, matrix) {\n        if (!matrix) {\n            return path;\n        }\n        var x, y, i, j, ii, jj, pathi;\n        path = path2curve(path);\n        for (i = 0, ii = path.length; i < ii; i++) {\n            pathi = path[i];\n            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n            }\n        }\n        return path;\n    }\n\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n            var p = [\n                        {x: +crp[i - 2], y: +crp[i - 1]},\n                        {x: +crp[i],     y: +crp[i + 1]},\n                        {x: +crp[i + 2], y: +crp[i + 3]},\n                        {x: +crp[i + 4], y: +crp[i + 5]}\n                    ];\n            if (z) {\n                if (!i) {\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n                } else if (iLen - 4 == i) {\n                    p[3] = {x: +crp[0], y: +crp[1]};\n                } else if (iLen - 2 == i) {\n                    p[2] = {x: +crp[0], y: +crp[1]};\n                    p[3] = {x: +crp[2], y: +crp[3]};\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n                }\n            }\n            d.push([\"C\",\n                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n                  p[2].x,\n                  p[2].y\n            ]);\n        }\n\n        return d;\n    }\n\n    // export\n    Snap.path = paths;\n\n    /*\\\n     * Snap.path.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the given path in pixels\n     **\n     - path (string) SVG path string\n     **\n     = (number) length\n    \\*/\n    Snap.path.getTotalLength = getTotalLength;\n    /*\\\n     * Snap.path.getPointAtLength\n     [ method ]\n     **\n     * Returns the coordinates of the point located at the given length along the given path\n     **\n     - path (string) SVG path string\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    Snap.path.getPointAtLength = getPointAtLength;\n    /*\\\n     * Snap.path.getSubpath\n     [ method ]\n     **\n     * Returns the subpath of a given path between given start and end lengths\n     **\n     - path (string) SVG path string\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    Snap.path.getSubpath = function (path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*\\\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the path in pixels (only works for `path` elements)\n     = (number) length\n    \\*/\n    elproto.getTotalLength = function () {\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n    };\n    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n    /*\\\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n     **\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    elproto.getPointAtLength = function (length) {\n        return getPointAtLength(this.attr(\"d\"), length);\n    };\n    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n    /*\\\n     * Element.getSubpath\n     [ method ]\n     **\n     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n     **\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    elproto.getSubpath = function (from, to) {\n        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n    };\n    Snap._.box = box;\n    /*\\\n     * Snap.path.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds dot coordinates on the given cubic beziér curve at the given t\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point,\n     o     y: (number) y coordinate of the point,\n     o     m: {\n     o         x: (number) x coordinate of the left anchor,\n     o         y: (number) y coordinate of the left anchor\n     o     },\n     o     n: {\n     o         x: (number) x coordinate of the right anchor,\n     o         y: (number) y coordinate of the right anchor\n     o     },\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve,\n     o         y: (number) y coordinate of the start of the curve\n     o     },\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve,\n     o         y: (number) y coordinate of the end of the curve\n     o     },\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n    \\*/\n    Snap.path.findDotsAtSegment = findDotsAtSegment;\n    /*\\\n     * Snap.path.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given cubic beziér curve\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for beziér curve\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.bezierBBox = bezierBBox;\n    /*\\\n     * Snap.path.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding box\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point is inside\n    \\*/\n    Snap.path.isPointInsideBBox = isPointInsideBBox;\n    Snap.closest = function (x, y, X, Y) {\n        var r = 100,\n            b = box(x - r / 2, y - r / 2, r, r),\n            inside = [],\n            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n                return {\n                    x: X[i].x,\n                    y: X[i].y\n                };\n            } : function (i) {\n                return {\n                    x: X[i],\n                    y: Y[i]\n                };\n            },\n            found = 0;\n        while (r <= 1e6 && !found) {\n            for (var i = 0, ii = X.length; i < ii; i++) {\n                var xy = getter(i);\n                if (isPointInsideBBox(b, xy.x, xy.y)) {\n                    found++;\n                    inside.push(xy);\n                    break;\n                }\n            }\n            if (!found) {\n                r *= 2;\n                b = box(x - r / 2, y - r / 2, r, r)\n            }\n        }\n        if (r == 1e6) {\n            return;\n        }\n        var len = Infinity,\n            res;\n        for (i = 0, ii = inside.length; i < ii; i++) {\n            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n            if (len > l) {\n                len = l;\n                inside[i].len = l;\n                res = inside[i];\n            }\n        }\n        return res;\n    };\n    /*\\\n     * Snap.path.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if bounding boxes intersect\n    \\*/\n    Snap.path.isBBoxIntersect = isBBoxIntersect;\n    /*\\\n     * Snap.path.intersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point,\n     o         y: (number) y coordinate of the point,\n     o         t1: (number) t value for segment of path1,\n     o         t2: (number) t value for segment of path2,\n     o         segment1: (number) order number for segment of path1,\n     o         segment2: (number) order number for segment of path2,\n     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,\n     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n     o     }\n     o ]\n    \\*/\n    Snap.path.intersection = pathIntersection;\n    Snap.path.intersectionNumber = pathIntersectionNumber;\n    /*\\\n     * Snap.path.isPointInside\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     *\n     * Note: fill mode doesn’t affect the result of this method.\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) `true` if point is inside the path\n    \\*/\n    Snap.path.isPointInside = isPointInsidePath;\n    /*\\\n     * Snap.path.getBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given path\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.getBBox = pathBBox;\n    Snap.path.get = getPath;\n    /*\\\n     * Snap.path.toRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into relative values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toRelative = pathToRelative;\n    /*\\\n     * Snap.path.toAbsolute\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into absolute values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toAbsolute = pathToAbsolute;\n    /*\\\n     * Snap.path.toCubic\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic beziér curves\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments\n    \\*/\n    Snap.path.toCubic = path2curve;\n    /*\\\n     * Snap.path.map\n     [ method ]\n     **\n     * Transform the path string with the given matrix\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n    \\*/\n    Snap.path.map = mapPath;\n    Snap.path.toString = toString;\n    Snap.path.clone = pathClone;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var mmax = Math.max,\n        mmin = Math.min;\n\n    // Set\n    var Set = function (items) {\n        this.items = [];\n\tthis.bindings = {};\n        this.length = 0;\n        this.type = \"set\";\n        if (items) {\n            for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i]) {\n                    this[this.items.length] = this.items[this.items.length] = items[i];\n                    this.length++;\n                }\n            }\n        }\n    },\n    setproto = Set.prototype;\n    /*\\\n     * Set.push\n     [ method ]\n     **\n     * Adds each argument to the current set\n     = (object) original element\n    \\*/\n    setproto.push = function () {\n        var item,\n            len;\n        for (var i = 0, ii = arguments.length; i < ii; i++) {\n            item = arguments[i];\n            if (item) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.pop\n     [ method ]\n     **\n     * Removes last element and returns it\n     = (object) element\n    \\*/\n    setproto.pop = function () {\n        this.length && delete this[this.length--];\n        return this.items.pop();\n    };\n    /*\\\n     * Set.forEach\n     [ method ]\n     **\n     * Executes given function for each element in the set\n     *\n     * If the function returns `false`, the loop stops running.\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Set object\n    \\*/\n    setproto.forEach = function (callback, thisArg) {\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.animate\n     [ method ]\n     **\n     * Animates each element in set in sync.\n     *\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     * or\n     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n     > Usage\n     | // animate all elements in set to radius 10\n     | set.animate({r: 10}, 500, mina.easein);\n     | // or\n     | // animate first element to radius 10, but second to radius 20 and in different time\n     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n     = (Element) the current element\n    \\*/\n    setproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Snap._.Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var args = arguments;\n        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n            var each = true;\n        }\n        var begin,\n            handler = function () {\n                if (begin) {\n                    this.b = begin;\n                } else {\n                    begin = this.b;\n                }\n            },\n            cb = 0,\n            set = this,\n            callbacker = callback && function () {\n                if (++cb == set.length) {\n                    callback.call(this);\n                }\n            };\n        return this.forEach(function (el, i) {\n            eve.once(\"snap.animcreated.\" + el.id, handler);\n            if (each) {\n                args[i] && el.animate.apply(el, args[i]);\n            } else {\n                el.animate(attrs, ms, easing, callbacker);\n            }\n        });\n    };\n    setproto.remove = function () {\n        while (this.length) {\n            this.pop().remove();\n        }\n        return this;\n    };\n    /*\\\n     * Set.bind\n     [ method ]\n     **\n     * Specifies how to handle a specific attribute when applied\n     * to a set.\n     *\n     **\n     - attr (string) attribute name\n     - callback (function) function to run\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     - eattr (string) attribute on the element to bind the attribute to\n     = (object) Set object\n    \\*/\n    setproto.bind = function (attr, a, b) {\n        var data = {};\n        if (typeof a == \"function\") {\n            this.bindings[attr] = a;\n        } else {\n            var aname = b || attr;\n            this.bindings[attr] = function (v) {\n                data[aname] = v;\n                a.attr(data);\n            };\n        }\n        return this;\n    };\n    setproto.attr = function (value) {\n        var unbound = {};\n        for (var k in value) {\n            if (this.bindings[k]) {\n                this.bindings[k](value[k]);\n            } else {\n                unbound[k] = value[k];\n            }\n        }\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            this.items[i].attr(unbound);\n        }\n        return this;\n    };\n    /*\\\n     * Set.clear\n     [ method ]\n     **\n     * Removes all elements from the set\n    \\*/\n    setproto.clear = function () {\n        while (this.length) {\n            this.pop();\n        }\n    };\n    /*\\\n     * Set.splice\n     [ method ]\n     **\n     * Removes range of elements from the set\n     **\n     - index (number) position of the deletion\n     - count (number) number of element to remove\n     - insertion… (object) #optional elements to insert\n     = (object) set elements that were deleted\n    \\*/\n    setproto.splice = function (index, count, insertion) {\n        index = index < 0 ? mmax(this.length + index, 0) : index;\n        count = mmax(0, mmin(this.length - index, count));\n        var tail = [],\n            todel = [],\n            args = [],\n            i;\n        for (i = 2; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        for (i = 0; i < count; i++) {\n            todel.push(this[index + i]);\n        }\n        for (; i < this.length - index; i++) {\n            tail.push(this[index + i]);\n        }\n        var arglen = args.length;\n        for (i = 0; i < arglen + tail.length; i++) {\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n        }\n        i = this.items.length = this.length -= count - arglen;\n        while (this[i]) {\n            delete this[i++];\n        }\n        return new Set(todel);\n    };\n    /*\\\n     * Set.exclude\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     - element (object) element to remove\n     = (boolean) `true` if object was found and removed from the set\n    \\*/\n    setproto.exclude = function (el) {\n        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n            this.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n    setproto.insertAfter = function (el) {\n        var i = this.items.length;\n        while (i--) {\n            this.items[i].insertAfter(el);\n        }\n        return this;\n    };\n    setproto.getBBox = function () {\n        var x = [],\n            y = [],\n            x2 = [],\n            y2 = [];\n        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n            var box = this.items[i].getBBox();\n            x.push(box.x);\n            y.push(box.y);\n            x2.push(box.x + box.width);\n            y2.push(box.y + box.height);\n        }\n        x = mmin.apply(0, x);\n        y = mmin.apply(0, y);\n        x2 = mmax.apply(0, x2);\n        y2 = mmax.apply(0, y2);\n        return {\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2,\n            width: x2 - x,\n            height: y2 - y,\n            cx: x + (x2 - x) / 2,\n            cy: y + (y2 - y) / 2\n        };\n    };\n    setproto.clone = function (s) {\n        s = new Set;\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            s.push(this.items[i].clone());\n        }\n        return s;\n    };\n    setproto.toString = function () {\n        return \"Snap\\u2018s set\";\n    };\n    setproto.type = \"set\";\n    // export\n    Snap.Set = Set;\n    Snap.set = function () {\n        var set = new Set;\n        if (arguments.length) {\n            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n        }\n        return set;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var names = {},\n        reUnit = /[a-z]+$/i,\n        Str = String;\n    names.stroke = names.fill = \"colour\";\n    function getEmpty(item) {\n        var l = item[0];\n        switch (l.toLowerCase()) {\n            case \"t\": return [l, 0, 0];\n            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n            case \"r\": if (item.length == 4) {\n                return [l, 0, item[2], item[3]];\n            } else {\n                return [l, 0];\n            }\n            case \"s\": if (item.length == 5) {\n                return [l, 1, 1, item[3], item[4]];\n            } else if (item.length == 3) {\n                return [l, 1, 1];\n            } else {\n                return [l, 1];\n            }\n        }\n    }\n    function equaliseTransform(t1, t2, getBBox) {\n        t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n        t1 = Snap.parseTransformString(t1) || [];\n        t2 = Snap.parseTransformString(t2) || [];\n        var maxlength = Math.max(t1.length, t2.length),\n            from = [],\n            to = [],\n            i = 0, j, jj,\n            tt1, tt2;\n        for (; i < maxlength; i++) {\n            tt1 = t1[i] || getEmpty(t2[i]);\n            tt2 = t2[i] || getEmpty(tt1);\n            if ((tt1[0] != tt2[0]) ||\n                (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n                (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n                ) {\n                    t1 = Snap._.transform2matrix(t1, getBBox());\n                    t2 = Snap._.transform2matrix(t2, getBBox());\n                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n                    break;\n            }\n            from[i] = [];\n            to[i] = [];\n            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n            }\n        }\n        return {\n            from: path2array(from),\n            to: path2array(to),\n            f: getPath(from)\n        };\n    }\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    function getViewBox(val) {\n        return val.join(\" \");\n    }\n    function getColour(clr) {\n        return Snap.rgb(clr[0], clr[1], clr[2]);\n    }\n    function getPath(path) {\n        var k = 0, i, ii, j, jj, out, a, b = [];\n        for (i = 0, ii = path.length; i < ii; i++) {\n            out = \"[\";\n            a = ['\"' + path[i][0] + '\"'];\n            for (j = 1, jj = path[i].length; j < jj; j++) {\n                a[j] = \"val[\" + (k++) + \"]\";\n            }\n            out += a + \"]\";\n            b[i] = out;\n        }\n        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n    }\n    function path2array(path) {\n        var out = [];\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            for (var j = 1, jj = path[i].length; j < jj; j++) {\n                out.push(path[i][j]);\n            }\n        }\n        return out;\n    }\n    function isNumeric(obj) {\n        return isFinite(parseFloat(obj));\n    }\n    function arrayEqual(arr1, arr2) {\n        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n            return false;\n        }\n        return arr1.toString() == arr2.toString();\n    }\n    Element.prototype.equal = function (name, b) {\n        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n    };\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this;\n        if (isNumeric(a) && isNumeric(b)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getNumber\n            };\n        }\n        if (names[name] == \"colour\") {\n            A = Snap.color(a);\n            B = Snap.color(b);\n            return {\n                from: [A.r, A.g, A.b, A.opacity],\n                to: [B.r, B.g, B.b, B.opacity],\n                f: getColour\n            };\n        }\n        if (name == \"viewBox\") {\n            A = this.attr(name).vb.split(\" \").map(Number);\n            B = b.split(\" \").map(Number);\n            return {\n                from: A,\n                to: B,\n                f: getViewBox\n            };\n        }\n        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n            if (b instanceof Snap.Matrix) {\n                b = b.toTransformString();\n            }\n            if (!Snap._.rgTransform.test(b)) {\n                b = Snap._.svgTransform2string(b);\n            }\n            return equaliseTransform(a, b, function () {\n                return el.getBBox(1);\n            });\n        }\n        if (name == \"d\" || name == \"path\") {\n            A = Snap.path.toCubic(a, b);\n            return {\n                from: path2array(A[0]),\n                to: path2array(A[1]),\n                f: getPath(A[0])\n            };\n        }\n        if (name == \"points\") {\n            A = Str(a).split(Snap._.separator);\n            B = Str(b).split(Snap._.separator);\n            return {\n                from: A,\n                to: B,\n                f: function (val) { return val; }\n            };\n        }\n        var aUnit = a.match(reUnit),\n            bUnit = Str(b).match(reUnit);\n        if (aUnit && arrayEqual(aUnit, bUnit)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getUnit(aUnit)\n            };\n        } else {\n            return {\n                from: this.asPX(name),\n                to: this.asPX(name, b),\n                f: getNumber\n            };\n        }\n    });\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n    has = \"hasOwnProperty\",\n    supportsTouch = \"createTouch\" in glob.doc,\n    events = [\n        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n        \"touchcancel\"\n    ],\n    touchMap = {\n        mousedown: \"touchstart\",\n        mousemove: \"touchmove\",\n        mouseup: \"touchend\"\n    },\n    getScroll = function (xy, el) {\n        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n    },\n    preventDefault = function () {\n        this.returnValue = false;\n    },\n    preventTouch = function () {\n        return this.originalEvent.preventDefault();\n    },\n    stopPropagation = function () {\n        this.cancelBubble = true;\n    },\n    stopTouch = function () {\n        return this.originalEvent.stopPropagation();\n    },\n    addEvent = function (obj, type, fn, element) {\n        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n            f = function (e) {\n                var scrollY = getScroll(\"y\", element),\n                    scrollX = getScroll(\"x\", element);\n                if (supportsTouch && touchMap[has](type)) {\n                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n                            var olde = e;\n                            e = e.targetTouches[i];\n                            e.originalEvent = olde;\n                            e.preventDefault = preventTouch;\n                            e.stopPropagation = stopTouch;\n                            break;\n                        }\n                    }\n                }\n                var x = e.clientX + scrollX,\n                    y = e.clientY + scrollY;\n                return fn.call(element, e, x, y);\n            };\n\n        if (type !== realName) {\n            obj.addEventListener(type, f, false);\n        }\n\n        obj.addEventListener(realName, f, false);\n\n        return function () {\n            if (type !== realName) {\n                obj.removeEventListener(type, f, false);\n            }\n\n            obj.removeEventListener(realName, f, false);\n            return true;\n        };\n    },\n    drag = [],\n    dragMove = function (e) {\n        var x = e.clientX,\n            y = e.clientY,\n            scrollY = getScroll(\"y\"),\n            scrollX = getScroll(\"x\"),\n            dragi,\n            j = drag.length;\n        while (j--) {\n            dragi = drag[j];\n            if (supportsTouch) {\n                var i = e.touches && e.touches.length,\n                    touch;\n                while (i--) {\n                    touch = e.touches[i];\n                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n                        break;\n                    }\n                }\n            } else {\n                e.preventDefault();\n            }\n            var node = dragi.el.node,\n                o,\n                next = node.nextSibling,\n                parent = node.parentNode,\n                display = node.style.display;\n            // glob.win.opera && parent.removeChild(node);\n            // node.style.display = \"none\";\n            // o = dragi.el.paper.getElementByPoint(x, y);\n            // node.style.display = display;\n            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n            x += scrollX;\n            y += scrollY;\n            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n        }\n    },\n    dragUp = function (e) {\n        Snap.unmousemove(dragMove).unmouseup(dragUp);\n        var i = drag.length,\n            dragi;\n        while (i--) {\n            dragi = drag[i];\n            dragi.el._drag = {};\n            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            eve.off(\"snap.drag.*.\" + dragi.el.id);\n        }\n        drag = [];\n    };\n    /*\\\n     * Element.click\n     [ method ]\n     **\n     * Adds a click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unclick\n     [ method ]\n     **\n     * Removes a click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds a double click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes a double click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds a mousedown event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes a mousedown event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds a mousemove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes a mousemove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds a mouseout event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes a mouseout event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds a mouseover event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes a mouseover event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds a mouseup event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes a mouseup event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds a touchstart event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes a touchstart event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds a touchmove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes a touchmove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchend\n     [ method ]\n     **\n     * Adds a touchend event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes a touchend event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds a touchcancel event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes a touchcancel event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    for (var i = events.length; i--;) {\n        (function (eventName) {\n            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n                if (Snap.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({\n                        name: eventName,\n                        f: fn,\n                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n                    });\n                } else {\n                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n                        try {\n                            this.events[i].f.call(this);\n                        } catch (e) {}\n                    }\n                }\n                return this;\n            };\n            Snap[\"un\" + eventName] =\n            elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n                while (l--) if (events[l].name == eventName &&\n                               (events[l].f == fn || !fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                    return this;\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n    /*\\\n     * Element.hover\n     [ method ]\n     **\n     * Adds hover event handlers to the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n    \\*/\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*\\\n     * Element.unhover\n     [ method ]\n     **\n     * Removes hover event handlers from the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n    \\*/\n    elproto.unhover = function (f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n    /*\\\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for an element's drag gesture\n     **\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start,\n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element\n     * `drag.over.<id>` fires as well.\n     *\n     * Start event and start handler are called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler are called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler are called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n    \\*/\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        var el = this;\n        if (!arguments.length) {\n            var origTransform;\n            return el.drag(function (dx, dy) {\n                this.attr({\n                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n                });\n            }, function () {\n                origTransform = this.transform().local;\n            });\n        }\n        function start(e, x, y) {\n            (e.originalEvent || e).preventDefault();\n            el._drag.x = x;\n            el._drag.y = y;\n            el._drag.id = e.identifier;\n            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n        }\n        function init(e, x, y) {\n            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n        }\n        eve.on(\"snap.draginit.\" + el.id, start);\n        el._drag = {};\n        draggable.push({el: el, start: start, init: init});\n        el.mousedown(init);\n        return el;\n    };\n    /*\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n     - f (function) handler for event, first argument would be the element you are dragging over\n    \\*/\n    // elproto.onDragOver = function (f) {\n    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n    // };\n    /*\\\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from the given element\n    \\*/\n    elproto.undrag = function () {\n        var i = draggable.length;\n        while (i--) if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].init);\n            draggable.splice(i, 1);\n            eve.unbind(\"snap.drag.*.\" + this.id);\n            eve.unbind(\"snap.draginit.\" + this.id);\n        }\n        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        pproto = Paper.prototype,\n        rgurl = /^\\s*url\\((.+)\\)/,\n        Str = String,\n        $ = Snap._.$;\n    Snap.filter = {};\n    /*\\\n     * Paper.filter\n     [ method ]\n     **\n     * Creates a `<filter>` element\n     **\n     - filstr (string) SVG fragment of filter provided as a string\n     = (object) @Element\n     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n     > Usage\n     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    pproto.filter = function (filstr) {\n        var paper = this;\n        if (paper.type != \"svg\") {\n            paper = paper.paper;\n        }\n        var f = Snap.parse(Str(filstr)),\n            id = Snap._.id(),\n            width = paper.node.offsetWidth,\n            height = paper.node.offsetHeight,\n            filter = $(\"filter\");\n        $(filter, {\n            id: id,\n            filterUnits: \"userSpaceOnUse\"\n        });\n        filter.appendChild(f.node);\n        paper.defs.appendChild(filter);\n        return new Element(filter);\n    };\n\n    eve.on(\"snap.util.getattr.filter\", function () {\n        eve.stop();\n        var p = $(this.node, \"filter\");\n        if (p) {\n            var match = Str(p).match(rgurl);\n            return match && Snap.select(match[1]);\n        }\n    });\n    eve.on(\"snap.util.attr.filter\", function (value) {\n        if (value instanceof Element && value.type == \"filter\") {\n            eve.stop();\n            var id = value.node.id;\n            if (!id) {\n                $(value.node, {id: value.id});\n                id = value.id;\n            }\n            $(this.node, {\n                filter: Snap.url(id)\n            });\n        }\n        if (!value || value == \"none\") {\n            eve.stop();\n            this.node.removeAttribute(\"filter\");\n        }\n    });\n    /*\\\n     * Snap.filter.blur\n     [ method ]\n     **\n     * Returns an SVG markup string for the blur filter\n     **\n     - x (number) amount of horizontal blur, in pixels\n     - y (number) #optional amount of vertical blur, in pixels\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.blur(5, 10)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.blur = function (x, y) {\n        if (x == null) {\n            x = 2;\n        }\n        var def = y == null ? x : [x, y];\n        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n            def: def\n        });\n    };\n    Snap.filter.blur.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.shadow\n     [ method ]\n     **\n     * Returns an SVG markup string for the shadow filter\n     **\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - blur (number) #optional amount of blur\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * which makes blur default to `4`. Or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - opacity (number) #optional `0..1` opacity of the shadow\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n        if (typeof blur == \"string\") {\n            color = blur;\n            opacity = color;\n            blur = 4;\n        }\n        if (typeof color != \"string\") {\n            opacity = color;\n            color = \"#000\";\n        }\n        color = color || \"#000\";\n        if (blur == null) {\n            blur = 4;\n        }\n        if (opacity == null) {\n            opacity = 1;\n        }\n        if (dx == null) {\n            dx = 0;\n            dy = 2;\n        }\n        if (dy == null) {\n            dy = dx;\n        }\n        color = Snap.color(color);\n        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n            color: color,\n            dx: dx,\n            dy: dy,\n            blur: blur,\n            opacity: opacity\n        });\n    };\n    Snap.filter.shadow.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.grayscale\n     [ method ]\n     **\n     * Returns an SVG markup string for the grayscale filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.grayscale = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    };\n    Snap.filter.grayscale.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.sepia\n     [ method ]\n     **\n     * Returns an SVG markup string for the sepia filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.sepia = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    };\n    Snap.filter.sepia.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.saturate\n     [ method ]\n     **\n     * Returns an SVG markup string for the saturate filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.saturate = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n            amount: 1 - amount\n        });\n    };\n    Snap.filter.saturate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.hueRotate\n     [ method ]\n     **\n     * Returns an SVG markup string for the hue-rotate filter\n     **\n     - angle (number) angle of rotation\n     = (string) filter representation\n    \\*/\n    Snap.filter.hueRotate = function (angle) {\n        angle = angle || 0;\n        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n            angle: angle\n        });\n    };\n    Snap.filter.hueRotate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.invert\n     [ method ]\n     **\n     * Returns an SVG markup string for the invert filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.invert = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: 1 - amount\n        });\n    };\n    Snap.filter.invert.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.brightness\n     [ method ]\n     **\n     * Returns an SVG markup string for the brightness filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.brightness = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n            amount: amount\n        });\n    };\n    Snap.filter.brightness.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.contrast\n     [ method ]\n     **\n     * Returns an SVG markup string for the contrast filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.contrast = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    };\n    Snap.filter.contrast.toString = function () {\n        return this();\n    };\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var box = Snap._.box,\n        is = Snap.is,\n        firstLetter = /^[^a-z]*([tbmlrc])/i,\n        toString = function () {\n            return \"T\" + this.dx + \",\" + this.dy;\n        };\n    /*\\\n     * Element.getAlign\n     [ method ]\n     **\n     * Returns shift needed to align the element relatively to given element.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n     > Usage\n     | el.transform(el.getAlign(el2, \"top\"));\n     * or\n     | var dy = el.getAlign(el2, \"top\").dy;\n    \\*/\n    Element.prototype.getAlign = function (el, way) {\n        if (way == null && is(el, \"string\")) {\n            way = el;\n            el = null;\n        }\n        el = el || this.paper;\n        var bx = el.getBBox ? el.getBBox() : box(el),\n            bb = this.getBBox(),\n            out = {};\n        way = way && way.match(firstLetter);\n        way = way ? way[1].toLowerCase() : \"c\";\n        switch (way) {\n            case \"t\":\n                out.dx = 0;\n                out.dy = bx.y - bb.y;\n            break;\n            case \"b\":\n                out.dx = 0;\n                out.dy = bx.y2 - bb.y2;\n            break;\n            case \"m\":\n                out.dx = 0;\n                out.dy = bx.cy - bb.cy;\n            break;\n            case \"l\":\n                out.dx = bx.x - bb.x;\n                out.dy = 0;\n            break;\n            case \"r\":\n                out.dx = bx.x2 - bb.x2;\n                out.dy = 0;\n            break;\n            default:\n                out.dx = bx.cx - bb.cx;\n                out.dy = 0;\n            break;\n        }\n        out.toString = toString;\n        return out;\n    };\n    /*\\\n     * Element.align\n     [ method ]\n     **\n     * Aligns the element relatively to given one via transformation.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object) this element\n     > Usage\n     | el.align(el2, \"top\");\n     * or\n     | el.align(\"middle\");\n    \\*/\n    Element.prototype.align = function (el, way) {\n        return this.transform(\"...\" + this.getAlign(el, way));\n    };\n});\n\nmodule.exports = Snap\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/snapsvg-cjs/dist/snap.svg-cjs.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}