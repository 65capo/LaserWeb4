{"version":3,"sources":["webpack:///ec6ef5e051fb1735e264.worker.js","webpack:///webpack/bootstrap ec6ef5e051fb1735e264","webpack:///./lib/workers/cam-raster.js","webpack:///./lib/lw.raster2gcode/canvas-filters.js","webpack:///./lib/lw.raster2gcode/canvas-grid.js","webpack:///./lib/lw.raster2gcode/raster-to-gcode.js","webpack:///../~/floyd-steinberg/floyd-steinberg.js"],"names":["modules","hotCreateRequire","moduleId","ensure","chunkId","callback","hotStatus","hotSetStatus","hotChunksLoading","__webpack_require__","e","finishChunkLoading","hotWaitingFilesMap","hotEnsureUpdateChunk","hotWaitingFiles","hotUpdateDownloaded","call","fn","me","installedModules","request","hot","active","parents","indexOf","push","children","hotCurrentParents","console","warn","name","Object","prototype","hasOwnProperty","canDefineProperty","defineProperty","configurable","enumerable","get","set","value","hotCreateModule","_acceptedDependencies","_declinedDependencies","_selfAccepted","_selfDeclined","_disposeHandlers","accept","dep","i","length","decline","dispose","addDisposeHandler","removeDisposeHandler","idx","splice","check","hotCheck","apply","hotApply","status","l","hotStatusHandlers","addStatusHandler","removeStatusHandler","data","hotCurrentModuleData","newStatus","toModuleId","id","isNumber","Error","hotApplyOnUpdate","err","hotDownloadManifest","update","hotRequestedFilesMap","hotAvailibleFilesMap","c","hotUpdateNewHash","h","hotCallback","hotUpdate","hotDownloadUpdateChunk","outdatedModules","options","getAffectedStuff","module","outdatedDependencies","queue","slice","pop","parentId","parent","addAllToSet","a","b","item","appliedUpdate","result","ignoreUnaccepted","outdatedSelfAcceptedModules","errorHandler","disposeHandlers","j","cb","child","moduleOutdatedDependencies","dependency","hotCurrentHash","error","callbacks","exports","loaded","x","m","p","start","rasterToGcode","_rasterToGcode","RasterToGcode","settings","assign","properties","on","event","self","postMessage","_extends","run","abort","target","arguments","source","key","onmessage","cmd","__REACT_HOT_LOADER__","register","_interopRequireDefault","obj","__esModule","default","color","invertColor","brightness","undefined","contrast","gamma","Math","exp","log","grayscale","algorithm","shades","grayscaleAlgorithms","gray","r","g","max","min","parseInt","canvasFilters","canvas","smoothing","shadesOfGray","dithering","context","getContext","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","oImageSmoothingEnabled","imageData","getImageData","width","height","contrastFactor","brightnessOffset","gammaCorrection","shadesOfGrayFactor","il","_floydSteinberg2","putImageData","_floydSteinberg","_default","_classCallCheck","instance","Constructor","TypeError","CanvasGrid","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","_canvasFilters","_canvasFilters2","this","cellSize","scaleRatio","y","filters","size","cols","rows","file","image","url","pixels","input","File","loadFromFile","Image","loadFromImage","URL","loadFromURL","trim","Promise","reject","src","resolve","_this","onload","then","catch","onerror","_this2","_loadImage","createObjectURL","_this3","_this4","_processImage","round","ceil","line","sx","sy","sw","sh","document","createElement","fillStyle","fillRect","drawImage","isNaN","col","row","pixelData","grid","coords","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_typeof","Symbol","iterator","_get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","_canvasGrid","_canvasGrid2","_CanvasGrid","ppi","toolDiameter","rapidRate","feedRate","rateUnit","beamRange","beamPower","milling","zSafe","zSurface","zDepth","passDepth","offsets","X","Y","trimLine","joinPixel","burnWhite","verboseG","diagonal","overscan","precision","S","nonBlocking","onProgress","onProgressContext","onDone","onDoneContext","onAbort","onAbortContext","passes","abs","floor","ppm","parseFloat","toFixed","running","gcode","gcodes","currentLine","lastCommands","outputSize","G1","G0","beamOffset","realBeamRange","_registerUserCallbacks","_addHeader","_scanDiagonally","_scanHorizontally","join","range","commands","Array","command","_command","defaultValue","pixel","getPixel","index","point","G","s","_mapPixelPower","first","lastWhite","last","lastColored","shift","points","power","reversed","firstPoint","lastPoint","rightPoint","leftPoint","unshift","_processMillingLine","_processLaserLine","_trimCurrentLine","_reduceCurrentLine","reverse","addCommand","_getPoint","plung","Z","zMax","pass","passNum","_overscanCurrentLine","w","computeCurrentLine","_getPixelPower","percent","lastPercent","processCurrentLine","_processCurrentLine","_onProgress","processNextLine","setTimeout","forEach","_onDone","_onAbort","_this5","totalLines","lineNum","_this6","method","toUpperCase","_this7","heightMap","floyd_steinberg","newPixel","imageDataLength","lumR","lumG","lumB","currentPixel"],"mappings":"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","file":"ec6ef5e051fb1735e264.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n/******/ \tvar canDefineProperty = false;\r\n/******/ \ttry {\r\n/******/ \t\tObject.defineProperty({}, \"x\", {\r\n/******/ \t\t\tget: function() {}\r\n/******/ \t\t});\r\n/******/ \t\tcanDefineProperty = true;\r\n/******/ \t} catch(x) {\r\n/******/ \t\t// IE will fail on defineProperty\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotApplyOnUpdate = true;\r\n/******/ \tvar hotCurrentHash = \"ec6ef5e051fb1735e264\"; // eslint-disable-line no-unused-vars\r\n/******/ \tvar hotCurrentModuleData = {};\r\n/******/ \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n/******/ \t\r\n/******/ \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar me = installedModules[moduleId];\r\n/******/ \t\tif(!me) return __webpack_require__;\r\n/******/ \t\tvar fn = function(request) {\r\n/******/ \t\t\tif(me.hot.active) {\r\n/******/ \t\t\t\tif(installedModules[request]) {\r\n/******/ \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n/******/ \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n/******/ \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n/******/ \t\t\t\t\t\tme.children.push(request);\r\n/******/ \t\t\t\t} else hotCurrentParents = [moduleId];\r\n/******/ \t\t\t} else {\r\n/******/ \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n/******/ \t\t\t\thotCurrentParents = [];\r\n/******/ \t\t\t}\r\n/******/ \t\t\treturn __webpack_require__(request);\r\n/******/ \t\t};\r\n/******/ \t\tfor(var name in __webpack_require__) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n/******/ \t\t\t\tif(canDefineProperty) {\r\n/******/ \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n/******/ \t\t\t\t\t\treturn {\r\n/******/ \t\t\t\t\t\t\tconfigurable: true,\r\n/******/ \t\t\t\t\t\t\tenumerable: true,\r\n/******/ \t\t\t\t\t\t\tget: function() {\r\n/******/ \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n/******/ \t\t\t\t\t\t\t},\r\n/******/ \t\t\t\t\t\t\tset: function(value) {\r\n/******/ \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n/******/ \t\t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\t};\r\n/******/ \t\t\t\t\t}(name)));\r\n/******/ \t\t\t\t} else {\r\n/******/ \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction ensure(chunkId, callback) {\r\n/******/ \t\t\tif(hotStatus === \"ready\")\r\n/******/ \t\t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotChunksLoading++;\r\n/******/ \t\t\t__webpack_require__.e(chunkId, function() {\r\n/******/ \t\t\t\ttry {\r\n/******/ \t\t\t\t\tcallback.call(null, fn);\r\n/******/ \t\t\t\t} finally {\r\n/******/ \t\t\t\t\tfinishChunkLoading();\r\n/******/ \t\t\t\t}\r\n/******/ \t\r\n/******/ \t\t\t\tfunction finishChunkLoading() {\r\n/******/ \t\t\t\t\thotChunksLoading--;\r\n/******/ \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n/******/ \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n/******/ \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\tif(canDefineProperty) {\r\n/******/ \t\t\tObject.defineProperty(fn, \"e\", {\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tvalue: ensure\r\n/******/ \t\t\t});\r\n/******/ \t\t} else {\r\n/******/ \t\t\tfn.e = ensure;\r\n/******/ \t\t}\r\n/******/ \t\treturn fn;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar hot = {\r\n/******/ \t\t\t// private stuff\r\n/******/ \t\t\t_acceptedDependencies: {},\r\n/******/ \t\t\t_declinedDependencies: {},\r\n/******/ \t\t\t_selfAccepted: false,\r\n/******/ \t\t\t_selfDeclined: false,\r\n/******/ \t\t\t_disposeHandlers: [],\r\n/******/ \t\r\n/******/ \t\t\t// Module API\r\n/******/ \t\t\tactive: true,\r\n/******/ \t\t\taccept: function(dep, callback) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfAccepted = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"function\")\r\n/******/ \t\t\t\t\thot._selfAccepted = dep;\r\n/******/ \t\t\t\telse if(typeof dep === \"object\")\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdecline: function(dep) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfDeclined = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"number\")\r\n/******/ \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdispose: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddDisposeHandler: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveDisposeHandler: function(callback) {\r\n/******/ \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n/******/ \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t// Management API\r\n/******/ \t\t\tcheck: hotCheck,\r\n/******/ \t\t\tapply: hotApply,\r\n/******/ \t\t\tstatus: function(l) {\r\n/******/ \t\t\t\tif(!l) return hotStatus;\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddStatusHandler: function(l) {\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveStatusHandler: function(l) {\r\n/******/ \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n/******/ \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t//inherit from previous dispose call\r\n/******/ \t\t\tdata: hotCurrentModuleData[moduleId]\r\n/******/ \t\t};\r\n/******/ \t\treturn hot;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotStatusHandlers = [];\r\n/******/ \tvar hotStatus = \"idle\";\r\n/******/ \t\r\n/******/ \tfunction hotSetStatus(newStatus) {\r\n/******/ \t\thotStatus = newStatus;\r\n/******/ \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n/******/ \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \t// while downloading\r\n/******/ \tvar hotWaitingFiles = 0;\r\n/******/ \tvar hotChunksLoading = 0;\r\n/******/ \tvar hotWaitingFilesMap = {};\r\n/******/ \tvar hotRequestedFilesMap = {};\r\n/******/ \tvar hotAvailibleFilesMap = {};\r\n/******/ \tvar hotCallback;\r\n/******/ \t\r\n/******/ \t// The update info\r\n/******/ \tvar hotUpdate, hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \tfunction toModuleId(id) {\r\n/******/ \t\tvar isNumber = (+id) + \"\" === id;\r\n/******/ \t\treturn isNumber ? +id : id;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCheck(apply, callback) {\r\n/******/ \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n/******/ \t\tif(typeof apply === \"function\") {\r\n/******/ \t\t\thotApplyOnUpdate = false;\r\n/******/ \t\t\tcallback = apply;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotApplyOnUpdate = apply;\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\thotSetStatus(\"check\");\r\n/******/ \t\thotDownloadManifest(function(err, update) {\r\n/******/ \t\t\tif(err) return callback(err);\r\n/******/ \t\t\tif(!update) {\r\n/******/ \t\t\t\thotSetStatus(\"idle\");\r\n/******/ \t\t\t\tcallback(null, null);\r\n/******/ \t\t\t\treturn;\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\thotRequestedFilesMap = {};\r\n/******/ \t\t\thotAvailibleFilesMap = {};\r\n/******/ \t\t\thotWaitingFilesMap = {};\r\n/******/ \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n/******/ \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n/******/ \t\t\thotUpdateNewHash = update.h;\r\n/******/ \t\r\n/******/ \t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotCallback = callback;\r\n/******/ \t\t\thotUpdate = {};\r\n/******/ \t\t\tvar chunkId = 0;\r\n/******/ \t\t\t{ // eslint-disable-line no-lone-blocks\r\n/******/ \t\t\t\t/*globals chunkId */\r\n/******/ \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t}\r\n/******/ \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t}\r\n/******/ \t\t});\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n/******/ \t\t\treturn;\r\n/******/ \t\thotRequestedFilesMap[chunkId] = false;\r\n/******/ \t\tfor(var moduleId in moreModules) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n/******/ \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n/******/ \t\t\thotUpdateDownloaded();\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotEnsureUpdateChunk(chunkId) {\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n/******/ \t\t\thotWaitingFilesMap[chunkId] = true;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotRequestedFilesMap[chunkId] = true;\r\n/******/ \t\t\thotWaitingFiles++;\r\n/******/ \t\t\thotDownloadUpdateChunk(chunkId);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotUpdateDownloaded() {\r\n/******/ \t\thotSetStatus(\"ready\");\r\n/******/ \t\tvar callback = hotCallback;\r\n/******/ \t\thotCallback = null;\r\n/******/ \t\tif(!callback) return;\r\n/******/ \t\tif(hotApplyOnUpdate) {\r\n/******/ \t\t\thotApply(hotApplyOnUpdate, callback);\r\n/******/ \t\t} else {\r\n/******/ \t\t\tvar outdatedModules = [];\r\n/******/ \t\t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t\tcallback(null, outdatedModules);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotApply(options, callback) {\r\n/******/ \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n/******/ \t\tif(typeof options === \"function\") {\r\n/******/ \t\t\tcallback = options;\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t} else if(options && typeof options === \"object\") {\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t} else {\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction getAffectedStuff(module) {\r\n/******/ \t\t\tvar outdatedModules = [module];\r\n/******/ \t\t\tvar outdatedDependencies = {};\r\n/******/ \t\r\n/******/ \t\t\tvar queue = outdatedModules.slice();\r\n/******/ \t\t\twhile(queue.length > 0) {\r\n/******/ \t\t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tif(!module || module.hot._selfAccepted)\r\n/******/ \t\t\t\t\tcontinue;\r\n/******/ \t\t\t\tif(module.hot._selfDeclined) {\r\n/******/ \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(moduleId === 0) {\r\n/******/ \t\t\t\t\treturn;\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n/******/ \t\t\t\t\tvar parentId = module.parents[i];\r\n/******/ \t\t\t\t\tvar parent = installedModules[parentId];\r\n/******/ \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n/******/ \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n/******/ \t\t\t\t\toutdatedModules.push(parentId);\r\n/******/ \t\t\t\t\tqueue.push(parentId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\treturn [outdatedModules, outdatedDependencies];\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction addAllToSet(a, b) {\r\n/******/ \t\t\tfor(var i = 0; i < b.length; i++) {\r\n/******/ \t\t\t\tvar item = b[i];\r\n/******/ \t\t\t\tif(a.indexOf(item) < 0)\r\n/******/ \t\t\t\t\ta.push(item);\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// at begin all updates modules are outdated\r\n/******/ \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n/******/ \t\tvar outdatedDependencies = {};\r\n/******/ \t\tvar outdatedModules = [];\r\n/******/ \t\tvar appliedUpdate = {};\r\n/******/ \t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\tvar moduleId = toModuleId(id);\r\n/******/ \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n/******/ \t\t\t\tif(!result) {\r\n/******/ \t\t\t\t\tif(options.ignoreUnaccepted)\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(result instanceof Error) {\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(result);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n/******/ \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n/******/ \t\t\t\tfor(var moduleId in result[1]) {\r\n/******/ \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Store self accepted outdated modules to require them later by the module system\r\n/******/ \t\tvar outdatedSelfAcceptedModules = [];\r\n/******/ \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n/******/ \t\t\tvar moduleId = outdatedModules[i];\r\n/******/ \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n/******/ \t\t\t\toutdatedSelfAcceptedModules.push({\r\n/******/ \t\t\t\t\tmodule: moduleId,\r\n/******/ \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n/******/ \t\t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Now in \"dispose\" phase\r\n/******/ \t\thotSetStatus(\"dispose\");\r\n/******/ \t\tvar queue = outdatedModules.slice();\r\n/******/ \t\twhile(queue.length > 0) {\r\n/******/ \t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\tif(!module) continue;\r\n/******/ \t\r\n/******/ \t\t\tvar data = {};\r\n/******/ \t\r\n/******/ \t\t\t// Call dispose handlers\r\n/******/ \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n/******/ \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n/******/ \t\t\t\tvar cb = disposeHandlers[j];\r\n/******/ \t\t\t\tcb(data);\r\n/******/ \t\t\t}\r\n/******/ \t\t\thotCurrentModuleData[moduleId] = data;\r\n/******/ \t\r\n/******/ \t\t\t// disable module (this disables requires from this module)\r\n/******/ \t\t\tmodule.hot.active = false;\r\n/******/ \t\r\n/******/ \t\t\t// remove module from cache\r\n/******/ \t\t\tdelete installedModules[moduleId];\r\n/******/ \t\r\n/******/ \t\t\t// remove \"parents\" references from all children\r\n/******/ \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n/******/ \t\t\t\tvar child = installedModules[module.children[j]];\r\n/******/ \t\t\t\tif(!child) continue;\r\n/******/ \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n/******/ \t\t\t\tif(idx >= 0) {\r\n/******/ \t\t\t\t\tchild.parents.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// remove outdated dependency from module children\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n/******/ \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n/******/ \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Not in \"apply\" phase\r\n/******/ \t\thotSetStatus(\"apply\");\r\n/******/ \t\r\n/******/ \t\thotCurrentHash = hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \t\t// insert new code\r\n/******/ \t\tfor(var moduleId in appliedUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n/******/ \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// call accept handlers\r\n/******/ \t\tvar error = null;\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tvar callbacks = [];\r\n/******/ \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n/******/ \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n/******/ \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n/******/ \t\t\t\t\tcallbacks.push(cb);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n/******/ \t\t\t\t\tvar cb = callbacks[i];\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\tcb(outdatedDependencies);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Load self accepted modules\r\n/******/ \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n/******/ \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n/******/ \t\t\tvar moduleId = item.module;\r\n/******/ \t\t\thotCurrentParents = [moduleId];\r\n/******/ \t\t\ttry {\r\n/******/ \t\t\t\t__webpack_require__(moduleId);\r\n/******/ \t\t\t} catch(err) {\r\n/******/ \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\titem.errorHandler(err);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t} else if(!error)\r\n/******/ \t\t\t\t\terror = err;\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// handle errors in accept handlers and self accepted module load\r\n/******/ \t\tif(error) {\r\n/******/ \t\t\thotSetStatus(\"fail\");\r\n/******/ \t\t\treturn callback(error);\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\thotSetStatus(\"idle\");\r\n/******/ \t\tcallback(null, outdatedModules);\r\n/******/ \t}\r\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\thot: hotCreateModule(moduleId),\n/******/ \t\t\tparents: hotCurrentParents,\n/******/ \t\t\tchildren: []\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// __webpack_hash__\n/******/ \t__webpack_require__.h = function() { return hotCurrentHash; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn hotCreateRequire(0)(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _rasterToGcode = __webpack_require__(3);\n\t\n\t// On messsage received\n\tself.onmessage = function (event) {\n\t    if (event.data.cmd === 'start') {\n\t        start(event.data);\n\t    }\n\t};\n\t\n\t// Start job\n\tfunction start(data) {\n\t\n\t    // Create RasterToGcode object\n\t    var rasterToGcode = new _rasterToGcode.RasterToGcode(data.settings);\n\t    Object.assign(rasterToGcode, data.properties);\n\t    // Register events callbacks\n\t    rasterToGcode.on('progress', function (event) {\n\t        self.postMessage(_extends({ event: 'onProgress' }, event));\n\t    }).on('done', function (event) {\n\t        self.postMessage(_extends({ event: 'onDone' }, event));\n\t    }).on('abort', function () {\n\t        self.postMessage({ event: 'onAbort' });\n\t    });\n\t\n\t    self.postMessage({ event: 'start' });\n\t    rasterToGcode.run();\n\t}\n\t\n\t// Abort job\n\tfunction abort() {\n\t    rasterToGcode.abort();\n\t}\n\t;\n\t\n\tvar _temp = function () {\n\t    if (typeof __REACT_HOT_LOADER__ === 'undefined') {\n\t        return;\n\t    }\n\t\n\t    __REACT_HOT_LOADER__.register(start, 'start', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/workers/cam-raster.js');\n\t\n\t    __REACT_HOT_LOADER__.register(abort, 'abort', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/workers/cam-raster.js');\n\t}();\n\n\t;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.canvasFilters = undefined;\n\t\n\tvar _floydSteinberg = __webpack_require__(4);\n\t\n\tvar _floydSteinberg2 = _interopRequireDefault(_floydSteinberg);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Grayscale algorithms\n\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\n\t// Trucate color value in the 0-255 range\n\tfunction color(color) {\n\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t}\n\t\n\t// Filters ...\n\tfunction invertColor(data, i, value) {\n\t    if (value) {\n\t        data[i] = color(255 - data[i]);\n\t        data[i + 1] = color(255 - data[i + 1]);\n\t        data[i + 2] = color(255 - data[i + 2]);\n\t    }\n\t}\n\t\n\tfunction brightness(data, i, value) {\n\t    if (value !== undefined) {\n\t        data[i] = color(data[i] + value);\n\t        data[i + 1] = color(data[i + 1] + value);\n\t        data[i + 2] = color(data[i + 2] + value);\n\t    }\n\t}\n\t\n\tfunction contrast(data, i, value) {\n\t    if (value !== undefined) {\n\t        data[i] = color(value * (data[i] - 128) + 128);\n\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t    }\n\t}\n\t\n\tfunction gamma(data, i, value) {\n\t    if (value !== undefined) {\n\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t    }\n\t}\n\t\n\tfunction grayscale(data, i, algorithm, shades) {\n\t    // Graysale\n\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\n\t    // Unsupported algorithm\n\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t    }\n\t\n\t    // None\n\t    if (algorithm === 'none') {\n\t        return null;\n\t    }\n\t\n\t    // Get Red/Green/Blue values\n\t    var gray = void 0;\n\t    var r = data[i];\n\t    var g = data[i + 1];\n\t    var b = data[i + 2];\n\t\n\t    switch (algorithm) {\n\t        case 'average':\n\t            gray = (r + g + b) / 3;\n\t            break;\n\t\n\t        case 'luma':\n\t            // Default\n\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t            break;\n\t\n\t        case 'luma-601':\n\t            // CCIR-601\n\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t            break;\n\t\n\t        case 'luma-709':\n\t            // ITU-R-709\n\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t            break;\n\t\n\t        case 'luma-240':\n\t            // SMPTE-240M\n\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t            break;\n\t\n\t        case 'desaturation':\n\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t            break;\n\t\n\t        case 'decomposition-min':\n\t            gray = Math.min(r, g, b);\n\t            break;\n\t\n\t        case 'decomposition-max':\n\t            gray = Math.max(r, g, b);\n\t            break;\n\t\n\t        case 'red-chanel':\n\t            gray = r;\n\t            break;\n\t\n\t        case 'green-chanel':\n\t            gray = g;\n\t            break;\n\t\n\t        case 'blue-chanel':\n\t            gray = b;\n\t            break;\n\t    }\n\t\n\t    // Shades of gray\n\t    if (shades !== undefined) {\n\t        gray = parseInt(gray / shades) * shades;\n\t    }\n\t\n\t    // Force integer\n\t    gray = parseInt(gray);\n\t\n\t    // Set new r/g/b values\n\t    data[i] = color(gray);\n\t    data[i + 1] = color(gray);\n\t    data[i + 2] = color(gray);\n\t}\n\t\n\t// Apply filters on provided canvas\n\tfunction canvasFilters(canvas, settings) {\n\t    settings = Object.assign({}, {\n\t        smoothing: false, // Smoothing [true|fale]\n\t        brightness: 0, // Image brightness [-255 to +255]\n\t        contrast: 0, // Image contrast [-255 to +255]\n\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t        shadesOfGray: 256, // Number of shades of gray [2-256]\n\t        invertColor: false, // Invert color...\n\t        dithering: false\n\t    }, settings || {});\n\t\n\t    // Get canvas 2d context\n\t    var context = canvas.getContext('2d');\n\t\n\t    // Smoothing\n\t    if (context.imageSmoothingEnabled !== undefined) {\n\t        context.imageSmoothingEnabled = settings.smoothing;\n\t    } else {\n\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t    }\n\t\n\t    // Get image data\n\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t    var data = imageData.data;\n\t\n\t    var contrastFactor = void 0,\n\t        brightnessOffset = void 0,\n\t        gammaCorrection = void 0,\n\t        shadesOfGrayFactor = void 0;\n\t\n\t    if (settings.contrast !== 0) {\n\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t    }\n\t\n\t    if (settings.brightness !== 0) {\n\t        brightnessOffset = settings.brightness;\n\t    }\n\t\n\t    if (settings.gamma !== 0) {\n\t        gammaCorrection = 1 / settings.gamma;\n\t    }\n\t\n\t    // Shades of gray\n\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t    }\n\t\n\t    // For each pixel\n\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t        // Apply filters\n\t        invertColor(data, i, settings.invertColor);\n\t        brightness(data, i, brightnessOffset);\n\t        contrast(data, i, contrastFactor);\n\t        gamma(data, i, gammaCorrection);\n\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t    }\n\t\n\t    if (settings.dithering) {\n\t        imageData = (0, _floydSteinberg2.default)(imageData);\n\t    }\n\t\n\t    // Write new image data on the context\n\t    context.putImageData(imageData, 0, 0);\n\t}\n\t\n\t// Exports\n\texports.canvasFilters = canvasFilters;\n\tvar _default = canvasFilters;\n\texports.default = _default;\n\t;\n\t\n\tvar _temp = function () {\n\t    if (typeof __REACT_HOT_LOADER__ === 'undefined') {\n\t        return;\n\t    }\n\t\n\t    __REACT_HOT_LOADER__.register(grayscaleAlgorithms, 'grayscaleAlgorithms', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(color, 'color', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(invertColor, 'invertColor', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(brightness, 'brightness', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(contrast, 'contrast', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(gamma, 'gamma', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(grayscale, 'grayscale', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(canvasFilters, 'canvasFilters', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t\n\t    __REACT_HOT_LOADER__.register(_default, 'default', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-filters.js');\n\t}();\n\n\t;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.CanvasGrid = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _canvasFilters = __webpack_require__(1);\n\t\n\tvar _canvasFilters2 = _interopRequireDefault(_canvasFilters);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// CanvasGrid class\n\tvar CanvasGrid = function () {\n\t    // Class constructor...\n\t    function CanvasGrid(settings) {\n\t        _classCallCheck(this, CanvasGrid);\n\t\n\t        // Init properties\n\t        this.cellSize = 1024;\n\t        this.scaleRatio = { x: 1, y: 1 };\n\t        this.filters = {};\n\t\n\t        Object.assign(this, settings || {});\n\t\n\t        if (!this.scaleRatio.x) {\n\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t        }\n\t\n\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t        this.file = null;\n\t        this.image = null;\n\t        this.url = null;\n\t        this.canvas = [];\n\t        this.pixels = [];\n\t    }\n\t\n\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\n\t\n\t    _createClass(CanvasGrid, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load Image object\n\t            if (input instanceof Image) {\n\t                return this.loadFromImage(input);\n\t            }\n\t\n\t            // Load URL object\n\t            if (typeof input === 'string' || input instanceof URL) {\n\t                return this.loadFromURL(input.trim());\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load image\n\t\n\t    }, {\n\t        key: '_loadImage',\n\t        value: function _loadImage(src, reject, resolve) {\n\t            var _this = this;\n\t\n\t            // Create Image object\n\t            var image = new Image();\n\t\n\t            // Register for load and error events\n\t            image.onload = function (event) {\n\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t            };\n\t\n\t            image.onerror = function (event) {\n\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t            };\n\t\n\t            // Load the image from File url\n\t            image.src = src;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Set input file\n\t                _this2.file = input;\n\t\n\t                // Load image\n\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from URL object or string\n\t\n\t    }, {\n\t        key: 'loadFromURL',\n\t        value: function loadFromURL(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a URL string or object.'));\n\t                }\n\t\n\t                // Create url object\n\t                var url = input instanceof URL ? input : new URL(input);\n\t\n\t                // Set url\n\t                _this3.url = url;\n\t\n\t                // Load image\n\t                _this3._loadImage(url, reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from Image object\n\t\n\t    }, {\n\t        key: 'loadFromImage',\n\t        value: function loadFromImage(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Image)) {\n\t                    reject(new Error('Input param must be a Image object.'));\n\t                }\n\t\n\t                // Set input image\n\t                _this4.image = input;\n\t\n\t                // Process image\n\t                _this4._processImage();\n\t\n\t                // Resolve the promise\n\t                resolve(_this4);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Reset canvas grid\n\t            this.canvas = [];\n\t            this.pixels = [];\n\t\n\t            // Calculate grid size\n\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t            var cols = Math.ceil(width / this.cellSize);\n\t            var rows = Math.ceil(height / this.cellSize);\n\t\n\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\n\t            // Create canvas grid\n\t            var line = null;\n\t            var canvas = null;\n\t            var pixels = null;\n\t            var context = null;\n\t\n\t            var x = null; // cols\n\t            var y = null; // rows\n\t            var sx = null; // scaled cols\n\t            var sy = null; // scaled rows\n\t            var sw = null; // scaled width\n\t            var sh = null; // scaled height\n\t\n\t            // For each line\n\t            for (y = 0; y < this.size.rows; y++) {\n\t                // Reset current line\n\t                line = [];\n\t                pixels = [];\n\t\n\t                // For each column\n\t                for (x = 0; x < this.size.cols; x++) {\n\t                    // Create canvas element\n\t                    canvas = document.createElement('canvas');\n\t\n\t                    // Set canvas size\n\t                    if (x === 0 || x < this.size.cols - 1) {\n\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.width = this.size.width % this.cellSize;\n\t                    }\n\t\n\t                    if (y === 0 || y < this.size.rows - 1) {\n\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.height = this.size.height % this.cellSize;\n\t                    }\n\t\n\t                    // Get canvas 2d context\n\t                    context = canvas.getContext('2d');\n\t\n\t                    // Fill withe background (avoid alpha chanel calculation)\n\t                    context.fillStyle = 'white';\n\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\n\t                    // Draw the part of image in the canvas (scale)\n\t                    sw = canvas.width / this.scaleRatio.x;\n\t                    sh = canvas.height / this.scaleRatio.y;\n\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\n\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\n\t                    // Apply image filters\n\t                    (0, _canvasFilters2.default)(canvas, this.filters);\n\t\n\t                    // Add the canvas to current line\n\t                    line.push(canvas);\n\t\n\t                    // Add the canvas image data to current line\n\t                    pixels.push(context.getImageData(0, 0, canvas.width, canvas.height).data);\n\t                }\n\t\n\t                // Add the line to canvas grid\n\t                this.pixels.push(pixels);\n\t                this.canvas.push(line);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getPixel',\n\t        value: function getPixel(x, y) {\n\t            // Test coords validity\n\t            x = parseInt(x);\n\t            y = parseInt(y);\n\t\n\t            if (isNaN(x) || isNaN(y)) {\n\t                throw new Error('[x, y] params must be Integer.');\n\t            }\n\t\n\t            // Test coords range\n\t            if (x < 0 || x >= this.size.width) {\n\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t            }\n\t\n\t            if (y < 0 || y >= this.size.height) {\n\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t            }\n\t\n\t            // Calculate target canvas coords\n\t            var col = parseInt(x / this.cellSize);\n\t            var row = parseInt(y / this.cellSize);\n\t\n\t            // Adjuste x/y values relative to canvas origin\n\t            col && (x -= this.cellSize * col);\n\t            row && (y -= this.cellSize * row);\n\t\n\t            // Get pixel data\n\t            var cellSize = this.cellSize;\n\t\n\t            if (this.size.width < cellSize) {\n\t                cellSize = this.size.width;\n\t            } else if (this.size.width < cellSize * (col + 1)) {\n\t                cellSize = this.size.width % cellSize;\n\t            }\n\t\n\t            var i = y * (cellSize * 4) + x * 4;\n\t            var pixels = this.pixels[row][col];\n\t            var pixelData = pixels.slice(i, i + 4);\n\t\n\t            return {\n\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t                grid: { col: col, row: row },\n\t                coords: { x: x, y: y }\n\t            };\n\t        }\n\t    }]);\n\t\n\t    return CanvasGrid;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.CanvasGrid = CanvasGrid;\n\tvar _default = CanvasGrid;\n\texports.default = _default;\n\t;\n\t\n\tvar _temp = function () {\n\t    if (typeof __REACT_HOT_LOADER__ === 'undefined') {\n\t        return;\n\t    }\n\t\n\t    __REACT_HOT_LOADER__.register(CanvasGrid, 'CanvasGrid', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-grid.js');\n\t\n\t    __REACT_HOT_LOADER__.register(_default, 'default', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/canvas-grid.js');\n\t}();\n\n\t;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RasterToGcode = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _canvasGrid = __webpack_require__(2);\n\t\n\tvar _canvasGrid2 = _interopRequireDefault(_canvasGrid);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// RasterToGcode class\n\tvar RasterToGcode = function (_CanvasGrid) {\n\t    _inherits(RasterToGcode, _CanvasGrid);\n\t\n\t    // Class constructor...\n\t    function RasterToGcode(settings) {\n\t        _classCallCheck(this, RasterToGcode);\n\t\n\t        // Defaults settings\n\t        settings = Object.assign({\n\t            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\t\n\t            toolDiameter: 0.1, // Tool diameter in millimeters\n\t            rapidRate: 1500, // Rapid rate in mm/min (G0 F value) nullish value to disable\n\t            feedRate: 500, // Feed rate in mm/min (G1 F value)\n\t            rateUnit: 'mm/min', // Rapid/Feed rate unit [mm/min, mm/sec]\n\t\n\t            beamRange: { min: 0, max: 1 }, // Beam power range (Firmware value)\n\t            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\t\n\t            milling: false, // EXPERIMENTAL\n\t            zSafe: 5, // Safe Z for fast move\n\t            zSurface: 0, // Usinable surface (white pixels)\n\t            zDepth: -10, // Z depth (black pixels)\n\t            passDepth: 1, // Pass depth in millimeters\n\t\n\t            offsets: { X: 0, Y: 0 }, // Global coordinates offsets\n\t            trimLine: true, // Trim trailing white pixels\n\t            joinPixel: true, // Join consecutive pixels with same intensity\n\t            burnWhite: true, // [true = G1 S0 | false = G0] on inner white pixels\n\t            verboseG: false, // Output verbose GCode (print each commands)\n\t            diagonal: false, // Go diagonally (increase the distance between points)\n\t            overscan: 0, // Add some extra white space (in millimeters) before and after each line\n\t\n\t            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\t\n\t            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\t\n\t            filters: {\n\t                smoothing: 0, // Smoothing the input image ?\n\t                brightness: 0, // Image brightness [-255 to +255]\n\t                contrast: 0, // Image contrast [-255 to +255]\n\t                gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t                grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t                shadesOfGray: 256, // Number of shades of gray [2-256]\n\t                invertColor: false // Invert color...\n\t            },\n\t\n\t            onProgress: null, // On progress callbacks\n\t            onProgressContext: null, // On progress callback context\n\t\n\t            onDone: null, // On done callback\n\t            onDoneContext: null, // On done callback context\n\t\n\t            onAbort: null, // On abort callback\n\t            onAbortContext: null // On abort callback context\n\t        }, settings || {});\n\t\n\t        // Init properties\n\t\n\t        // Milling settings\n\t        var _this = _possibleConstructorReturn(this, (RasterToGcode.__proto__ || Object.getPrototypeOf(RasterToGcode)).call(this, settings));\n\t\n\t        if (_this.milling) {\n\t            if (_this.zSafe < _this.zSurface) {\n\t                throw new Error('\"zSafe\" must be greater to \"zSurface\"');\n\t            }\n\t\n\t            _this.passes = Math.abs(Math.floor(_this.zDepth / _this.passDepth));\n\t        }\n\t\n\t        // Negative beam size ?\n\t        if (_this.toolDiameter <= 0) {\n\t            throw new Error('\"toolDiameter\" must be positive');\n\t        }\n\t\n\t        // Uniforme ppi\n\t        if (!_this.ppi.x) {\n\t            _this.ppi = { x: _this.ppi, y: _this.ppi };\n\t        }\n\t\n\t        // Calculate PPM = Pixel Per Millimeters\n\t        _this.ppm = {\n\t            x: parseFloat((2540 / (_this.ppi.x * 100)).toFixed(10)),\n\t            y: parseFloat((2540 / (_this.ppi.y * 100)).toFixed(10))\n\t        };\n\t\n\t        // Calculate scale ratio\n\t        _this.scaleRatio = {\n\t            x: _this.ppm.x / _this.toolDiameter,\n\t            y: _this.ppm.y / _this.toolDiameter\n\t        };\n\t\n\t        // State...\n\t        _this.running = false;\n\t        _this.gcode = null;\n\t        _this.gcodes = null;\n\t        _this.currentLine = null;\n\t        _this.lastCommands = null;\n\t\n\t        // Output size in millimeters\n\t        _this.outputSize = { width: 0, height: 0 };\n\t\n\t        // G0 command\n\t        _this.G1 = ['G', 1];\n\t        _this.G0 = ['G', _this.burnWhite ? 1 : 0];\n\t\n\t        // Calculate beam offset\n\t        _this.beamOffset = _this.toolDiameter * 1000 / 2000;\n\t\n\t        // Calculate real beam range\n\t        _this.realBeamRange = {\n\t            min: _this.beamRange.max / 100 * _this.beamPower.min,\n\t            max: _this.beamRange.max / 100 * _this.beamPower.max\n\t        };\n\t\n\t        // Adjuste feed rate to mm/min\n\t        if (_this.rateUnit === 'mm/sec') {\n\t            _this.feedRate *= 60;\n\t\n\t            if (_this.rapidRate) {\n\t                _this.rapidRate *= 60;\n\t            }\n\t        }\n\t\n\t        // Register user callbacks\n\t        _this._registerUserCallbacks(_this);\n\t        return _this;\n\t    }\n\t\n\t    // Register user callbacks\n\t\n\t\n\t    _createClass(RasterToGcode, [{\n\t        key: '_registerUserCallbacks',\n\t        value: function _registerUserCallbacks(callbacks) {\n\t            // Register user callbacks\n\t            callbacks.onProgress && this.on('progress', callbacks.onProgress, callbacks.onProgressContext);\n\t            callbacks.onAbort && this.on('abort', callbacks.onAbort, callbacks.onAbortContext);\n\t            callbacks.onDone && this.on('done', callbacks.onDone, callbacks.onDoneContext);\n\t        }\n\t\n\t        // Process image\n\t\n\t    }, {\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Call parent method\n\t            _get(RasterToGcode.prototype.__proto__ || Object.getPrototypeOf(RasterToGcode.prototype), '_processImage', this).call(this);\n\t\n\t            // Calculate output size\n\t            this.outputSize = {\n\t                width: this.size.width * (this.toolDiameter * 1000) / 1000,\n\t                height: this.size.height * (this.toolDiameter * 1000) / 1000\n\t            };\n\t        }\n\t\n\t        // Abort job\n\t\n\t    }, {\n\t        key: 'abort',\n\t        value: function abort() {\n\t            this.running = false;\n\t        }\n\t\n\t        // Process image and return gcode string\n\t\n\t    }, {\n\t        key: 'run',\n\t        value: function run(settings) {\n\t            if (this.running) {\n\t                return;\n\t            }\n\t\n\t            // Reset state\n\t            this.running = true;\n\t            this.gcode = [];\n\t            this.gcodes = [];\n\t            this.lastCommands = {};\n\t            this.currentLine = null;\n\t\n\t            // Defaults settings\n\t            settings = settings || {};\n\t\n\t            // Register user callbacks\n\t            this._registerUserCallbacks(settings);\n\t\n\t            // Non blocking mode ?\n\t            var nonBlocking = this.nonBlocking;\n\t\n\t            if (settings.nonBlocking !== undefined) {\n\t                nonBlocking = settings.nonBlocking;\n\t            }\n\t\n\t            // Add gcode header\n\t            this._addHeader();\n\t\n\t            // Scan type ?\n\t            if (this.diagonal) {\n\t                this._scanDiagonally(nonBlocking);\n\t            } else {\n\t                this._scanHorizontally(nonBlocking);\n\t            }\n\t\n\t            if (!nonBlocking) {\n\t                return this.gcode;\n\t            }\n\t        }\n\t    }, {\n\t        key: '_addHeader',\n\t        value: function _addHeader() {\n\t            // Base headers\n\t            this.gcode.push('; Generated by LaserWeb (lw.raster-to-gcode.js)', '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm', '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y, '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y, '; Tool diam. : ' + this.toolDiameter + ' mm', '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit);\n\t\n\t            if (this.rapidRate) {\n\t                this.gcode.push('; Rapid rate  : ' + this.rapidRate + ' ' + this.rateUnit);\n\t            }\n\t\n\t            if (this.milling) {\n\t                this.gcode.push('; Z safe     : ' + this.zSafe, '; Z surface  : ' + this.zSurface, '; Z depth    : ' + this.zDepth);\n\t            } else {\n\t                this.gcode.push('; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max, '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %');\n\t            }\n\t\n\t            // Print activated options\n\t            var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];\n\t\n\t            for (var i = options.length - 1; i >= 0; i--) {\n\t                if (!this[options[i]]) {\n\t                    options.splice(i, 1);\n\t                }\n\t            }\n\t\n\t            if (options.length) {\n\t                this.gcode.push('; Options    : ' + options.join(', '));\n\t            }\n\t\n\t            // Set feed rates\n\t            this.gcode.push('');\n\t\n\t            if (this.rapidRate) {\n\t                this.gcode.push('G0 F' + this.rapidRate);\n\t            }\n\t\n\t            this.gcode.push('G1 F' + this.feedRate);\n\t            this.gcode.push('');\n\t        }\n\t\n\t        // Map S value to pixel power\n\t\n\t    }, {\n\t        key: '_mapPixelPower',\n\t        value: function _mapPixelPower(value) {\n\t            var range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange;\n\t            return value * (range.max - range.min) / 255 + range.min;\n\t        }\n\t\n\t        // Compute and return a command, return null if not changed\n\t\n\t    }, {\n\t        key: '_command',\n\t        value: function _command(name, value) {\n\t            // If the value argument is an object\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t                // Computed commands line\n\t                var commands = Array.prototype.slice.call(arguments);\n\t                var command = void 0,\n\t                    line = [];\n\t\n\t                // for each command\n\t                for (var i = 0, il = commands.length; i < il; i++) {\n\t                    command = this._command.apply(this, commands[i]);\n\t                    command && line.push(command);\n\t                }\n\t\n\t                // Return the line if not empty\n\t                return line.length ? line.join(' ') : null;\n\t            }\n\t\n\t            // Format the value\n\t            value = value.toFixed(this.precision[name] || 0);\n\t\n\t            // If the value was changed or if verbose mode on\n\t            if (this.verboseG || value !== this.lastCommands[name]) {\n\t                this.lastCommands[name] = value;\n\t                return name + value;\n\t            }\n\t\n\t            // No change\n\t            return null;\n\t        }\n\t\n\t        // Get a pixel power value from the canvas data grid\n\t\n\t    }, {\n\t        key: '_getPixelPower',\n\t        value: function _getPixelPower(x, y, defaultValue) {\n\t            try {\n\t                // Reverse Y value since canvas as top/left origin\n\t                y = this.size.height - y - 1;\n\t\n\t                // Get pixel info\n\t                var pixel = this.getPixel(x, y);\n\t\n\t                // Reversed gray value [ 0 = white | 255 = black ]\n\t                return 255 - pixel.gray;\n\t            } catch (error) {\n\t                if (arguments.length === 3) {\n\t                    return defaultValue;\n\t                }\n\t                throw error;\n\t            }\n\t        }\n\t\n\t        // Get a point from the current line with real world coordinates\n\t\n\t    }, {\n\t        key: '_getPoint',\n\t        value: function _getPoint(index) {\n\t            // Get the point object from the current line\n\t            var point = this.currentLine[index];\n\t\n\t            // No point\n\t            if (!point) {\n\t                return null;\n\t            }\n\t\n\t            // Commands\n\t            point.G = point.s ? ['G', 1] : this.G0;\n\t            point.X = point.x * this.toolDiameter + this.offsets.X;\n\t            point.Y = point.y * this.toolDiameter + this.offsets.Y;\n\t            point.S = this._mapPixelPower(point.s);\n\t\n\t            // Offsets\n\t            if (this.diagonal) {\n\t                // Vertical offset\n\t                point.Y += this.toolDiameter;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                    point.Y -= this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                    point.Y += this.beamOffset;\n\t                }\n\t            } else {\n\t                // Vertical offset\n\t                point.Y += this.beamOffset;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                }\n\t            }\n\t\n\t            // Return the point\n\t            return point;\n\t        }\n\t\n\t        // Remove all trailing white spaces from the current line\n\t\n\t    }, {\n\t        key: '_trimCurrentLine',\n\t        value: function _trimCurrentLine() {\n\t            // Remove white spaces from the left\n\t            var point = this.currentLine[0];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.shift();\n\t                point = this.currentLine[0];\n\t            }\n\t\n\t            // Remove white spaces from the right\n\t            point = this.currentLine[this.currentLine.length - 2];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.pop();\n\t                point = this.currentLine[this.currentLine.length - 2];\n\t            }\n\t\n\t            // Return the new line length\n\t            return this.currentLine.length;\n\t        }\n\t\n\t        // Join pixel with same power\n\t\n\t    }, {\n\t        key: '_reduceCurrentLine',\n\t        value: function _reduceCurrentLine() {\n\t            // Line too short to be reduced\n\t            if (this.currentLine.length < 3) {\n\t                return this.currentLine.length;\n\t            }\n\t\n\t            // Extract all points exept the first one\n\t            var points = this.currentLine.splice(1);\n\t\n\t            // Get current power\n\t            var power = this.currentLine[0].p;\n\t\n\t            // For each extracted point\n\t            for (var point, i = 0, il = points.length - 1; i < il; i++) {\n\t                // Current point\n\t                point = points[i];\n\t\n\t                // On power change\n\t                if (power !== point.p) {\n\t                    this.currentLine.push(point);\n\t                }\n\t\n\t                // Update power\n\t                power = point.p;\n\t            }\n\t\n\t            // Add last point\n\t            this.currentLine.push(points[i]);\n\t        }\n\t\n\t        // Add extra white pixels at the ends\n\t\n\t    }, {\n\t        key: '_overscanCurrentLine',\n\t        value: function _overscanCurrentLine(reversed) {\n\t            // Number of pixels to add on each side\n\t            var pixels = this.overscan / this.ppm.x;\n\t\n\t            // Get first/last point\n\t            var firstPoint = this.currentLine[0];\n\t            var lastPoint = this.currentLine[this.currentLine.length - 1];\n\t\n\t            // Is last white/colored point ?\n\t            firstPoint.s && (firstPoint.lastWhite = true);\n\t            lastPoint.s && (lastPoint.lastColored = true);\n\t\n\t            // Reversed line ?\n\t            reversed ? lastPoint.s = 0 : firstPoint.s = 0;\n\t\n\t            // Create left/right points\n\t            var rightPoint = { x: lastPoint.x + pixels, y: lastPoint.y, s: 0, p: 0 };\n\t            var leftPoint = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 };\n\t\n\t            if (this.diagonal) {\n\t                leftPoint.y += pixels;\n\t                rightPoint.y -= pixels;\n\t            }\n\t\n\t            // Add left/right points to current line\n\t            this.currentLine.unshift(leftPoint);\n\t            this.currentLine.push(rightPoint);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processCurrentLine',\n\t        value: function _processCurrentLine(reversed) {\n\t            if (this.milling) {\n\t                return this._processMillingLine(reversed);\n\t            }\n\t\n\t            return this._processLaserLine(reversed);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processMillingLine',\n\t        value: function _processMillingLine(reversed) {\n\t            var _this2 = this;\n\t\n\t            // Skip empty line\n\t            if (!this._trimCurrentLine()) {\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            var addCommand = function addCommand() {\n\t                command = _this2._command.apply(_this2, arguments);\n\t                command && gcode.push(command);\n\t            };\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            var plung = false;\n\t            var Z = void 0,\n\t                zMax = void 0;\n\t\n\t            var pass = function pass(passNum) {\n\t                // Move to start of the line\n\t                addCommand(['G', 0], ['Z', _this2.zSafe]);\n\t                addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\n\t                addCommand(['G', 0], ['Z', _this2.zSurface]);\n\t\n\t                // For each point on the line\n\t                while (point) {\n\t                    if (point.S) {\n\t                        if (plung) {\n\t                            addCommand(['G', 0], ['Z', _this2.zSurface]);\n\t                            plung = false;\n\t                        }\n\t\n\t                        Z = point.S;\n\t                        zMax = _this2.passDepth * passNum;\n\t\n\t                        // Last pass\n\t                        if (passNum < _this2.passes) {\n\t                            Z = Math.max(Z, -zMax);\n\t                        }\n\t\n\t                        addCommand(['G', 1], ['Z', _this2.zSurface + Z]);\n\t                        addCommand(['G', 1], ['X', point.X], ['Y', point.Y]);\n\t                    } else {\n\t                        if (plung) {\n\t                            addCommand(['G', 1], ['Z', _this2.zSurface]);\n\t                            plung = false;\n\t                        }\n\t\n\t                        addCommand(['G', 0], ['Z', _this2.zSafe]);\n\t                        addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\n\t                    }\n\t\n\t                    if (point.lastWhite || point.lastColored) {\n\t                        plung = true;\n\t                    }\n\t\n\t                    // Get next point\n\t                    point = _this2._getPoint(++index);\n\t                }\n\t\n\t                // Move to Z safe\n\t                addCommand(['G', 1], ['Z', _this2.zSurface]);\n\t                addCommand(['G', 0], ['Z', _this2.zSafe]);\n\t            };\n\t\n\t            for (var i = 1; i <= this.passes; i++) {\n\t                pass(i);\n\t\n\t                if (!gcode.length) {\n\t                    break;\n\t                }\n\t\n\t                if (this.gcodes.length < i) {\n\t                    this.gcodes.push([]);\n\t                } else {\n\t                    this.gcodes[i - 1].push.apply(this.gcodes[i - 1], gcode);\n\t                }\n\t\n\t                index = 0;\n\t                gcode = [];\n\t                point = this._getPoint(index);\n\t\n\t                this.lastCommands = {};\n\t            }\n\t\n\t            // Not sure what to return...\n\t            return null;\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processLaserLine',\n\t        value: function _processLaserLine(reversed) {\n\t            var _this3 = this;\n\t\n\t            // Trim trailing white spaces ?\n\t            if (this.trimLine && !this._trimCurrentLine()) {\n\t                // Skip empty line\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Overscan ?\n\t            if (this.overscan) {\n\t                this._overscanCurrentLine(reversed);\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            var addCommand = function addCommand() {\n\t                command = _this3._command.apply(_this3, arguments);\n\t                command && gcode.push(command);\n\t            };\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            // Move to start of the line\n\t            addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);\n\t\n\t            // Get next point\n\t            point = this._getPoint(++index);\n\t\n\t            // For each point on the line\n\t            while (point) {\n\t                // Burn to next point\n\t                addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);\n\t\n\t                // Get next point\n\t                point = this._getPoint(++index);\n\t            }\n\t\n\t            // Return gcode commands array\n\t            if (gcode.length) {\n\t                return gcode;\n\t            }\n\t\n\t            // Empty line\n\t            return null;\n\t        }\n\t\n\t        // Parse horizontally\n\t\n\t    }, {\n\t        key: '_scanHorizontally',\n\t        value: function _scanHorizontally(nonBlocking) {\n\t            var _this4 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                _this4.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x <= w; x++) {\n\t                    // Get pixel power\n\t                    s = p = _this4._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add point to current line\n\t                    _this4.currentLine.push(point);\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this4._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    _this4._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this4.gcode.push.apply(_this4.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                // Aborted ?\n\t                if (!_this4.running) {\n\t                    return _this4._onAbort();\n\t                }\n\t\n\t                // Process line...\n\t                computeCurrentLine();\n\t                processCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    if (_this4.milling) {\n\t                        _this4.gcodes.forEach(function (gcode) {\n\t                            _this4.gcode.push.apply(_this4.gcode, gcode);\n\t                        });\n\t                    }\n\t\n\t                    _this4._onDone({ gcode: _this4.gcode });\n\t                    _this4.running = false;\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t        }\n\t\n\t        // Parse diagonally\n\t\n\t    }, {\n\t        key: '_scanDiagonally',\n\t        value: function _scanDiagonally(nonBlocking) {\n\t            var _this5 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var totalLines = w + h - 1;\n\t            var lineNum = 0;\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine(x, y) {\n\t                // Reset current line\n\t                _this5.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // Increment line num\n\t                lineNum++;\n\t\n\t                while (true) {\n\t                    // Y limit reached !\n\t                    if (y < -1 || y == h) {\n\t                        break;\n\t                    }\n\t\n\t                    // X limit reached !\n\t                    if (x < 0 || x > w) {\n\t                        break;\n\t                    }\n\t\n\t                    // Get pixel power\n\t                    s = p = _this5._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add the new point\n\t                    _this5.currentLine.push(point);\n\t\n\t                    // Next coords\n\t                    x++;\n\t                    y--;\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this5._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(lineNum / totalLines * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    _this5._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this5.gcode.push.apply(_this5.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                // Aborted ?\n\t                if (!_this5.running) {\n\t                    return _this5._onAbort();\n\t                }\n\t\n\t                // Process line...\n\t                computeCurrentLine(x, y);\n\t                processCurrentLine();\n\t\n\t                if (!x) y++;else x++;\n\t\n\t                if (y === h) {\n\t                    x++;\n\t                    y--;\n\t                }\n\t\n\t                if (y < h && x < w) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this5._onDone({ gcode: _this5.gcode });\n\t                    _this5.running = false;\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t        }\n\t    }, {\n\t        key: '_onProgress',\n\t        value: function _onProgress(event) {\n\t            //console.log('progress:', event.percent)\n\t        }\n\t    }, {\n\t        key: '_onDone',\n\t        value: function _onDone(event) {\n\t            //console.log('done:', event.gcode.length)\n\t        }\n\t    }, {\n\t        key: '_onAbort',\n\t        value: function _onAbort() {\n\t            //console.log('abort')\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback, context) {\n\t            var _this6 = this;\n\t\n\t            var method = '_on' + event[0].toUpperCase() + event.slice(1);\n\t\n\t            if (!this[method] || typeof this[method] !== 'function') {\n\t                throw new Error('Undefined event: ' + event);\n\t            }\n\t\n\t            this[method] = function (event) {\n\t                return callback.call(context || _this6, event);\n\t            };\n\t\n\t            return this;\n\t        }\n\t\n\t        // Return the bitmap height-map\n\t\n\t    }, {\n\t        key: 'getHeightMap',\n\t        value: function getHeightMap(settings) {\n\t            var _this7 = this;\n\t\n\t            if (this.running) {\n\t                return;\n\t            }\n\t\n\t            // Init loop vars\n\t            this.running = true;\n\t            var heightMap = [];\n\t\n\t            var x = 0;\n\t            var y = 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            // Defaults settings\n\t            settings = settings || {};\n\t\n\t            // Register user callbacks\n\t            this._registerUserCallbacks(settings);\n\t\n\t            // Non blocking mode ?\n\t            var nonBlocking = this.nonBlocking;\n\t\n\t            if (settings.nonBlocking !== undefined) {\n\t                nonBlocking = settings.nonBlocking;\n\t            }\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                var pixels = [];\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x < w; x++) {\n\t                    pixels.push(_this7._mapPixelPower(_this7._getPixelPower(x, y)));\n\t                }\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    //onProgress.call(settings.progressContext || this, { pixels, percent })\n\t                    _this7._onProgress({ pixels: pixels, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Add pixels line\n\t                heightMap.push(pixels);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                // Aborted ?\n\t                if (!_this7.running) {\n\t                    return _this7._onAbort();\n\t                }\n\t\n\t                // Process line...\n\t                computeCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    //onDone.call(settings.doneContext || this, { heightMap })\n\t                    _this7._onDone({ heightMap: heightMap });\n\t                    _this7.running = false;\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            if (!nonBlocking) {\n\t                return heightMap;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return RasterToGcode;\n\t}(_canvasGrid2.default);\n\t\n\t// Exports\n\t\n\t\n\texports.RasterToGcode = RasterToGcode;\n\tvar _default = RasterToGcode;\n\texports.default = _default;\n\t;\n\t\n\tvar _temp = function () {\n\t    if (typeof __REACT_HOT_LOADER__ === 'undefined') {\n\t        return;\n\t    }\n\t\n\t    __REACT_HOT_LOADER__.register(RasterToGcode, 'RasterToGcode', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/raster-to-gcode.js');\n\t\n\t    __REACT_HOT_LOADER__.register(_default, 'default', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/lw.raster2gcode/raster-to-gcode.js');\n\t}();\n\n\t;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * floyd-steinberg\n\t *\n\t * Using 2D error diffusion formula published by Robert Floyd and Louis Steinberg in 1976\n\t *\n\t * Javascript implementation of Floyd-Steinberg algorithm thanks to Forrest Oliphant @forresto and @meemoo \n\t * via iFramework https://github.com/meemoo/iframework/blob/master/src/nodes/image-monochrome-worker.js\n\t *\n\t * Accepts an object that complies with the HTML5 canvas imageData spec https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n\t * In particular, it makes use of the width, height, and data properties\n\t *\n\t * License: MIT\n\t*/\n\t\n\tmodule.exports = floyd_steinberg;\n\t\n\tfunction floyd_steinberg(image) {\n\t  var imageData = image.data;\n\t  var imageDataLength = imageData.length;\n\t  var w = image.width;\n\t  var lumR = [],\n\t      lumG = [],\n\t      lumB = [];\n\t\n\t  var newPixel, err;\n\t\n\t  for (var i = 0; i < 256; i++) {\n\t    lumR[i] = i * 0.299;\n\t    lumG[i] = i * 0.587;\n\t    lumB[i] = i * 0.110;\n\t  }\n\t\n\t  // Greyscale luminance (sets r pixels to luminance of rgb)\n\t  for (var i = 0; i <= imageDataLength; i += 4) {\n\t    imageData[i] = Math.floor(lumR[imageData[i]] + lumG[imageData[i+1]] + lumB[imageData[i+2]]);\n\t  }\n\t\n\t  for (var currentPixel = 0; currentPixel <= imageDataLength; currentPixel += 4) {\n\t    // threshold for determining current pixel's conversion to a black or white pixel\n\t    newPixel = imageData[currentPixel] < 150 ? 0 : 255;\n\t    err = Math.floor((imageData[currentPixel] - newPixel) / 23);\n\t    imageData[currentPixel] = newPixel;\n\t    imageData[currentPixel + 4         ] += err * 7;\n\t    imageData[currentPixel + 4 * w - 4 ] += err * 3;\n\t    imageData[currentPixel + 4 * w     ] += err * 5;\n\t    imageData[currentPixel + 4 * w + 4 ] += err * 1;\n\t    // Set g and b pixels equal to r (effectively greyscales the image fully)\n\t    imageData[currentPixel + 1] = imageData[currentPixel + 2] = imageData[currentPixel];\n\t  }\n\t\n\t  return image;\n\t}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ec6ef5e051fb1735e264.worker.js"," \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n \tvar canDefineProperty = false;\r\n \ttry {\r\n \t\tObject.defineProperty({}, \"x\", {\r\n \t\t\tget: function() {}\r\n \t\t});\r\n \t\tcanDefineProperty = true;\r\n \t} catch(x) {\r\n \t\t// IE will fail on defineProperty\r\n \t}\r\n \t\r\n \tvar hotApplyOnUpdate = true;\r\n \tvar hotCurrentHash = \"ec6ef5e051fb1735e264\"; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentModuleData = {};\r\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n \t\r\n \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar me = installedModules[moduleId];\r\n \t\tif(!me) return __webpack_require__;\r\n \t\tvar fn = function(request) {\r\n \t\t\tif(me.hot.active) {\r\n \t\t\t\tif(installedModules[request]) {\r\n \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n \t\t\t\t\t\tme.children.push(request);\r\n \t\t\t\t} else hotCurrentParents = [moduleId];\r\n \t\t\t} else {\r\n \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n \t\t\t\thotCurrentParents = [];\r\n \t\t\t}\r\n \t\t\treturn __webpack_require__(request);\r\n \t\t};\r\n \t\tfor(var name in __webpack_require__) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n \t\t\t\tif(canDefineProperty) {\r\n \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n \t\t\t\t\t\treturn {\r\n \t\t\t\t\t\t\tconfigurable: true,\r\n \t\t\t\t\t\t\tenumerable: true,\r\n \t\t\t\t\t\t\tget: function() {\r\n \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n \t\t\t\t\t\t\t},\r\n \t\t\t\t\t\t\tset: function(value) {\r\n \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t};\r\n \t\t\t\t\t}(name)));\r\n \t\t\t\t} else {\r\n \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\tfunction ensure(chunkId, callback) {\r\n \t\t\tif(hotStatus === \"ready\")\r\n \t\t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotChunksLoading++;\r\n \t\t\t__webpack_require__.e(chunkId, function() {\r\n \t\t\t\ttry {\r\n \t\t\t\t\tcallback.call(null, fn);\r\n \t\t\t\t} finally {\r\n \t\t\t\t\tfinishChunkLoading();\r\n \t\t\t\t}\r\n \t\r\n \t\t\t\tfunction finishChunkLoading() {\r\n \t\t\t\t\thotChunksLoading--;\r\n \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\t\t\t\thotUpdateDownloaded();\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t});\r\n \t\t}\r\n \t\tif(canDefineProperty) {\r\n \t\t\tObject.defineProperty(fn, \"e\", {\r\n \t\t\t\tenumerable: true,\r\n \t\t\t\tvalue: ensure\r\n \t\t\t});\r\n \t\t} else {\r\n \t\t\tfn.e = ensure;\r\n \t\t}\r\n \t\treturn fn;\r\n \t}\r\n \t\r\n \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar hot = {\r\n \t\t\t// private stuff\r\n \t\t\t_acceptedDependencies: {},\r\n \t\t\t_declinedDependencies: {},\r\n \t\t\t_selfAccepted: false,\r\n \t\t\t_selfDeclined: false,\r\n \t\t\t_disposeHandlers: [],\r\n \t\r\n \t\t\t// Module API\r\n \t\t\tactive: true,\r\n \t\t\taccept: function(dep, callback) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfAccepted = true;\r\n \t\t\t\telse if(typeof dep === \"function\")\r\n \t\t\t\t\thot._selfAccepted = dep;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n \t\t\t\telse\r\n \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n \t\t\t},\r\n \t\t\tdecline: function(dep) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfDeclined = true;\r\n \t\t\t\telse if(typeof dep === \"number\")\r\n \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n \t\t\t\telse\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n \t\t\t},\r\n \t\t\tdispose: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\taddDisposeHandler: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\tremoveDisposeHandler: function(callback) {\r\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t// Management API\r\n \t\t\tcheck: hotCheck,\r\n \t\t\tapply: hotApply,\r\n \t\t\tstatus: function(l) {\r\n \t\t\t\tif(!l) return hotStatus;\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\taddStatusHandler: function(l) {\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\tremoveStatusHandler: function(l) {\r\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t//inherit from previous dispose call\r\n \t\t\tdata: hotCurrentModuleData[moduleId]\r\n \t\t};\r\n \t\treturn hot;\r\n \t}\r\n \t\r\n \tvar hotStatusHandlers = [];\r\n \tvar hotStatus = \"idle\";\r\n \t\r\n \tfunction hotSetStatus(newStatus) {\r\n \t\thotStatus = newStatus;\r\n \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n \t}\r\n \t\r\n \t// while downloading\r\n \tvar hotWaitingFiles = 0;\r\n \tvar hotChunksLoading = 0;\r\n \tvar hotWaitingFilesMap = {};\r\n \tvar hotRequestedFilesMap = {};\r\n \tvar hotAvailibleFilesMap = {};\r\n \tvar hotCallback;\r\n \t\r\n \t// The update info\r\n \tvar hotUpdate, hotUpdateNewHash;\r\n \t\r\n \tfunction toModuleId(id) {\r\n \t\tvar isNumber = (+id) + \"\" === id;\r\n \t\treturn isNumber ? +id : id;\r\n \t}\r\n \t\r\n \tfunction hotCheck(apply, callback) {\r\n \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n \t\tif(typeof apply === \"function\") {\r\n \t\t\thotApplyOnUpdate = false;\r\n \t\t\tcallback = apply;\r\n \t\t} else {\r\n \t\t\thotApplyOnUpdate = apply;\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\thotSetStatus(\"check\");\r\n \t\thotDownloadManifest(function(err, update) {\r\n \t\t\tif(err) return callback(err);\r\n \t\t\tif(!update) {\r\n \t\t\t\thotSetStatus(\"idle\");\r\n \t\t\t\tcallback(null, null);\r\n \t\t\t\treturn;\r\n \t\t\t}\r\n \t\r\n \t\t\thotRequestedFilesMap = {};\r\n \t\t\thotAvailibleFilesMap = {};\r\n \t\t\thotWaitingFilesMap = {};\r\n \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n \t\t\thotUpdateNewHash = update.h;\r\n \t\r\n \t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotCallback = callback;\r\n \t\t\thotUpdate = {};\r\n \t\t\tvar chunkId = 0;\r\n \t\t\t{ // eslint-disable-line no-lone-blocks\r\n \t\t\t\t/*globals chunkId */\r\n \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t}\r\n \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\thotUpdateDownloaded();\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n \t\t\treturn;\r\n \t\thotRequestedFilesMap[chunkId] = false;\r\n \t\tfor(var moduleId in moreModules) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n \t\t\thotUpdateDownloaded();\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotEnsureUpdateChunk(chunkId) {\r\n \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n \t\t\thotWaitingFilesMap[chunkId] = true;\r\n \t\t} else {\r\n \t\t\thotRequestedFilesMap[chunkId] = true;\r\n \t\t\thotWaitingFiles++;\r\n \t\t\thotDownloadUpdateChunk(chunkId);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotUpdateDownloaded() {\r\n \t\thotSetStatus(\"ready\");\r\n \t\tvar callback = hotCallback;\r\n \t\thotCallback = null;\r\n \t\tif(!callback) return;\r\n \t\tif(hotApplyOnUpdate) {\r\n \t\t\thotApply(hotApplyOnUpdate, callback);\r\n \t\t} else {\r\n \t\t\tvar outdatedModules = [];\r\n \t\t\tfor(var id in hotUpdate) {\r\n \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tcallback(null, outdatedModules);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotApply(options, callback) {\r\n \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n \t\tif(typeof options === \"function\") {\r\n \t\t\tcallback = options;\r\n \t\t\toptions = {};\r\n \t\t} else if(options && typeof options === \"object\") {\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t} else {\r\n \t\t\toptions = {};\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\r\n \t\tfunction getAffectedStuff(module) {\r\n \t\t\tvar outdatedModules = [module];\r\n \t\t\tvar outdatedDependencies = {};\r\n \t\r\n \t\t\tvar queue = outdatedModules.slice();\r\n \t\t\twhile(queue.length > 0) {\r\n \t\t\t\tvar moduleId = queue.pop();\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tif(!module || module.hot._selfAccepted)\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tif(module.hot._selfDeclined) {\r\n \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n \t\t\t\t}\r\n \t\t\t\tif(moduleId === 0) {\r\n \t\t\t\t\treturn;\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n \t\t\t\t\tvar parentId = module.parents[i];\r\n \t\t\t\t\tvar parent = installedModules[parentId];\r\n \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n \t\t\t\t\toutdatedModules.push(parentId);\r\n \t\t\t\t\tqueue.push(parentId);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\r\n \t\t\treturn [outdatedModules, outdatedDependencies];\r\n \t\t}\r\n \t\r\n \t\tfunction addAllToSet(a, b) {\r\n \t\t\tfor(var i = 0; i < b.length; i++) {\r\n \t\t\t\tvar item = b[i];\r\n \t\t\t\tif(a.indexOf(item) < 0)\r\n \t\t\t\t\ta.push(item);\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// at begin all updates modules are outdated\r\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n \t\tvar outdatedDependencies = {};\r\n \t\tvar outdatedModules = [];\r\n \t\tvar appliedUpdate = {};\r\n \t\tfor(var id in hotUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\tvar moduleId = toModuleId(id);\r\n \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n \t\t\t\tif(!result) {\r\n \t\t\t\t\tif(options.ignoreUnaccepted)\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n \t\t\t\t}\r\n \t\t\t\tif(result instanceof Error) {\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(result);\r\n \t\t\t\t}\r\n \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n \t\t\t\tfor(var moduleId in result[1]) {\r\n \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Store self accepted outdated modules to require them later by the module system\r\n \t\tvar outdatedSelfAcceptedModules = [];\r\n \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n \t\t\tvar moduleId = outdatedModules[i];\r\n \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n \t\t\t\toutdatedSelfAcceptedModules.push({\r\n \t\t\t\t\tmodule: moduleId,\r\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n \t\t\t\t});\r\n \t\t}\r\n \t\r\n \t\t// Now in \"dispose\" phase\r\n \t\thotSetStatus(\"dispose\");\r\n \t\tvar queue = outdatedModules.slice();\r\n \t\twhile(queue.length > 0) {\r\n \t\t\tvar moduleId = queue.pop();\r\n \t\t\tvar module = installedModules[moduleId];\r\n \t\t\tif(!module) continue;\r\n \t\r\n \t\t\tvar data = {};\r\n \t\r\n \t\t\t// Call dispose handlers\r\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n \t\t\t\tvar cb = disposeHandlers[j];\r\n \t\t\t\tcb(data);\r\n \t\t\t}\r\n \t\t\thotCurrentModuleData[moduleId] = data;\r\n \t\r\n \t\t\t// disable module (this disables requires from this module)\r\n \t\t\tmodule.hot.active = false;\r\n \t\r\n \t\t\t// remove module from cache\r\n \t\t\tdelete installedModules[moduleId];\r\n \t\r\n \t\t\t// remove \"parents\" references from all children\r\n \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n \t\t\t\tvar child = installedModules[module.children[j]];\r\n \t\t\t\tif(!child) continue;\r\n \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n \t\t\t\tif(idx >= 0) {\r\n \t\t\t\t\tchild.parents.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// remove outdated dependency from module children\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Not in \"apply\" phase\r\n \t\thotSetStatus(\"apply\");\r\n \t\r\n \t\thotCurrentHash = hotUpdateNewHash;\r\n \t\r\n \t\t// insert new code\r\n \t\tfor(var moduleId in appliedUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// call accept handlers\r\n \t\tvar error = null;\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tvar callbacks = [];\r\n \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n \t\t\t\t\tcallbacks.push(cb);\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n \t\t\t\t\tvar cb = callbacks[i];\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tcb(outdatedDependencies);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Load self accepted modules\r\n \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n \t\t\tvar moduleId = item.module;\r\n \t\t\thotCurrentParents = [moduleId];\r\n \t\t\ttry {\r\n \t\t\t\t__webpack_require__(moduleId);\r\n \t\t\t} catch(err) {\r\n \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\titem.errorHandler(err);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t} else if(!error)\r\n \t\t\t\t\terror = err;\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// handle errors in accept handlers and self accepted module load\r\n \t\tif(error) {\r\n \t\t\thotSetStatus(\"fail\");\r\n \t\t\treturn callback(error);\r\n \t\t}\r\n \t\r\n \t\thotSetStatus(\"idle\");\r\n \t\tcallback(null, outdatedModules);\r\n \t}\r\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false,\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: hotCurrentParents,\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ec6ef5e051fb1735e264","import { RasterToGcode } from '../lw.raster2gcode/raster-to-gcode.js'\n\n// On messsage received\nself.onmessage = function (event) {\n    if (event.data.cmd === 'start') {\n        start(event.data);\n    }\n}\n\n\n\n// Start job\nfunction start(data) {\n\n    // Create RasterToGcode object\n    var rasterToGcode = new RasterToGcode(data.settings);\n        Object.assign( rasterToGcode, data.properties );\n    // Register events callbacks\n        rasterToGcode.on('progress', function (event) {\n            self.postMessage({ event: 'onProgress', ...event });\n        }).on('done', function (event) {\n            self.postMessage({ event: 'onDone', ...event });\n        }).on('abort', function () {\n            self.postMessage({ event: 'onAbort' });\n        });\n\n    \n    self.postMessage({ event: 'start' });\n    rasterToGcode.run();\n\n}\n\n// Abort job\nfunction abort() {\n    rasterToGcode.abort();\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/workers/cam-raster.js","import FloydSteinberg from 'floyd-steinberg'\n\n// Grayscale algorithms\nconst grayscaleAlgorithms = [\n    'none',\n    'average',\n    'desaturation',\n    'decomposition-min', 'decomposition-max',\n    'luma', 'luma-601', 'luma-709', 'luma-240',\n    'red-chanel', 'green-chanel', 'blue-chanel'\n]\n\n// Trucate color value in the 0-255 range\nfunction color(color) {\n    return color < 0 ? 0 : (color > 255 ? 255 : color);\n}\n\n// Filters ...\nfunction invertColor(data, i, value) {\n    if (value) {\n        data[i]     = color(255 - data[i])\n        data[i + 1] = color(255 - data[i + 1])\n        data[i + 2] = color(255 - data[i + 2])\n    }\n}\n\nfunction brightness(data, i, value) {\n    if (value !== undefined) {\n        data[i]     = color(data[i]     + value)\n        data[i + 1] = color(data[i + 1] + value)\n        data[i + 2] = color(data[i + 2] + value)\n    }\n}\n\nfunction contrast(data, i, value) {\n    if (value !== undefined) {\n        data[i]     = color(value * (data[i]     - 128) + 128)\n        data[i + 1] = color(value * (data[i + 1] - 128) + 128)\n        data[i + 2] = color(value * (data[i + 2] - 128) + 128)\n    }\n}\n\nfunction gamma(data, i, value) {\n    if (value !== undefined) {\n        data[i]     = color(Math.exp(Math.log(255 * (data[i]     / 255)) * value))\n        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value))\n        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value))\n    }\n}\n\nfunction grayscale(data, i, algorithm, shades) {\n    // Graysale\n    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\n    // Unsupported algorithm\n    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n        throw new Error('Unsupported grayscale algorithm: ' + algorithm)\n    }\n\n    // None\n    if (algorithm === 'none') {\n        return null\n    }\n\n    // Get Red/Green/Blue values\n    let gray\n    let r = data[i];\n    let g = data[i + 1];\n    let b = data[i + 2];\n\n    switch (algorithm) {\n        case 'average':\n            gray = (r + g + b) / 3\n            break\n\n        case 'luma': // Default\n            gray = (r * 0.3) + (g * 0.59) + (b * 0.11)\n            break\n\n        case 'luma-601': // CCIR-601\n            gray = (r * 0.299) + (g * 0.587) + (b * 0.114)\n            break\n\n        case 'luma-709': // ITU-R-709\n            gray = (r * 0.2126) + (g * 0.7152) + (b * 0.0722)\n            break\n\n        case 'luma-240': // SMPTE-240M\n            gray = (r * 0.212) + (g * 0.701) + (b * 0.087)\n            break\n\n        case 'desaturation':\n            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2\n            break\n\n        case 'decomposition-min':\n            gray = Math.min(r, g, b)\n            break\n\n        case 'decomposition-max':\n            gray = Math.max(r, g, b)\n            break\n\n        case 'red-chanel':\n            gray = r\n            break\n\n        case 'green-chanel':\n            gray = g\n            break\n\n        case 'blue-chanel':\n            gray = b\n            break\n    }\n\n    // Shades of gray\n    if (shades !== undefined) {\n        gray = parseInt(gray / shades) * shades\n    }\n\n    // Force integer\n    gray = parseInt(gray)\n\n    // Set new r/g/b values\n    data[i]     = color(gray)\n    data[i + 1] = color(gray)\n    data[i + 2] = color(gray)\n}\n\n// Apply filters on provided canvas\nfunction canvasFilters(canvas, settings) {\n    settings = Object.assign({}, {\n        smoothing   : false,  // Smoothing [true|fale]\n        brightness  : 0,      // Image brightness [-255 to +255]\n        contrast    : 0,      // Image contrast [-255 to +255]\n        gamma       : 0,      // Image gamma correction [0.01 to 7.99]\n        grayscale   : 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n        shadesOfGray: 256,    // Number of shades of gray [2-256]\n        invertColor : false,   // Invert color...\n        dithering   : false\n    }, settings || {})\n\n    // Get canvas 2d context\n    let context = canvas.getContext('2d')\n\n    // Smoothing\n    if (context.imageSmoothingEnabled !== undefined) {\n        context.imageSmoothingEnabled = settings.smoothing\n    }\n    else {\n        context.mozImageSmoothingEnabled    = settings.smoothing\n        context.webkitImageSmoothingEnabled = settings.smoothing\n        context.msImageSmoothingEnabled     = settings.smoothing\n        context.oImageSmoothingEnabled      = settings.smoothing\n    }\n\n    // Get image data\n    let imageData = context.getImageData(0, 0, canvas.width, canvas.height)\n    let data      = imageData.data\n\n    let contrastFactor, brightnessOffset, gammaCorrection, shadesOfGrayFactor\n\n    if (settings.contrast !== 0) {\n        contrastFactor = (259 * (settings.contrast + 255)) / (255 * (259 - settings.contrast))\n    }\n\n    if (settings.brightness !== 0) {\n        brightnessOffset = settings.brightness\n    }\n\n    if (settings.gamma !== 0) {\n        gammaCorrection = 1 / settings.gamma\n    }\n\n    // Shades of gray\n    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1)\n    }\n\n    // For each pixel\n    for (let i = 0, il = data.length; i < il; i += 4) {\n        // Apply filters\n        invertColor(data, i, settings.invertColor)\n        brightness(data, i, brightnessOffset)\n        contrast(data, i, contrastFactor)\n        gamma(data, i, gammaCorrection)\n        grayscale(data, i, settings.grayscale, shadesOfGrayFactor)\n    }\n\n    if (settings.dithering) {\n        imageData = FloydSteinberg(imageData)\n    }\n\n    // Write new image data on the context\n    context.putImageData(imageData, 0, 0)\n}\n\n// Exports\nexport { canvasFilters }\nexport default canvasFilters\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lw.raster2gcode/canvas-filters.js","import canvasFilters from './canvas-filters'\n\n// CanvasGrid class\nclass CanvasGrid {\n    // Class constructor...\n    constructor(settings) {\n        // Init properties\n        this.cellSize   = 1024\n        this.scaleRatio = { x: 1, y: 1 }\n        this.filters    = {}\n\n        Object.assign(this, settings || {})\n\n        if (! this.scaleRatio.x) {\n            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio }\n        }\n\n        this.size   = { width: 0, height: 0, cols: 0, rows: 0 }\n        this.file   = null\n        this.image  = null\n        this.url    = null\n        this.canvas = []\n        this.pixels = []\n    }\n\n    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n    load(input) {\n        // Load File object\n        if (input instanceof File) {\n            return this.loadFromFile(input)\n        }\n\n        // Load Image object\n        if (input instanceof Image) {\n            return this.loadFromImage(input)\n        }\n\n        // Load URL object\n        if (typeof input === 'string' || input instanceof URL) {\n            return this.loadFromURL(input.trim())\n        }\n\n        // Return rejected promise with an Error object\n        return Promise.reject(new Error('Unsupported input format.'))\n    }\n\n    // Load image\n    _loadImage(src, reject, resolve) {\n        // Create Image object\n        let image = new Image()\n\n        // Register for load and error events\n        image.onload = event => {\n            this.loadFromImage(image).then(resolve).catch(reject)\n        }\n\n        image.onerror = event => {\n            reject(new Error('An error occurred while loading the image : ' + src))\n        }\n\n        // Load the image from File url\n        image.src = src\n    }\n\n    // Load from File object\n    loadFromFile(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof File)) {\n                reject(new Error('Input param must be a File object.'))\n            }\n\n            // Set input file\n            this.file = input\n\n            // Load image\n            this._loadImage(URL.createObjectURL(input), reject, resolve)\n        })\n    }\n\n    // Load from URL object or string\n    loadFromURL(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof URL) && typeof input !== 'string') {\n                reject(new Error('Input param must be a URL string or object.'))\n            }\n\n            // Create url object\n            let url = input instanceof URL ? input : new URL(input)\n\n            // Set url\n            this.url = url\n\n            // Load image\n            this._loadImage(url, reject, resolve)\n        })\n    }\n\n    // Load from Image object\n    loadFromImage(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof Image)) {\n                reject(new Error('Input param must be a Image object.'))\n            }\n\n            // Set input image\n            this.image = input\n\n            // Process image\n            this._processImage()\n\n            // Resolve the promise\n            resolve(this)\n        })\n    }\n\n    _processImage() {\n        // Reset canvas grid\n        this.canvas = []\n        this.pixels = []\n\n        // Calculate grid size\n        let width  = Math.round(this.image.width * this.scaleRatio.x)\n        let height = Math.round(this.image.height * this.scaleRatio.y)\n        let cols   = Math.ceil(width / this.cellSize)\n        let rows   = Math.ceil(height / this.cellSize)\n\n        this.size = { width, height, cols, rows }\n\n        // Create canvas grid\n        let line    = null\n        let canvas  = null\n        let pixels  = null\n        let context = null\n\n        let x  = null // cols\n        let y  = null // rows\n        let sx = null // scaled cols\n        let sy = null // scaled rows\n        let sw = null // scaled width\n        let sh = null // scaled height\n\n        // For each line\n        for (y = 0; y < this.size.rows; y++) {\n            // Reset current line\n            line   = []\n            pixels = []\n\n            // For each column\n            for (x = 0; x < this.size.cols; x++) {\n                // Create canvas element\n                canvas = document.createElement('canvas')\n\n                // Set canvas size\n                if (x === 0 || x < (this.size.cols - 1)) {\n                    canvas.width = this.size.width < this.cellSize\n                                 ? this.size.width : this.cellSize\n                }\n                else {\n                    // Get the rest for the last item (except the first one)\n                    canvas.width = this.size.width % this.cellSize\n                }\n\n                if (y === 0 || y < (this.size.rows - 1)) {\n                    canvas.height = this.size.height < this.cellSize\n                                  ? this.size.height : this.cellSize\n                }\n                else {\n                    // Get the rest for the last item (except the first one)\n                    canvas.height = this.size.height % this.cellSize\n                }\n\n                // Get canvas 2d context\n                context = canvas.getContext('2d')\n\n                // Fill withe background (avoid alpha chanel calculation)\n                context.fillStyle = 'white'\n                context.fillRect(0, 0, canvas.width, canvas.height)\n\n                // Draw the part of image in the canvas (scale)\n                sw = canvas.width / this.scaleRatio.x\n                sh = canvas.height / this.scaleRatio.y\n                sx = x * this.cellSize / this.scaleRatio.x\n                sy = y * this.cellSize / this.scaleRatio.y\n\n                context.drawImage(\n                    this.image, sx, sy, sw, sh,\n                    0, 0, canvas.width, canvas.height\n                )\n\n                // Apply image filters\n                canvasFilters(canvas, this.filters)\n\n                // Add the canvas to current line\n                line.push(canvas)\n\n                // Add the canvas image data to current line\n                pixels.push(context.getImageData(0, 0, canvas.width, canvas.height).data)\n            }\n\n            // Add the line to canvas grid\n            this.pixels.push(pixels)\n            this.canvas.push(line)\n        }\n    }\n\n    getPixel(x, y) {\n        // Test coords validity\n        x = parseInt(x)\n        y = parseInt(y)\n\n        if (isNaN(x) || isNaN(y)) {\n            throw new Error('[x, y] params must be Integer.')\n        }\n\n        // Test coords range\n        if (x < 0 || x >= this.size.width) {\n            throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width)\n        }\n\n        if (y < 0 || y >= this.size.height) {\n            throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height)\n        }\n\n        // Calculate target canvas coords\n        let col = parseInt(x / this.cellSize)\n        let row = parseInt(y / this.cellSize)\n\n        // Adjuste x/y values relative to canvas origin\n        col && (x -= this.cellSize * col)\n        row && (y -= this.cellSize * row)\n\n        // Get pixel data\n        let cellSize  = this.cellSize;\n\n        if (this.size.width < cellSize) {\n            cellSize = this.size.width\n        }\n        else if (this.size.width < cellSize * (col + 1)) {\n            cellSize = this.size.width % cellSize\n        }\n\n        let i         = (y * (cellSize * 4)) + (x * 4)\n        let pixels    = this.pixels[row][col]\n        let pixelData = pixels.slice(i, i + 4)\n\n        return {\n            color : { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n            gray  : (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n            grid  : { col, row },\n            coords: { x, y }\n        }\n    }\n}\n\n// Exports\nexport { CanvasGrid }\nexport default CanvasGrid\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lw.raster2gcode/canvas-grid.js","import CanvasGrid from './canvas-grid'\n\n// RasterToGcode class\nclass RasterToGcode extends CanvasGrid {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = Object.assign({\n            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\n            toolDiameter: 0.1,      // Tool diameter in millimeters\n            rapidRate   : 1500,     // Rapid rate in mm/min (G0 F value) nullish value to disable\n            feedRate    : 500,      // Feed rate in mm/min (G1 F value)\n            rateUnit    : 'mm/min', // Rapid/Feed rate unit [mm/min, mm/sec]\n\n            beamRange: { min: 0, max: 1 },   // Beam power range (Firmware value)\n            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\n            milling  : false, // EXPERIMENTAL\n            zSafe    : 5,     // Safe Z for fast move\n            zSurface : 0,     // Usinable surface (white pixels)\n            zDepth   : -10,   // Z depth (black pixels)\n            passDepth: 1,     // Pass depth in millimeters\n\n            offsets  : { X: 0, Y: 0 }, // Global coordinates offsets\n            trimLine : true,           // Trim trailing white pixels\n            joinPixel: true,           // Join consecutive pixels with same intensity\n            burnWhite: true,           // [true = G1 S0 | false = G0] on inner white pixels\n            verboseG : false,          // Output verbose GCode (print each commands)\n            diagonal : false,          // Go diagonally (increase the distance between points)\n            overscan : 0,              // Add some extra white space (in millimeters) before and after each line\n\n            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\n            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\n            filters: {\n                smoothing   : 0,      // Smoothing the input image ?\n                brightness  : 0,      // Image brightness [-255 to +255]\n                contrast    : 0,      // Image contrast [-255 to +255]\n                gamma       : 0,      // Image gamma correction [0.01 to 7.99]\n                grayscale   : 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n                shadesOfGray: 256,    // Number of shades of gray [2-256]\n                invertColor : false   // Invert color...\n            },\n\n            onProgress       : null, // On progress callbacks\n            onProgressContext: null, // On progress callback context\n\n            onDone       : null, // On done callback\n            onDoneContext: null, // On done callback context\n\n            onAbort       : null, // On abort callback\n            onAbortContext: null  // On abort callback context\n        }, settings || {})\n\n        // Init properties\n        super(settings)\n\n        // Milling settings\n        if (this.milling) {\n            if (this.zSafe < this.zSurface) {\n                throw new Error('\"zSafe\" must be greater to \"zSurface\"')\n            }\n\n            this.passes = Math.abs(Math.floor(this.zDepth / this.passDepth))\n        }\n\n        // Negative beam size ?\n        if (this.toolDiameter <= 0) {\n            throw new Error('\"toolDiameter\" must be positive')\n        }\n\n        // Uniforme ppi\n        if (! this.ppi.x) {\n            this.ppi = { x: this.ppi, y: this.ppi }\n        }\n\n        // Calculate PPM = Pixel Per Millimeters\n        this.ppm = {\n            x: parseFloat((2540 / (this.ppi.x * 100)).toFixed(10)),\n            y: parseFloat((2540 / (this.ppi.y * 100)).toFixed(10))\n        }\n\n        // Calculate scale ratio\n        this.scaleRatio = {\n            x: this.ppm.x / this.toolDiameter,\n            y: this.ppm.y / this.toolDiameter\n        }\n\n        // State...\n        this.running      = false\n        this.gcode        = null\n        this.gcodes       = null\n        this.currentLine  = null\n        this.lastCommands = null\n\n        // Output size in millimeters\n        this.outputSize = { width : 0, height: 0 }\n\n        // G0 command\n        this.G1 = ['G', 1]\n        this.G0 = ['G', this.burnWhite ? 1 : 0]\n\n        // Calculate beam offset\n        this.beamOffset = this.toolDiameter * 1000 / 2000\n\n        // Calculate real beam range\n        this.realBeamRange = {\n            min: this.beamRange.max / 100 * this.beamPower.min,\n            max: this.beamRange.max / 100 * this.beamPower.max\n        }\n\n        // Adjuste feed rate to mm/min\n        if (this.rateUnit === 'mm/sec') {\n            this.feedRate  *= 60\n\n            if (this.rapidRate) {\n                this.rapidRate *= 60\n            }\n        }\n\n        // Register user callbacks\n        this._registerUserCallbacks(this)\n    }\n\n    // Register user callbacks\n    _registerUserCallbacks(callbacks) {\n        // Register user callbacks\n        callbacks.onProgress && this.on('progress', callbacks.onProgress, callbacks.onProgressContext)\n        callbacks.onAbort && this.on('abort', callbacks.onAbort, callbacks.onAbortContext)\n        callbacks.onDone && this.on('done', callbacks.onDone, callbacks.onDoneContext)\n    }\n\n    // Process image\n    _processImage() {\n        // Call parent method\n        super._processImage()\n\n        // Calculate output size\n        this.outputSize = {\n            width : this.size.width  * (this.toolDiameter * 1000) / 1000,\n            height: this.size.height * (this.toolDiameter * 1000) / 1000\n        }\n    }\n\n    // Abort job\n    abort() {\n        this.running = false\n    }\n\n    // Process image and return gcode string\n    run(settings) {\n        if (this.running) {\n            return\n        }\n\n        // Reset state\n        this.running      = true\n        this.gcode        = []\n        this.gcodes       = []\n        this.lastCommands = {}\n        this.currentLine  = null\n\n        // Defaults settings\n        settings = settings || {}\n\n        // Register user callbacks\n        this._registerUserCallbacks(settings)\n\n        // Non blocking mode ?\n        let nonBlocking = this.nonBlocking\n\n        if (settings.nonBlocking !== undefined) {\n            nonBlocking = settings.nonBlocking\n        }\n\n        // Add gcode header\n        this._addHeader()\n\n        // Scan type ?\n        if (this.diagonal) {\n            this._scanDiagonally(nonBlocking)\n        }\n        else {\n            this._scanHorizontally(nonBlocking)\n        }\n\n        if (! nonBlocking) {\n            return this.gcode\n        }\n    }\n\n    _addHeader() {\n        // Base headers\n        this.gcode.push(\n            '; Generated by LaserWeb (lw.raster-to-gcode.js)',\n            '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm',\n            '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y,\n            '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y,\n            '; Tool diam. : ' + this.toolDiameter + ' mm',\n            '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit\n        )\n\n        if (this.rapidRate) {\n           this.gcode.push('; Rapid rate  : ' + this.rapidRate + ' ' + this.rateUnit)\n        }\n\n        if (this.milling) {\n            this.gcode.push(\n                '; Z safe     : ' + this.zSafe,\n                '; Z surface  : ' + this.zSurface,\n                '; Z depth    : ' + this.zDepth\n            )\n        }\n        else {\n            this.gcode.push(\n                '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,\n                '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %'\n            )\n        }\n\n        // Print activated options\n        let options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal']\n\n        for (var i = options.length - 1; i >= 0; i--) {\n            if (! this[options[i]]) {\n                options.splice(i, 1)\n            }\n        }\n\n        if (options.length) {\n            this.gcode.push('; Options    : ' + options.join(', '))\n        }\n\n        // Set feed rates\n        this.gcode.push('')\n\n        if (this.rapidRate) {\n           this.gcode.push('G0 F' + this.rapidRate)\n        }\n\n        this.gcode.push('G1 F' + this.feedRate)\n        this.gcode.push('')\n    }\n\n    // Map S value to pixel power\n    _mapPixelPower(value) {\n        let range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange\n        return value * (range.max - range.min) / 255 + range.min\n    }\n\n    // Compute and return a command, return null if not changed\n    _command(name, value) {\n        // If the value argument is an object\n        if (typeof value === 'object') {\n            // Computed commands line\n            let commands = Array.prototype.slice.call(arguments)\n            let command, line = []\n\n            // for each command\n            for (var i = 0, il = commands.length; i < il; i++) {\n                command = this._command.apply(this, commands[i])\n                command && line.push(command)\n            }\n\n            // Return the line if not empty\n            return line.length ? line.join(' ') : null\n        }\n\n        // Format the value\n        value = value.toFixed(this.precision[name] || 0)\n\n        // If the value was changed or if verbose mode on\n        if (this.verboseG || value !== this.lastCommands[name]) {\n            this.lastCommands[name] = value\n            return name + value\n        }\n\n        // No change\n        return null\n    }\n\n    // Get a pixel power value from the canvas data grid\n    _getPixelPower(x, y, defaultValue) {\n        try {\n            // Reverse Y value since canvas as top/left origin\n            y = this.size.height - y - 1\n\n            // Get pixel info\n            let pixel = this.getPixel(x, y)\n\n            // Reversed gray value [ 0 = white | 255 = black ]\n            return 255 - pixel.gray\n        }\n        catch (error) {\n            if (arguments.length === 3) {\n                return defaultValue\n            }\n            throw error\n        }\n    }\n\n    // Get a point from the current line with real world coordinates\n    _getPoint(index) {\n        // Get the point object from the current line\n        let point = this.currentLine[index]\n\n        // No point\n        if (! point) {\n            return null\n        }\n\n        // Commands\n        point.G = point.s ? ['G', 1] : this.G0\n        point.X = (point.x * this.toolDiameter) + this.offsets.X\n        point.Y = (point.y * this.toolDiameter) + this.offsets.Y\n        point.S = this._mapPixelPower(point.s)\n\n        // Offsets\n        if (this.diagonal) {\n            // Vertical offset\n            point.Y += this.toolDiameter\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n                point.Y -= this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n                point.Y += this.beamOffset\n            }\n        }\n        else {\n            // Vertical offset\n            point.Y += this.beamOffset\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n            }\n        }\n\n        // Return the point\n        return point\n    }\n\n    // Remove all trailing white spaces from the current line\n    _trimCurrentLine() {\n        // Remove white spaces from the left\n        let point = this.currentLine[0]\n\n        while (point && ! point.p) {\n            this.currentLine.shift()\n            point = this.currentLine[0]\n        }\n\n        // Remove white spaces from the right\n        point = this.currentLine[this.currentLine.length - 2]\n\n        while (point && ! point.p) {\n            this.currentLine.pop()\n            point = this.currentLine[this.currentLine.length - 2]\n        }\n\n        // Return the new line length\n        return this.currentLine.length\n    }\n\n    // Join pixel with same power\n    _reduceCurrentLine() {\n        // Line too short to be reduced\n        if (this.currentLine.length < 3) {\n            return this.currentLine.length\n        }\n\n        // Extract all points exept the first one\n        let points = this.currentLine.splice(1)\n\n        // Get current power\n        let power = this.currentLine[0].p\n\n        // For each extracted point\n        for (var point, i = 0, il = points.length - 1; i < il; i++) {\n            // Current point\n            point = points[i]\n\n            // On power change\n            if (power !== point.p) {\n                this.currentLine.push(point)\n            }\n\n            // Update power\n            power = point.p\n        }\n\n        // Add last point\n        this.currentLine.push(points[i])\n    }\n\n    // Add extra white pixels at the ends\n    _overscanCurrentLine(reversed) {\n        // Number of pixels to add on each side\n        let pixels = this.overscan / this.ppm.x\n\n        // Get first/last point\n        let firstPoint = this.currentLine[0]\n        let lastPoint  = this.currentLine[this.currentLine.length - 1]\n\n        // Is last white/colored point ?\n        firstPoint.s && (firstPoint.lastWhite  = true)\n        lastPoint.s  && (lastPoint.lastColored = true)\n\n        // Reversed line ?\n        reversed ? (lastPoint.s = 0) : (firstPoint.s = 0)\n\n        // Create left/right points\n        let rightPoint = { x: lastPoint.x + pixels , y: lastPoint.y , s: 0, p: 0 }\n        let leftPoint  = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 }\n\n        if (this.diagonal) {\n            leftPoint.y  += pixels\n            rightPoint.y -= pixels\n        }\n\n        // Add left/right points to current line\n        this.currentLine.unshift(leftPoint)\n        this.currentLine.push(rightPoint)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processCurrentLine(reversed) {\n        if (this.milling) {\n            return this._processMillingLine(reversed)\n        }\n\n        return this._processLaserLine(reversed)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processMillingLine(reversed) {\n        // Skip empty line\n        if (! this._trimCurrentLine()) {\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        let addCommand = (...args) => {\n            command = this._command(...args)\n            command && gcode.push(command)\n        }\n\n        // Get first point\n        point = this._getPoint(index)\n\n        let plung = false\n        let Z, zMax\n\n        let pass = (passNum) => {\n            // Move to start of the line\n            addCommand(['G', 0], ['Z', this.zSafe])\n            addCommand(['G', 0], ['X', point.X], ['Y', point.Y])\n            addCommand(['G', 0], ['Z', this.zSurface])\n\n            // For each point on the line\n            while (point) {\n                if (point.S) {\n                    if (plung) {\n                        addCommand(['G', 0], ['Z', this.zSurface])\n                        plung = false\n                    }\n\n                    Z    = point.S\n                    zMax = this.passDepth * passNum\n\n                    // Last pass\n                    if (passNum < this.passes) {\n                        Z = Math.max(Z, -zMax)\n                    }\n\n                    addCommand(['G', 1], ['Z', this.zSurface + Z])\n                    addCommand(['G', 1], ['X', point.X], ['Y', point.Y])\n                }\n                else {\n                    if (plung) {\n                        addCommand(['G', 1], ['Z', this.zSurface])\n                        plung = false\n                    }\n\n                    addCommand(['G', 0], ['Z', this.zSafe])\n                    addCommand(['G', 0], ['X', point.X], ['Y', point.Y])\n                }\n\n                if (point.lastWhite || point.lastColored) {\n                    plung = true\n                }\n\n                // Get next point\n                point = this._getPoint(++index)\n            }\n\n            // Move to Z safe\n            addCommand(['G', 1], ['Z', this.zSurface])\n            addCommand(['G', 0], ['Z', this.zSafe])\n        }\n\n        for (var i = 1; i <= this.passes; i++) {\n            pass(i)\n\n            if (! gcode.length) {\n                break\n            }\n\n            if (this.gcodes.length < i) {\n                this.gcodes.push([])\n            }\n            else {\n                this.gcodes[i - 1].push.apply(this.gcodes[i - 1], gcode)\n            }\n\n            index = 0\n            gcode = []\n            point = this._getPoint(index)\n\n            this.lastCommands = {}\n        }\n\n        // Not sure what to return...\n        return null\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processLaserLine(reversed) {\n        // Trim trailing white spaces ?\n        if (this.trimLine && ! this._trimCurrentLine()) {\n            // Skip empty line\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Overscan ?\n        if (this.overscan) {\n            this._overscanCurrentLine(reversed)\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        let addCommand = (...args) => {\n            command = this._command(...args)\n            command && gcode.push(command)\n        }\n\n        // Get first point\n        point = this._getPoint(index)\n\n        // Move to start of the line\n        addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0])\n\n        // Get next point\n        point = this._getPoint(++index)\n\n        // For each point on the line\n        while (point) {\n            // Burn to next point\n            addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S])\n\n            // Get next point\n            point = this._getPoint(++index)\n        }\n\n        // Return gcode commands array\n        if (gcode.length) {\n            return gcode\n        }\n\n        // Empty line\n        return null\n    }\n\n    // Parse horizontally\n    _scanHorizontally(nonBlocking) {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // For each pixel on the line\n            for (x = 0; x <= w; x++) {\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && ! point.p && p\n                lastColored = point && point.p && ! p\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add point to current line\n                this.currentLine.push(point)\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            // Aborted ?\n            if (! this.running) {\n                return this._onAbort()\n            }\n\n            // Process line...\n            computeCurrentLine()\n            processCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                if (this.milling) {\n                    this.gcodes.forEach(gcode => {\n                        this.gcode.push.apply(this.gcode, gcode)\n                    })\n                }\n\n                this._onDone({ gcode: this.gcode })\n                this.running = false\n            }\n        }\n\n        processNextLine()\n    }\n\n    // Parse diagonally\n    _scanDiagonally(nonBlocking) {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let totalLines  = w + h - 1\n        let lineNum     = 0\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = (x, y) => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // Increment line num\n            lineNum++\n\n            while(true) {\n                // Y limit reached !\n                if (y < -1 || y == h) {\n                    break\n                }\n\n                // X limit reached !\n                if (x < 0 || x > w) {\n                    break\n                }\n\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && (! point.p && p)\n                lastColored = point && (point.p && ! p)\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add the new point\n                this.currentLine.push(point)\n\n                // Next coords\n                x++\n                y--\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((lineNum / totalLines) * 100)\n\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            // Aborted ?\n            if (! this.running) {\n                return this._onAbort()\n            }\n\n            // Process line...\n            computeCurrentLine(x, y)\n            processCurrentLine()\n\n            if (! x) y++\n            else x++\n\n            if (y === h) {\n                x++\n                y--\n            }\n\n            if (y < h && x < w) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n                this.running = false\n            }\n        }\n\n        processNextLine()\n    }\n\n    _onProgress(event) {\n        //console.log('progress:', event.percent)\n    }\n\n    _onDone(event) {\n        //console.log('done:', event.gcode.length)\n    }\n\n    _onAbort() {\n        //console.log('abort')\n    }\n\n    on(event, callback, context) {\n        let method = '_on' + event[0].toUpperCase() + event.slice(1)\n\n        if (! this[method] || typeof this[method] !== 'function') {\n            throw new Error('Undefined event: ' + event)\n        }\n\n        this[method] = event => callback.call(context || this, event)\n\n        return this\n    }\n\n    // Return the bitmap height-map\n    getHeightMap(settings) {\n        if (this.running) {\n            return\n        }\n\n        // Init loop vars\n        this.running  = true\n        let heightMap = []\n\n        let x = 0\n        let y = 0\n        let w = this.size.width\n        let h = this.size.height\n\n        let percent     = 0\n        let lastPercent = 0\n\n        // Defaults settings\n        settings = settings || {}\n\n        // Register user callbacks\n        this._registerUserCallbacks(settings)\n\n        // Non blocking mode ?\n        let nonBlocking = this.nonBlocking\n\n        if (settings.nonBlocking !== undefined) {\n            nonBlocking = settings.nonBlocking\n        }\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            let pixels = []\n\n            // For each pixel on the line\n            for (x = 0; x < w; x++) {\n                pixels.push(this._mapPixelPower(this._getPixelPower(x, y)))\n            }\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n\n            if (percent > lastPercent) {\n                //onProgress.call(settings.progressContext || this, { pixels, percent })\n                this._onProgress({ pixels, percent })\n            }\n\n            lastPercent = percent\n\n            // Add pixels line\n            heightMap.push(pixels)\n        }\n\n        let processNextLine = () => {\n            // Aborted ?\n            if (! this.running) {\n                return this._onAbort()\n            }\n\n            // Process line...\n            computeCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                //onDone.call(settings.doneContext || this, { heightMap })\n                this._onDone({ heightMap })\n                this.running = false\n            }\n        }\n\n        processNextLine()\n\n        if (! nonBlocking) {\n            return heightMap\n        }\n    }\n}\n\n// Exports\nexport { RasterToGcode }\nexport default RasterToGcode\n\n\n\n// WEBPACK FOOTER //\n// ./lib/lw.raster2gcode/raster-to-gcode.js","/*\n * floyd-steinberg\n *\n * Using 2D error diffusion formula published by Robert Floyd and Louis Steinberg in 1976\n *\n * Javascript implementation of Floyd-Steinberg algorithm thanks to Forrest Oliphant @forresto and @meemoo \n * via iFramework https://github.com/meemoo/iframework/blob/master/src/nodes/image-monochrome-worker.js\n *\n * Accepts an object that complies with the HTML5 canvas imageData spec https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * In particular, it makes use of the width, height, and data properties\n *\n * License: MIT\n*/\n\nmodule.exports = floyd_steinberg;\n\nfunction floyd_steinberg(image) {\n  var imageData = image.data;\n  var imageDataLength = imageData.length;\n  var w = image.width;\n  var lumR = [],\n      lumG = [],\n      lumB = [];\n\n  var newPixel, err;\n\n  for (var i = 0; i < 256; i++) {\n    lumR[i] = i * 0.299;\n    lumG[i] = i * 0.587;\n    lumB[i] = i * 0.110;\n  }\n\n  // Greyscale luminance (sets r pixels to luminance of rgb)\n  for (var i = 0; i <= imageDataLength; i += 4) {\n    imageData[i] = Math.floor(lumR[imageData[i]] + lumG[imageData[i+1]] + lumB[imageData[i+2]]);\n  }\n\n  for (var currentPixel = 0; currentPixel <= imageDataLength; currentPixel += 4) {\n    // threshold for determining current pixel's conversion to a black or white pixel\n    newPixel = imageData[currentPixel] < 150 ? 0 : 255;\n    err = Math.floor((imageData[currentPixel] - newPixel) / 23);\n    imageData[currentPixel] = newPixel;\n    imageData[currentPixel + 4         ] += err * 7;\n    imageData[currentPixel + 4 * w - 4 ] += err * 3;\n    imageData[currentPixel + 4 * w     ] += err * 5;\n    imageData[currentPixel + 4 * w + 4 ] += err * 1;\n    // Set g and b pixels equal to r (effectively greyscales the image fully)\n    imageData[currentPixel + 1] = imageData[currentPixel + 2] = imageData[currentPixel];\n  }\n\n  return image;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/floyd-steinberg/floyd-steinberg.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}